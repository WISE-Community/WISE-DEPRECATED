{"version":3,"sources":["studentDataService.es6"],"names":["StudentDataService","$filter","$http","$injector","$q","$rootScope","AnnotationService","ConfigService","ProjectService","UtilService","$translate","currentNode","previousStep","studentData","stackHistory","visitedNodesHistory","nodeStatuses","runStatus","maxScore","maxPlanningNodeNumber","saveToServerRequestCount","dummyStudentWorkId","$on","event","args","calculateActiveGlobalAnnotationGroups","globalAnnotationGroups","getActiveGlobalAnnotationGroups","map","globalAnnotationGroup","globalAnnotations","annotations","globalAnnotation","data","isGlobal","unGlobalizeConditional","unGlobalizeCriteriaArray","unGlobalizeCriteria","anySatified","unGlobalizeCriteriaResult","evaluateCriteria","unGlobalizedTimestamp","Date","parse","saveAnnotations","allSatisfied","annotation","handleAnnotationReceived","isPreview","componentStates","nodeStates","events","userName","userId","setAnnotations","populateHistories","updateNodeStatuses","studentDataURL","getConfigParam","httpParams","method","url","params","workgroupId","getWorkgroupId","runId","getRunId","getStudentWork","getEvents","getAnnotations","toWorkgroupId","then","result","resultData","studentWorkList","studentWork","componentId","push","project","nodes","length","planningGroupNode","planning","lastestNodeStateForPlanningGroupNode","getLatestNodeStateByNodeId","id","studentModifiedNodes","studentModifiedNode","studentModifiedNodeId","n","ids","parseProject","runStatusURL","headers","nodeId","nodeStatus","getNodes","planningNodes","getPlanningNodes","groups","getGroups","concat","node","isGroupNode","updateNodeStatusByNode","group","depth","getNodeDepth","sort","a","b","getMaxScore","$broadcast","tempNodeStatus","isVisitable","isCompleted","constraintsForNode","getConstraintsForNode","getFlattenedProjectAsNodeIds","indexOf","isVisible","isVisibleResults","isVisitableResults","firstResult","constraintForNode","tempResult","evaluateConstraint","action","isVisibleResult","isVisitableResult","isVisited","isNodeVisited","getNodeStatusByNodeId","setNodeStatusByNodeId","previousIsCompletedValue","progress","getNodeProgressById","icon","getNodeIconByNodeId","latestComponentStatesForNode","getLatestComponentStateByNodeId","latestComponentStateClientSaveTime","clientSaveTime","latestComponentStateServerSaveTime","serverSaveTime","removalCriteria","evaluateNodeConstraint","visitedNodes","getVisitedNodesHistory","transitionsToNodeId","visitedNodeId","transitions","getTransitionsByFromAndToNodeId","isStartNode","removalConditional","tempCriteria","criteria","functionName","name","evaluateBranchPathTakenCriteria","evaluateIsVisitedCriteria","evaluateIsVisitedAfterCriteria","evaluateIsRevisedAfterCriteria","evaluateIsVisitedAndRevisedAfterCriteria","evaluateIsCompletedCriteria","evaluateIsCorrectCriteria","evaluateChoiceChosenCriteria","evaluateIsPlanningActivityCompletedCriteria","evaluateScoreCriteria","evaluateUsedXSubmitsCriteria","evaluateNumberOfWordsWrittenCriteria","getComponentStatesByNodeIdAndComponentId","componentState","isCorrect","planningStepsCreated","planningStepsCompleted","planningStepsCreatedSatisfied","planningStepsCompletedSatisfied","getNodeStatesByNodeId","ns","planningStepCount","nodeState","type","planningNodeTemplateId","expectedFromNodeId","fromNodeId","expectedToNodeId","toNodeId","branchPathTakenEvents","getBranchPathTakenEventsByNodeId","branchPathTakenEvent","isVisitedAfterNodeId","criteriaCreatedTimestamp","isRevisedAfterNodeId","isRevisedAfterComponentId","latestComponentStateForRevisedComponent","getLatestComponentStateByNodeIdAndComponentId","serviceName","has","service","get","choiceChosen","scores","scoreType","latestScoreAnnotation","getLatestScoreAnnotation","scoreValue","getScoreValueFromScoreAnnotation","toString","requiredSubmitCount","manualSubmitCounter","highestSubmitCounter","isSubmit","submitCounter","requiredNumberOfWords","response","numberOfWords","wordCount","updateStackHistory","updateVisitedNodesHistory","index","indexOfNodeId","splice","timestamp","nodeStatesByNodeId","tempNodeId","notebookItemId","component","category","alert","context","componentType","saveEvent","newEvent","createNewEvent","saveToServer","projectId","getProjectId","periodId","getPeriodId","requestToken","generateKey","addComponentState","addNodeState","addEvent","addAnnotation","savedStudentDataResponse","saveToServerSuccess","deferred","defer","resolve","promise","angular","toJson","$","param","savedStudentWorkList","localStudentWorkList","savedStudentWork","l","localStudentWork","getMode","savedEvents","localEvents","savedEvent","localEvent","savedAnnotations","localAnnotations","savedAnnotation","localAnnotation","saveStudentStatus","studentStatusURL","getStudentStatusURL","currentNodeId","getCurrentNodeId","getNodeStatuses","projectCompletion","getProjectCompletion","studentStatusJSON","status","studentStatusParams","latestComponentState","getLatestComponentState","allNodeStatesByNodeId","c","componentStateNodeId","componentStateComponentId","studentWorkId","componentStatesByNodeId","componentStatesByNodeIdAndComponentId","eventsByNodeId","eventNodeId","eventComponentId","e","eventName","getNodeById","isActive","completedItems","completedItemsWithWork","totalItems","totalItemsWithWork","nodeIds","getChildNodeIdsById","groupProgress","hasWork","nodeHasWork","completionPct","Math","round","completionPctWithWork","componentEvents","getEventsByNodeIdAndComponentId","nodeEvents","getEventsByNodeId","getComponentByNodeIdAndComponentId","isGroup","components","getComponentsByNodeId","showPreviousWorkNodeId","showPreviousWorkComponentId","tempNode","tempComponentId","tempComponent","isComponentCompleted","console","log","setCurrentNode","previousCurrentNode","previousNode","nodeToExit","endCurrentNode","setCurrentNodeByNodeId","nodeClickLocked","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue","replace","finalValue","floatVal","parseFloat","isNaN","getTotalScore","currentMaxPlanningNodeNumber","getNodeStates","nodeStateNodeId","isPlanning","planningNodeIdRegEx","match","planningNodeNumber","parseInt","latestComponentStates","getComponentStatesByNodeId","completionCriteria","inOrder","tempTimestamp","completionCriterion","tempComponentState","getComponentStateSubmittedAfter","getComponentStateSavedAfter","tempEvent","getVisitEventAfter","showClassmateWorkSource","onlyGetLatest","p","hasOwnProperty","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":";;;;;;;;;;IAAMA,kB;AACJ,8BACIC,OADJ,EAEIC,KAFJ,EAGIC,SAHJ,EAIIC,EAJJ,EAKIC,UALJ,EAMIC,iBANJ,EAOIC,aAPJ,EAQIC,cARJ,EASIC,WATJ,EASiB;AAAA;;AAAA;;AACf,SAAKR,OAAL,GAAeA,OAAf;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,UAAL,GAAkB,KAAKT,OAAL,CAAa,WAAb,CAAlB;AACA,SAAKU,WAAL,GAAmB,IAAnB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,YAAL,GAAoB,EAApB,CAde,CAcU;AACzB,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,QAAL,GAAgB,IAAhB;;AAEA,SAAKC,qBAAL,GAA6B,CAA7B;;AAEA;;;;;;AAMA,SAAKC,wBAAL,GAAgC,CAAhC;;AAEA;;;;AAIA,SAAKC,kBAAL,GAA0B,CAA1B;;AAEA;AACA,SAAKhB,UAAL,CAAgBiB,GAAhB,CAAoB,qBAApB,EAA2C,UAACC,KAAD,EAAQC,IAAR,EAAiB;AAC1D;AACA,YAAKlB,iBAAL,CAAuBmB,qCAAvB;;AAEA;AACA,UAAIC,yBAAyB,MAAKpB,iBAAL,CAAuBqB,+BAAvB,EAA7B;AACAD,6BAAuBE,GAAvB,CAA2B,UAACC,qBAAD,EAA2B;AACpD,YAAIC,oBAAoBD,sBAAsBE,WAA9C;AACAD,0BAAkBF,GAAlB,CAAsB,UAACI,gBAAD,EAAsB;AAC1C,cAAIA,iBAAiBC,IAAjB,IAAyB,IAAzB,IAAiCD,iBAAiBC,IAAjB,CAAsBC,QAA3D,EAAqE;AACnE,gBAAIC,yBAAyBH,iBAAiBC,IAAjB,CAAsBE,sBAAnD;AACA,gBAAIC,2BAA2BJ,iBAAiBC,IAAjB,CAAsBI,mBAArD;AACA,gBAAID,4BAA4B,IAAhC,EAAsC;AACpC,kBAAID,2BAA2B,KAA/B,EAAsC;AACpC;AACA,oBAAIG,cAAc,KAAlB;AAFoC;AAAA;AAAA;;AAAA;AAGpC,uCAAgCF,wBAAhC,8HAA0D;AAAA,wBAAjDC,mBAAiD;;AACxD,wBAAIE,4BAA4B,MAAKC,gBAAL,CAAsBH,mBAAtB,CAAhC;AACAC,kCAAcA,eAAeC,yBAA7B;AACD;AANmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOpC,oBAAID,WAAJ,EAAiB;AACfN,mCAAiBC,IAAjB,CAAsBQ,qBAAtB,GAA8CC,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAA9C,CADe,CACwD;AACvE,wBAAKE,eAAL,CAAqB,CAACZ,gBAAD,CAArB,EAFe,CAE4B;AAC5C;AACF,eAXD,MAWO,IAAIG,2BAA2B,KAA/B,EAAsC;AAC3C;AACA,oBAAIU,eAAe,IAAnB;AAF2C;AAAA;AAAA;;AAAA;AAG3C,wCAAgCT,wBAAhC,mIAA0D;AAAA,wBAAjDC,oBAAiD;;AACxD,wBAAIE,6BAA4B,MAAKC,gBAAL,CAAsBH,oBAAtB,CAAhC;AACAQ,mCAAeA,gBAAgBN,0BAA/B;AACD;AAN0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAO3C,oBAAIM,YAAJ,EAAkB;AAChBb,mCAAiBC,IAAjB,CAAsBQ,qBAAtB,GAA8CC,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAA9C,CADgB,CACuD;AACvE,wBAAKE,eAAL,CAAqB,CAACZ,gBAAD,CAArB,EAFgB,CAE2B;AAC5C;AACF;AACF;AACF;AACF,SA9BD;AA+BD,OAjCD;AAkCD,KAxCD;;AA0CA;;;;AAIA,SAAK3B,UAAL,CAAgBiB,GAAhB,CAAoB,uBAApB,EAA6C,UAACC,KAAD,EAAQC,IAAR,EAAiB;AAC5D,UAAIA,IAAJ,EAAU;AACR;AACA,YAAIsB,aAAatB,KAAKsB,UAAtB;AACA,cAAKC,wBAAL,CAA8BD,UAA9B;AACD;AACF,KAND;AAOD;;;;0CAEqB;AAAA;;AACpB,UAAI,KAAKvC,aAAL,CAAmByC,SAAnB,EAAJ,EAAoC;AAClC;AACA,aAAKnC,WAAL,GAAmB,EAAnB;AACA,aAAKA,WAAL,CAAiBoC,eAAjB,GAAmC,EAAnC;AACA,aAAKpC,WAAL,CAAiBqC,UAAjB,GAA8B,EAA9B;AACA,aAAKrC,WAAL,CAAiBsC,MAAjB,GAA0B,EAA1B;AACA,aAAKtC,WAAL,CAAiBkB,WAAjB,GAA+B,EAA/B;AACA,aAAKlB,WAAL,CAAiBuC,QAAjB,GAA4B,KAAK1C,UAAL,CAAgB,iBAAhB,CAA5B;AACA,aAAKG,WAAL,CAAiBwC,MAAjB,GAA0B,GAA1B;;AAEA;AACA,aAAK/C,iBAAL,CAAuBgD,cAAvB,CAAsC,KAAKzC,WAAL,CAAiBkB,WAAvD;;AAEA;AACA,aAAKwB,iBAAL,CAAuB,KAAK1C,WAAL,CAAiBsC,MAAxC;;AAEA;AACA,aAAKK,kBAAL;AACD,OAlBD,MAkBO;AACL,YAAMC,iBAAiB,KAAKlD,aAAL,CAAmBmD,cAAnB,CAAkC,gBAAlC,CAAvB;;AAEA,YAAMC,aAAa,EAAnB;AACAA,mBAAWC,MAAX,GAAoB,KAApB;AACAD,mBAAWE,GAAX,GAAiBJ,cAAjB;;AAEA,YAAMK,SAAS,EAAf;AACAA,eAAOC,WAAP,GAAqB,KAAKxD,aAAL,CAAmByD,cAAnB,EAArB;AACAF,eAAOG,KAAP,GAAe,KAAK1D,aAAL,CAAmB2D,QAAnB,EAAf;AACAJ,eAAOK,cAAP,GAAwB,IAAxB;AACAL,eAAOM,SAAP,GAAmB,IAAnB;AACAN,eAAOO,cAAP,GAAwB,IAAxB;AACAP,eAAOQ,aAAP,GAAuB,KAAK/D,aAAL,CAAmByD,cAAnB,EAAvB;AACAL,mBAAWG,MAAX,GAAoBA,MAApB;;AAEA;AACA,eAAO,KAAK5D,KAAL,CAAWyD,UAAX,EAAuBY,IAAvB,CAA4B,UAACC,MAAD,EAAY;AAC7C,cAAMC,aAAaD,OAAOvC,IAA1B;AACA,cAAIwC,cAAc,IAAlB,EAAwB;AACtB,mBAAK5D,WAAL,GAAmB,EAAnB;;AAEA;AACA,mBAAKA,WAAL,CAAiBoC,eAAjB,GAAmC,EAAnC;AACA,mBAAKpC,WAAL,CAAiBqC,UAAjB,GAA8B,EAA9B;AACA,gBAAMwB,kBAAkBD,WAAWC,eAAnC;AANsB;AAAA;AAAA;;AAAA;AAOtB,oCAAwBA,eAAxB,mIAAyC;AAAA,oBAAhCC,WAAgC;;AACvC,oBAAIA,YAAYC,WAAZ,IAA2B,IAA/B,EAAqC;AACnC,yBAAK/D,WAAL,CAAiBoC,eAAjB,CAAiC4B,IAAjC,CAAsCF,WAAtC;AACD,iBAFD,MAEO;AACL,yBAAK9D,WAAL,CAAiBqC,UAAjB,CAA4B2B,IAA5B,CAAiCF,WAAjC;AACD;AACF;;AAED;AAfsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBtB,gBAAI,OAAKnE,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,IAAqC,IAArC,IAA6C,OAAKvE,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,CAAkCC,MAAlC,GAA2C,CAA5F,EAA+F;AAC7F;AAD6F;AAAA;AAAA;;AAAA;AAE7F,sCAA8B,OAAKxE,cAAL,CAAoBsE,OAApB,CAA4BC,KAA1D,mIAAiE;AAAA,sBAAxDE,iBAAwD;;AAC/D,sBAAIA,kBAAkBC,QAAtB,EAAgC;AAC9B,wBAAIC,uCAAuC,OAAKC,0BAAL,CAAgCH,kBAAkBI,EAAlD,CAA3C;AACA,wBAAIF,wCAAwC,IAA5C,EAAkD;AAChD,0BAAIG,uBAAuBH,qCAAqCtE,WAArC,CAAiDkE,KAA5E;AACA,0BAAIO,wBAAwB,IAA5B,EAAkC;AAAA;AAAA;AAAA;;AAAA;AAChC,gDAAgCA,oBAAhC,mIAAsD;AAAA,gCAA7CC,mBAA6C;;AACpD,gCAAIC,wBAAwBD,oBAAoBF,EAAhD;AACA,gCAAIE,oBAAoBL,QAAxB,EAAkC;AAChC;AACA,mCAAK,IAAIO,IAAI,CAAb,EAAgBA,IAAI,OAAKjF,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,CAAkCC,MAAtD,EAA8DS,GAA9D,EAAmE;AACjE,oCAAI,OAAKjF,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,CAAkCU,CAAlC,EAAqCJ,EAArC,KAA4CG,qBAAhD,EAAuE;AACrE;AACA,yCAAKhF,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,CAAkCU,CAAlC,EAAqCC,GAArC,GAA2CH,oBAAoBG,GAA/D;AACD;AACF;AACF,6BARD,MAQO;AACL;AACA,qCAAKlF,cAAL,CAAoBsE,OAApB,CAA4BC,KAA5B,CAAkCF,IAAlC,CAAuCU,mBAAvC;AACD;AACF;AAf+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBjC;AACF;AACF;AACF;AACD;AA3B6F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4B7F,qBAAK/E,cAAL,CAAoBmF,YAApB;AACD;;AAED,mBAAK9E,WAAL,CAAiBsC,MAAjB,GAA0BsB,WAAWtB,MAArC;AACA,mBAAKtC,WAAL,CAAiBkB,WAAjB,GAA+B0C,WAAW1C,WAA1C;AACA,mBAAKzB,iBAAL,CAAuBgD,cAAvB,CAAsC,OAAKzC,WAAL,CAAiBkB,WAAvD;AACA,mBAAKwB,iBAAL,CAAuB,OAAK1C,WAAL,CAAiBsC,MAAxC;AACA,mBAAKK,kBAAL;AACD;;AAED,iBAAO,OAAK3C,WAAZ;AACD,SAzDM,CAAP;AA0DD;AACF;;;;;AAED;;;wCAGoB;AAAA;;AAClB,UAAI,KAAKN,aAAL,CAAmByC,SAAnB,EAAJ,EAAoC;AAClC,aAAK/B,SAAL,GAAiB,EAAjB;AACD,OAFD,MAEO;AACL,YAAM2E,eAAe,KAAKrF,aAAL,CAAmBmD,cAAnB,CAAkC,cAAlC,CAArB;AACA,YAAMO,QAAQ,KAAK1D,aAAL,CAAmBmD,cAAnB,CAAkC,OAAlC,CAAd;;AAEA,YAAMI,SAAS;AACbG,iBAAMA;AADO,SAAf;;AAIA,YAAMN,aAAa,EAAnB;AACAA,mBAAWC,MAAX,GAAoB,KAApB;AACAD,mBAAWkC,OAAX,GAAqB,EAAC,gBAAgB,mCAAjB,EAArB;AACAlC,mBAAWE,GAAX,GAAiB+B,YAAjB;AACAjC,mBAAWG,MAAX,GAAoBA,MAApB;;AAEA,eAAO,KAAK5D,KAAL,CAAWyD,UAAX,EAAuBY,IAAvB,CAA4B,UAACC,MAAD,EAAY;AAC7C,cAAIA,UAAU,IAAd,EAAoB;AAClB,gBAAMvC,OAAOuC,OAAOvC,IAApB;AACA,gBAAIA,QAAQ,IAAZ,EAAkB;AAChB,qBAAKhB,SAAL,GAAiBgB,IAAjB;AACD;AACF;AACF,SAPM,CAAP;AAQD;AACF;;;sCAEiB;AAChB,aAAO,KAAKjB,YAAZ;AACD;;;0CAEqB8E,M,EAAQC,U,EAAY;AACxC,UAAID,UAAU,IAAV,IAAkBC,cAAc,IAApC,EAA0C;AACxC,YAAM/E,eAAe,KAAKA,YAA1B;AACA,YAAIA,gBAAgB,IAApB,EAA0B;AACxBA,uBAAa8E,MAAb,IAAuBC,UAAvB;AACD;AACF;AACF;;;0CAEqBD,M,EAAQ;AAC5B,UAAM9E,eAAe,KAAKA,YAA1B;AACA,UAAI8E,UAAU,IAAV,IAAkB9E,gBAAgB,IAAtC,EAA4C;AAC1C,eAAOA,aAAa8E,MAAb,CAAP;AACD;AACD,aAAO,IAAP;AACD;;;yCAEoB;AACnB,UAAIf,QAAQ,KAAKvE,cAAL,CAAoBwF,QAApB,EAAZ;AACA,UAAIC,gBAAgB,KAAKzF,cAAL,CAAoB0F,gBAApB,EAApB;AACA,UAAMC,SAAS,KAAK3F,cAAL,CAAoB4F,SAApB,EAAf;;AAEA,UAAIrB,SAAS,IAAb,EAAmB;AACjB,YAAIkB,iBAAiB,IAArB,EAA2B;AACzBlB,kBAAQA,MAAMsB,MAAN,CAAaJ,aAAb,CAAR;AACD;AAHgB;AAAA;AAAA;;AAAA;AAIjB,gCAAiBlB,KAAjB,mIAAwB;AAAA,gBAAfuB,IAAe;;AACtB,gBAAI,CAAC,KAAK9F,cAAL,CAAoB+F,WAApB,CAAgCD,KAAKjB,EAArC,CAAL,EAA+C;AAC7C,mBAAKmB,sBAAL,CAA4BF,IAA5B;AACD;AACF;AARgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASlB;;AAED,UAAIG,cAAJ;AACA,UAAIN,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,gCAAkBA,MAAlB,mIAA0B;AAAA,gBAAjBM,MAAiB;;AACxBA,mBAAMC,KAAN,GAAc,KAAKlG,cAAL,CAAoBmG,YAApB,CAAiCF,OAAMpB,EAAvC,CAAd;AACD;;AAED;AALkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMlBc,eAAOS,IAAP,CAAY,UAASC,CAAT,EAAYC,CAAZ,EAAe;AACzB,iBAAOA,EAAEJ,KAAF,GAAUG,EAAEH,KAAnB;AACD,SAFD;;AANkB;AAAA;AAAA;;AAAA;AAUlB,gCAAkBP,MAAlB,mIAA0B;AAAA,gBAAjBM,OAAiB;;AACxB,iBAAKD,sBAAL,CAA4BC,OAA5B;AACD;AAZiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAanB;;AAED;AACA,WAAKvF,QAAL,GAAgB,KAAK6F,WAAL,EAAhB;AACA,WAAK1G,UAAL,CAAgB2G,UAAhB,CAA2B,qBAA3B;AACD;;;;;AAED;;;;2CAIuBV,I,EAAM;AAC3B,UAAIA,QAAQ,IAAZ,EAAkB;AAChB,YAAMR,SAASQ,KAAKjB,EAApB;AACA,YAAM4B,iBAAiB,EAAvB;AACAA,uBAAenB,MAAf,GAAwBA,MAAxB;AACAmB,uBAAeC,WAAf,GAA6B,IAA7B;AACAD,uBAAeE,WAAf,GAA6B,IAA7B;;AAEA;AACA,YAAIC,qBAAqB,KAAK5G,cAAL,CAAoB6G,qBAApB,CAA0Cf,IAA1C,CAAzB;;AAEA,YAAI,KAAK/F,aAAL,CAAmBmD,cAAnB,CAAkC,aAAlC,KAAoD,KAAxD,EAA+D;AAC7D;;;;AAIA0D,+BAAqB,IAArB;AACD;;AAED,YAAIA,sBAAsB,IAAtB,IAA8BA,mBAAmBpC,MAAnB,IAA6B,CAA/D,EAAkE;AAChE,cAAI,KAAKxE,cAAL,CAAoB8G,4BAApB,GAAmDC,OAAnD,CAA2DzB,MAA3D,KAAsE,CAAC,CAAvE,IACF,CAAC,KAAKtF,cAAL,CAAoB+F,WAApB,CAAgCT,MAAhC,CADH,EAC4C;AAC1C;AACAmB,2BAAeO,SAAf,GAA2B,KAA3B;AACAP,2BAAeC,WAAf,GAA6B,IAA7B;AACD,WALD,MAKO;AACL;AACAD,2BAAeO,SAAf,GAA2B,IAA3B;AACAP,2BAAeC,WAAf,GAA6B,IAA7B;AACD;AACF,SAXD,MAWO;AACL,cAAMO,mBAAmB,EAAzB;AACA,cAAMC,qBAAqB,EAA3B;;AAEA,cAAIlD,SAAS,KAAb;AACA,cAAMmD,cAAc,IAApB;;AALK;AAAA;AAAA;;AAAA;AAOL,kCAA8BP,kBAA9B,mIAAkD;AAAA,kBAAzCQ,iBAAyC;;AAChD,kBAAIA,qBAAqB,IAAzB,EAA+B;AAC7B;AACA,oBAAMC,aAAa,KAAKC,kBAAL,CAAwBxB,IAAxB,EAA8BsB,iBAA9B,CAAnB;;AAEA,oBAAMG,SAASH,kBAAkBG,MAAjC;;AAEA,oBAAIA,UAAU,IAAd,EAAoB;AAClB,sBAAIA,WAAW,wBAAf,EAAyC;AACvCN,qCAAiB5C,IAAjB,CAAsBgD,UAAtB;AACD,mBAFD,MAEO,IAAIE,WAAW,0BAAf,EAA2C;AAChDL,uCAAmB7C,IAAnB,CAAwBgD,UAAxB;AACD,mBAFM,MAEA,IAAIE,WAAW,iCAAf,EAAkD;AACvDN,qCAAiB5C,IAAjB,CAAsBgD,UAAtB;AACD,mBAFM,MAEA,IAAIE,WAAW,mCAAf,EAAoD;AACzDL,uCAAmB7C,IAAnB,CAAwBgD,UAAxB;AACD,mBAFM,MAEA,IAAIE,WAAW,6BAAf,EAA8C;AACnDN,qCAAiB5C,IAAjB,CAAsBgD,UAAtB;AACD,mBAFM,MAEA,IAAIE,WAAW,+BAAf,EAAgD;AACrDL,uCAAmB7C,IAAnB,CAAwBgD,UAAxB;AACD;AACF;AACF;AACF;AA9BI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgCL,cAAIL,YAAY,IAAhB;AACA,cAAIN,cAAc,IAAlB;;AAjCK;AAAA;AAAA;;AAAA;AAmCL,mCAA4BO,gBAA5B,wIAA8C;AAAA,kBAArCO,eAAqC;;AAC5CR,0BAAYA,aAAaQ,eAAzB;AACD;AArCI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAuCL,mCAA8BN,kBAA9B,wIAAkD;AAAA,kBAAzCO,iBAAyC;;AAChDf,4BAAcA,eAAee,iBAA7B;AACD;AAzCI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2CLhB,yBAAeO,SAAf,GAA2BA,SAA3B;AACAP,yBAAeC,WAAf,GAA6BA,WAA7B;AACD;;AAEDD,uBAAeE,WAAf,GAA6B,KAAKA,WAAL,CAAiBrB,MAAjB,CAA7B;AACAmB,uBAAeiB,SAAf,GAA2B,KAAKC,aAAL,CAAmBrC,MAAnB,CAA3B;;AAEA,YAAMC,aAAa,KAAKqC,qBAAL,CAA2BtC,MAA3B,CAAnB;;AAEA,YAAIC,cAAc,IAAlB,EAAwB;AACtB,eAAKsC,qBAAL,CAA2BvC,MAA3B,EAAmCmB,cAAnC;AACD,SAFD,MAEO;AACL;;;;AAIA,cAAMqB,2BAA2B,KAAKtH,YAAL,CAAkB8E,MAAlB,EAA0BqB,WAA3D;;AAEA,eAAKnG,YAAL,CAAkB8E,MAAlB,EAA0BoC,SAA1B,GAAsCjB,eAAeiB,SAArD;AACA,eAAKlH,YAAL,CAAkB8E,MAAlB,EAA0B0B,SAA1B,GAAsCP,eAAeO,SAArD;AACA,eAAKxG,YAAL,CAAkB8E,MAAlB,EAA0BoB,WAA1B,GAAwCD,eAAeC,WAAvD;AACA,eAAKlG,YAAL,CAAkB8E,MAAlB,EAA0BqB,WAA1B,GAAwCF,eAAeE,WAAvD;;AAEA,cAAImB,4BAA4B,KAA5B,IAAqCrB,eAAeE,WAAxD,EAAqE;AACnE;;;;AAIA,iBAAK9G,UAAL,CAAgB2G,UAAhB,CAA2B,eAA3B,EAA4C,EAAElB,QAAQA,MAAV,EAA5C;AACD;AACF;;AAED,aAAK9E,YAAL,CAAkB8E,MAAlB,EAA0ByC,QAA1B,GAAqC,KAAKC,mBAAL,CAAyB1C,MAAzB,CAArC;AACA,aAAK9E,YAAL,CAAkB8E,MAAlB,EAA0B2C,IAA1B,GAAiC,KAAKjI,cAAL,CAAoBkI,mBAApB,CAAwC5C,MAAxC,CAAjC;;AAEA;AACA,YAAM6C,+BAA+B,KAAKC,+BAAL,CAAqC9C,MAArC,CAArC;AACA,YAAI6C,gCAAgC,IAApC,EAA0C;AACxC;AACA,eAAK3H,YAAL,CAAkB8E,MAAlB,EAA0B+C,kCAA1B,GAA+DF,6BAA6BG,cAA5F;AACA,eAAK9H,YAAL,CAAkB8E,MAAlB,EAA0BiD,kCAA1B,GAA+DJ,6BAA6BK,cAA5F;AACD;AACF;AACF;;;;;AAED;;;;;;uCAMmB1C,I,EAAMsB,iB,EAAmB;AAC1C,UAAIA,qBAAqB,IAAzB,EAA+B;AAC7B,YAAMqB,kBAAkBrB,kBAAkBqB,eAA1C;AACA,YAAIA,mBAAmB,IAAvB,EAA6B;AAC3B,iBAAO,KAAKC,sBAAL,CAA4B5C,IAA5B,EAAkCsB,iBAAlC,CAAP;AACD;AACF;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;;uDAMmCtB,I,EAAMsB,iB,EAAmB;AAC1D,UAAIpD,SAAS,KAAb;AACA,UAAI8B,QAAQ,IAAZ,EAAkB;AAChB,YAAMR,SAASQ,KAAKjB,EAApB;;AAEA,YAAI,KAAK8C,aAAL,CAAmBrC,MAAnB,CAAJ,EAAgC;AAC9B;AACAtB,mBAAS,IAAT;AACD,SAHD,MAGO;AACL;AACA,cAAM2E,eAAe,KAAKC,sBAAL,EAArB;;AAEA,cAAIC,sBAAsB,EAA1B;;AAJK;AAAA;AAAA;;AAAA;AAML,mCAA0BF,YAA1B,wIAAwC;AAAA,kBAA/BG,aAA+B;;AACtC;AACA,kBAAMC,cAAc,KAAK/I,cAAL,CAAoBgJ,+BAApB,CAAoDF,aAApD,EAAmExD,MAAnE,CAApB;;AAEA;;AAEA;AACAuD,oCAAsBA,oBAAoBhD,MAApB,CAA2BkD,WAA3B,CAAtB;AACD;AAdI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBL,cAAIF,uBAAuB,IAAvB,IAA+BA,oBAAoBrE,MAApB,GAA6B,CAAhE,EAAmE;AACjE;;AAEA;;;;AAIAR,qBAAS,IAAT;AACD,WARD,MAQO;AACL;;;;AAIAA,qBAAS,KAAT;AACD;;AAED,cAAI,KAAKhE,cAAL,CAAoBiJ,WAApB,CAAgCnD,IAAhC,CAAJ,EAA2C;AACzC;;;;AAIA9B,qBAAS,IAAT;AACD;AACF;AACF;AACD,aAAOA,MAAP;AACD;;;;;AAED;;;;;;2CAMuB8B,I,EAAMsB,iB,EAAmB;AAC9C,UAAIpD,SAAS,KAAb;;AAEA,UAAIoD,qBAAqB,IAAzB,EAA+B;AAC7B,YAAMqB,kBAAkBrB,kBAAkBqB,eAA1C;AACA,YAAMS,qBAAqB9B,kBAAkB8B,kBAA7C;AACA,YAAIT,mBAAmB,IAAvB,EAA6B;AAC3BzE,mBAAS,IAAT;AACD,SAFD,MAEO;AACL,cAAImD,cAAc,IAAlB;AADK;AAAA;AAAA;;AAAA;AAEL,mCAAyBsB,eAAzB,wIAA0C;AAAA,kBAAjCU,YAAiC;;AACxC,kBAAIA,gBAAgB,IAApB,EAA0B;AACxB;AACA,oBAAM9B,aAAa,KAAKrF,gBAAL,CAAsBmH,YAAtB,CAAnB;;AAEA,oBAAIhC,WAAJ,EAAiB;AACf;AACAnD,2BAASqD,UAAT;AACAF,gCAAc,KAAd;AACD,iBAJD,MAIO;AACL;;AAEA,sBAAI+B,uBAAuB,KAA3B,EAAkC;AAChC;AACAlF,6BAASA,UAAUqD,UAAnB;AACD,mBAHD,MAGO;AACL;AACArD,6BAASA,UAAUqD,UAAnB;AACD;AACF;AACF;AACF;AAvBI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBN;AACF;AACD,aAAOrD,MAAP;AACD;;;;;AAGD;;;;;qCAKiBoF,Q,EAAU;AACzB,UAAIpF,SAAS,KAAb;AACA,UAAIoF,YAAY,IAAhB,EAAsB;AACpB,YAAMC,eAAeD,SAASE,IAA9B;AACA,YAAID,gBAAgB,IAApB,EAA0B,CAEzB,CAFD,MAEO,IAAIA,iBAAiB,iBAArB,EAAwC;AAC7CrF,mBAAS,KAAKuF,+BAAL,CAAqCH,QAArC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,WAArB,EAAkC,CAExC,CAFM,MAEA,IAAIA,iBAAiB,aAArB,EAAoC,CAE1C,CAFM,MAEA,IAAIA,iBAAiB,WAArB,EAAkC;AACvCrF,mBAAS,KAAKwF,yBAAL,CAA+BJ,QAA/B,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,gBAArB,EAAuC;AAC5CrF,mBAAS,KAAKyF,8BAAL,CAAoCL,QAApC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,gBAArB,EAAuC;AAC5CrF,mBAAS,KAAK0F,8BAAL,CAAoCN,QAApC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,0BAArB,EAAiD;AACtDrF,mBAAS,KAAK2F,wCAAL,CAA8CP,QAA9C,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,aAArB,EAAoC;AACzCrF,mBAAS,KAAK4F,2BAAL,CAAiCR,QAAjC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,WAArB,EAAkC;AACvCrF,mBAAS,KAAK6F,yBAAL,CAA+BT,QAA/B,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,cAArB,EAAqC;AAC1CrF,mBAAS,KAAK8F,4BAAL,CAAkCV,QAAlC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,6BAArB,EAAoD;AACzDrF,mBAAS,KAAK+F,2CAAL,CAAiDX,QAAjD,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,OAArB,EAA8B;AACnCrF,mBAAS,KAAKgG,qBAAL,CAA2BZ,QAA3B,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,cAArB,EAAqC;AAC1CrF,mBAAS,KAAKiG,4BAAL,CAAkCb,QAAlC,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,qBAArB,EAA4C;AACjDrF,mBAAS,KAAKkG,oCAAL,CAA0Cd,QAA1C,CAAT;AACD,SAFM,MAEA,IAAIC,iBAAiB,EAArB,EAAyB,CAE/B;AACF;AACD,aAAOrF,MAAP;AACD;;;;;AAED;;;;;gDAK4BoF,Q,EAAU;AACpC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAMA,SAAS8F,SAAS9F,MAAxB;AACA,YAAMgC,SAAShC,OAAOgC,MAAtB;AACA,eAAO,KAAKqB,WAAL,CAAiBrB,MAAjB,CAAP;AACD;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;8CAK0B8D,Q,EAAU;AAClC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAMA,SAAS8F,SAAS9F,MAAxB;AACA,YAAMgC,SAAShC,OAAOgC,MAAtB;AACA,YAAMlB,cAAcd,OAAOc,WAA3B;;AAEA,YAAIkB,UAAU,IAAV,IAAkBlB,eAAe,IAArC,EAA2C;AACzC,cAAM3B,kBAAkB,KAAK0H,wCAAL,CAA8C7E,MAA9C,EAAsDlB,WAAtD,CAAxB;AACA,cAAI3B,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,qCAA2BA,eAA3B,wIAA4C;AAAA,oBAAnC2H,cAAmC;;AAC1C,oBAAIA,kBAAkB,IAAtB,EAA4B;AAC1B,sBAAM/J,cAAc+J,eAAe/J,WAAnC;AACA,sBAAIA,eAAe,IAAnB,EAAyB;AACvB,wBAAIA,YAAYgK,SAAhB,EAA2B;AACzB,6BAAO,IAAP;AACD;AACF;AACF;AACF;AAV0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAW5B;AACF;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;gEAK4CjB,Q,EAAU;AACpD,UAAIpF,SAAS,KAAb;AACA,UAAIoF,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAMA,SAAS8F,SAAS9F,MAAxB;;AAEA;AACA,YAAMgC,SAAShC,OAAOgC,MAAtB;;AAEA;AACA,YAAMgF,uBAAuBhH,OAAOgH,oBAApC;;AAEA;AACA,YAAMC,yBAAyBjH,OAAOiH,sBAAtC;;AAEA,YAAIC,gCAAgC,KAApC;AACA,YAAIC,kCAAkC,KAAtC;;AAEA,YAAIhF,gBAAgB,EAApB;;AAEA,YAAI6E,wBAAwB,IAA5B,EAAkC;AAChC;AACAE,0CAAgC,IAAhC;AACD,SAHD,MAGO;AACL;;;;;AAKA;AACA,cAAM9H,aAAa,KAAKgI,qBAAL,CAA2BpF,MAA3B,CAAnB;;AAEA,cAAI5C,cAAc,IAAlB,EAAwB;AACtB,iBAAK,IAAIiI,KAAKjI,WAAW8B,MAAX,GAAoB,CAAlC,EAAqCmG,MAAM,CAA3C,EAA8CA,IAA9C,EAAoD;AAClD,kBAAIC,oBAAoB,CAAxB;AACA,kBAAMC,YAAYnI,WAAWiI,EAAX,CAAlB;AACA,kBAAIE,aAAa,IAAjB,EAAuB;AACrB,oBAAMxK,cAAcwK,UAAUxK,WAA9B;AACA,oBAAIA,eAAe,IAAnB,EAAyB;AACvB,sBAAMkE,QAAQlE,YAAYkE,KAA1B;AACA,sBAAIA,SAAS,IAAb,EAAmB;AAAA;AAAA;AAAA;;AAAA;AACjB,6CAAiBA,KAAjB,wIAAwB;AAAA,4BAAfuB,IAAe;;AACtB,4BAAIA,QAAQ,IAAZ,EAAkB;AAChB,8BAAIA,KAAKgF,IAAL,KAAc,MAAd,IAAwBhF,KAAKiF,sBAAL,IAA+B,IAA3D,EAAiE;AAC/D;AACAH;AACD;AACF;AACF;AARgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUjB,wBAAIA,qBAAqBN,oBAAzB,EAA+C;AAC7C;AACAE,sDAAgC,IAAhC;AACA/E,sCAAgBlB,KAAhB;AACA;AACD;AACF;AACF;AACF;AACF;AACF;AACF;;AAED,YAAIgG,0BAA0B,IAA9B,EAAoC;AAClCE,4CAAkC,IAAlC;AACD,SAFD,MAEO;AACL;;;;AAIA,cAAI,KAAK9D,WAAL,CAAiBrB,MAAjB,CAAJ,EAA8B;AAC5BmF,8CAAkC,IAAlC;AACD;AACF;;AAED,YAAID,iCAAiCC,+BAArC,EAAsE;AACpEzG,mBAAS,IAAT;AACD;AACF;AACD,aAAOA,MAAP;AACD;;AAED;;;;;;;;oDAKgCoF,Q,EAAU;AACxC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C;AACA,YAAM0H,qBAAqB5B,SAAS9F,MAAT,CAAgB2H,UAA3C;AACA,YAAMC,mBAAmB9B,SAAS9F,MAAT,CAAgB6H,QAAzC;;AAEA;AACA,YAAMC,wBAAwB,KAAKC,gCAAL,CAAsCL,kBAAtC,CAA9B;;AAEA,YAAII,yBAAyB,IAA7B,EAAmC;AAAA;AAAA;AAAA;;AAAA;AACjC,mCAAiCA,qBAAjC,wIAAwD;AAAA,kBAA/CE,oBAA+C;;AACtD,kBAAIA,wBAAwB,IAA5B,EAAkC;AAChC,oBAAM7J,OAAO6J,qBAAqB7J,IAAlC;AACA,oBAAIA,QAAQ,IAAZ,EAAkB;AAChB;AACA,sBAAMwJ,aAAaxJ,KAAKwJ,UAAxB;AACA,sBAAME,WAAW1J,KAAK0J,QAAtB;AACA,sBAAIH,uBAAuBC,UAAvB,IAAqCC,qBAAqBC,QAA9D,EAAwE;AACtE;AACA,2BAAO,IAAP;AACD;AACF;AACF;AACF;AAdgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAelC;AACF;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;8CAK0B/B,Q,EAAU;AAClC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAMgC,SAAS8D,SAAS9F,MAAT,CAAgBgC,MAA/B;AACA,YAAM3C,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AACA,YAAIA,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,mCAAkBA,MAAlB,wIAA0B;AAAA,kBAAjB5B,KAAiB;;AACxB,kBAAIA,SAAS,IAAb,EAAmB;AACjB,oBAAIuE,UAAUvE,MAAMuE,MAAhB,IAA0B,kBAAkBvE,MAAMA,KAAtD,EAA6D;AAC3D,yBAAO,IAAP;AACD;AACF;AACF;AAPiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQnB;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;mDAK+BqI,Q,EAAU;AACvC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAIiI,uBAAuBnC,SAAS9F,MAAT,CAAgBiI,oBAA3C;AACA,YAAIC,2BAA2BpC,SAAS9F,MAAT,CAAgBkI,wBAA/C;;AAEA,YAAI7I,SAAS,KAAKtC,WAAL,CAAiBsC,MAA9B;AACA,YAAIA,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,mCAAkBA,MAAlB,wIAA0B;AAAA,kBAAjB5B,KAAiB;;AACxB,kBAAIA,SAAS,IAAb,EAAmB;AACjB,oBAAIwK,wBAAwBxK,MAAMuE,MAA9B,IACF,kBAAkBvE,MAAMA,KADtB,IAEFA,MAAMuH,cAAN,GAAuBkD,wBAFzB,EAEmD;AACjD,yBAAO,IAAP;AACD;AACF;AACF;AATiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUnB;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;mDAK+BpC,Q,EAAU;AACvC,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAImI,uBAAuBrC,SAAS9F,MAAT,CAAgBmI,oBAA3C;AACA,YAAIC,4BAA4BtC,SAAS9F,MAAT,CAAgBoI,yBAAhD;AACA,YAAIF,2BAA2BpC,SAAS9F,MAAT,CAAgBkI,wBAA/C;;AAEA;AACA;AACA,YAAIG,0CAA0C,KAAKC,6CAAL,CAAmDH,oBAAnD,EAAyEC,yBAAzE,CAA9C;AACA,YAAIC,wCAAwCrD,cAAxC,GAAyDkD,wBAA7D,EAAuF;AACrF,iBAAO,IAAP;AACD;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;6DAKyCpC,Q,EAAU;AACjD,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C;AACA,YAAIiI,uBAAuBnC,SAAS9F,MAAT,CAAgBiI,oBAA3C;AACA,YAAIE,uBAAuBrC,SAAS9F,MAAT,CAAgBmI,oBAA3C;AACA,YAAIC,4BAA4BtC,SAAS9F,MAAT,CAAgBoI,yBAAhD;AACA,YAAIF,2BAA2BpC,SAAS9F,MAAT,CAAgBkI,wBAA/C;;AAEA,YAAI7I,SAAS,KAAKtC,WAAL,CAAiBsC,MAA9B;AACA,YAAIA,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,mCAAkBA,MAAlB,wIAA0B;AAAA,kBAAjB5B,KAAiB;;AACxB,kBAAIA,SAAS,IAAb,EAAmB;AACjB,oBAAIwK,wBAAwBxK,MAAMuE,MAA9B,IAAwC,kBAAkBvE,MAAMA,KAAhE,IAAyEA,MAAMuH,cAAN,GAAuBkD,wBAApG,EAA8H;AAC5H;AACA;AACA,sBAAIG,0CAA0C,KAAKC,6CAAL,CAAmDH,oBAAnD,EAAyEC,yBAAzE,CAA9C;AACA,sBAAIC,wCAAwCrD,cAAxC,GAAyDvH,MAAMuH,cAAnE,EAAmF;AACjF,2BAAO,IAAP;AACD;AACF;AACF;AACF;AAZiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAanB;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;qDAKiC2C,U,EAAY;AAC3C,UAAMG,wBAAwB,EAA9B;AACA,UAAMzI,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AACA,UAAIA,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,iCAAkBA,MAAlB,wIAA0B;AAAA,gBAAjB5B,KAAiB;;AACxB,gBAAIA,SAAS,IAAb,EAAmB;AACjB,kBAAIkK,eAAelK,MAAMuE,MAArB,IAA+B,sBAAsBvE,MAAMA,KAA/D,EAAsE;AACpE;AACAqK,sCAAsB/G,IAAtB,CAA2BtD,KAA3B;AACD;AACF;AACF;AARiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASnB;AACD,aAAOqK,qBAAP;AACD;;AAED;;;;;;;;iDAK6BhC,Q,EAAU;AACrC,UAAMyC,cAAc,uBAApB,CADqC,CACS;AAC9C,UAAI,KAAKlM,SAAL,CAAemM,GAAf,CAAmBD,WAAnB,CAAJ,EAAqC;AACnC,YAAME,UAAU,KAAKpM,SAAL,CAAeqM,GAAf,CAAmBH,WAAnB,CAAhB;AACA,eAAOE,QAAQE,YAAR,CAAqB7C,QAArB,CAAP;AACD;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;0CAKsBA,Q,EAAU;AAC9B,UAAM9F,SAAS8F,SAAS9F,MAAxB;AACA,UAAIA,UAAU,IAAd,EAAoB;AAClB,YAAMgC,SAAShC,OAAOgC,MAAtB;AACA,YAAMlB,cAAcd,OAAOc,WAA3B;AACA,YAAM8H,SAAS5I,OAAO4I,MAAtB;AACA,YAAM3I,cAAc,KAAKxD,aAAL,CAAmByD,cAAnB,EAApB;AACA,YAAM2I,YAAY,KAAlB;AACA,YAAI7G,UAAU,IAAV,IAAkBlB,eAAe,IAAjC,IAAyC8H,UAAU,IAAvD,EAA6D;AAC3D,cAAME,wBAAwB,KAAKtM,iBAAL,CAAuBuM,wBAAvB,CAAgD/G,MAAhD,EAAwDlB,WAAxD,EAAqEb,WAArE,EAAkF4I,SAAlF,CAA9B;AACA,cAAIC,yBAAyB,IAA7B,EAAmC;AACjC,gBAAME,aAAa,KAAKxM,iBAAL,CAAuByM,gCAAvB,CAAwDH,qBAAxD,CAAnB;;AAEA;AACA,gBAAIF,OAAOnF,OAAP,CAAeuF,UAAf,KAA8B,CAAC,CAA/B,IAAqCA,cAAc,IAAd,IAAsBJ,OAAOnF,OAAP,CAAeuF,WAAWE,QAAX,EAAf,KAAyC,CAAC,CAAzG,EAA6G;AAC3G;;;;AAIA,qBAAO,IAAP;AACD;AACF;AACF;AACF;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;;;iDAO6BpD,Q,EAAU;AACrC,UAAM9F,SAAS8F,SAAS9F,MAAxB;AACA,UAAIA,UAAU,IAAd,EAAoB;AAClB,YAAMgC,SAAShC,OAAOgC,MAAtB;AACA,YAAMlB,cAAcd,OAAOc,WAA3B;AACA,YAAMqI,sBAAsBnJ,OAAOmJ,mBAAnC;;AAEA,YAAInH,UAAU,IAAV,IAAkBlB,eAAe,IAArC,EAA2C;AACzC,cAAM3B,kBAAkB,KAAK0H,wCAAL,CAA8C7E,MAA9C,EAAsDlB,WAAtD,CAAxB;AACA,cAAI3B,mBAAmB,IAAvB,EAA6B;AAC3B;AACA,gBAAIiK,sBAAsB,CAA1B;;AAEA;AACA,gBAAIC,uBAAuB,CAA3B;;AAEA;;;;;;AAP2B;AAAA;AAAA;;AAAA;AAa3B,qCAA2BlK,eAA3B,wIAA4C;AAAA,oBAAnC2H,cAAmC;;AAC1C,oBAAIA,kBAAkB,IAAtB,EAA4B;AAC1B,sBAAIA,eAAewC,QAAnB,EAA6B;AAC3BF;AACD;AACD,sBAAMrM,cAAc+J,eAAe/J,WAAnC;AACA,sBAAIA,eAAe,IAAnB,EAAyB;AACvB,wBAAIA,YAAYwM,aAAZ,IAA6B,IAAjC,EAAuC;AACrC,0BAAIxM,YAAYwM,aAAZ,GAA4BF,oBAAhC,EAAsD;AACpD;;;;AAIAA,+CAAuBtM,YAAYwM,aAAnC;AACD;AACF;AACF;AACF;AACF;AA/B0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiC3B,gBAAIH,uBAAuBD,mBAAvB,IAA8CE,wBAAwBF,mBAA1E,EAA+F;AAC7F;AACA,qBAAO,IAAP;AACD;AACF;AACF;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;;yDAMqCrD,Q,EAAU;AAC7C,UAAIA,YAAY,IAAZ,IAAoBA,SAAS9F,MAAT,IAAmB,IAA3C,EAAiD;AAC/C,YAAMA,SAAS8F,SAAS9F,MAAxB;AACA,YAAMgC,SAAShC,OAAOgC,MAAtB;AACA,YAAMlB,cAAcd,OAAOc,WAA3B;AACA,YAAM0I,wBAAwBxJ,OAAOwJ,qBAArC;;AAEA,YAAIxH,UAAU,IAAV,IAAkBlB,eAAe,IAArC,EAA2C;AACzC,cAAMgG,iBAAiB,KAAKwB,6CAAL,CAAmDtG,MAAnD,EAA2DlB,WAA3D,CAAvB;AACA,cAAIgG,kBAAkB,IAAtB,EAA4B;AAC1B,gBAAM/J,cAAc+J,eAAe/J,WAAnC;AACA,gBAAM0M,WAAW1M,YAAY0M,QAA7B;AACA,gBAAMC,gBAAgB,KAAK/M,WAAL,CAAiBgN,SAAjB,CAA2BF,QAA3B,CAAtB;AACA,gBAAIC,iBAAiBF,qBAArB,EAA4C;AAC1C,qBAAO,IAAP;AACD;AACF;AACF;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;sCAIkBnK,M,EAAQ;AACxB,WAAKrC,YAAL,GAAoB,EAApB;AACA,WAAKC,mBAAL,GAA2B,EAA3B;;AAEA,UAAIoC,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,iCAAkBA,MAAlB,wIAA0B;AAAA,gBAAjB5B,KAAiB;;AACxB,gBAAIA,SAAS,IAAT,IAAiBA,MAAMA,KAAN,KAAgB,aAArC,EAAoD;AAClD,mBAAKmM,kBAAL,CAAwBnM,MAAMuE,MAA9B;AACA,mBAAK6H,yBAAL,CAA+BpM,MAAMuE,MAArC;AACD;AACF;AANiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOnB;AACF;;;2CAEsB8H,K,EAAO;AAC5B,UAAIA,QAAQ,CAAZ,EAAe;AACbA,gBAAQ,KAAK9M,YAAL,CAAkBkE,MAAlB,GAA2B4I,KAAnC;AACD;AACD,UAAI,KAAK9M,YAAL,IAAqB,IAArB,IAA6B,KAAKA,YAAL,CAAkBkE,MAAlB,GAA2B,CAA5D,EAA+D;AAC7D,eAAO,KAAKlE,YAAL,CAAkB8M,KAAlB,CAAP;AACD;AACD,aAAO,IAAP;AACD;;;sCAEiB;AAChB,aAAO,KAAK9M,YAAZ;AACD;;;uCAEkBgF,M,EAAQ;AACzB,UAAM+H,gBAAgB,KAAK/M,YAAL,CAAkByG,OAAlB,CAA0BzB,MAA1B,CAAtB;AACA,UAAI+H,kBAAkB,CAAC,CAAvB,EAA0B;AACxB,aAAK/M,YAAL,CAAkB+D,IAAlB,CAAuBiB,MAAvB;AACD,OAFD,MAEO;AACL,aAAKhF,YAAL,CAAkBgN,MAAlB,CAAyBD,gBAAgB,CAAzC,EAA4C,KAAK/M,YAAL,CAAkBkE,MAA9D;AACD;AACF;;;8CAEyBc,M,EAAQ;AAChC,UAAM+H,gBAAgB,KAAK9M,mBAAL,CAAyBwG,OAAzB,CAAiCzB,MAAjC,CAAtB;AACA,UAAI+H,kBAAkB,CAAC,CAAvB,EAA0B;AACxB,aAAK9M,mBAAL,CAAyB8D,IAAzB,CAA8BiB,MAA9B;AACD;AACF;;;6CAEwB;AACvB,aAAO,KAAK/E,mBAAZ;AACD;;;kCAEa+E,M,EAAQ;AACpB,UAAM/E,sBAAsB,KAAKA,mBAAjC;AACA,UAAIA,uBAAuB,IAA3B,EAAiC;AAC/B,YAAM8M,gBAAgB9M,oBAAoBwG,OAApB,CAA4BzB,MAA5B,CAAtB;AACA,YAAI+H,kBAAkB,CAAC,CAAvB,EAA0B;AACxB,iBAAO,IAAP;AACD;AACF;AACD,aAAO,KAAP;AACD;;;2CAEsB;AACrB,UAAMjD,iBAAiB,EAAvB;AACAA,qBAAemD,SAAf,GAA2BrL,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAA3B;AACA,aAAOkI,cAAP;AACD;;;sCAEiBA,c,EAAgB;AAChC,UAAI,KAAK/J,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBoC,eAAjB,IAAoC,IAApE,EAA0E;AACxE,aAAKpC,WAAL,CAAiBoC,eAAjB,CAAiC4B,IAAjC,CAAsC+F,cAAtC;AACD;AACF;;;iCAEYS,S,EAAW;AACtB,UAAI,KAAKxK,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBqC,UAAjB,IAA+B,IAA/D,EAAqE;AACnE,aAAKrC,WAAL,CAAiBqC,UAAjB,CAA4B2B,IAA5B,CAAiCwG,SAAjC;AACD;AACF;;;;;AAED;;;;oCAIgB;AACd,UAAI,KAAKxK,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBqC,UAAjB,IAA+B,IAA/D,EAAqE;AACnE,eAAO,KAAKrC,WAAL,CAAiBqC,UAAxB;AACD;AACD,aAAO,EAAP;AACD;;;;;AAED;;;;;0CAKsB4C,M,EAAQ;AAC5B,UAAMkI,qBAAqB,EAA3B;AACA,UAAI,KAAKnN,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBqC,UAAjB,IAA+B,IAA/D,EAAqE;AACnE,YAAMA,aAAa,KAAKrC,WAAL,CAAiBqC,UAApC;AADmE;AAAA;AAAA;;AAAA;AAEnE,iCAAsBA,UAAtB,wIAAkC;AAAA,gBAAzBmI,SAAyB;;AAChC,gBAAIA,aAAa,IAAjB,EAAuB;AACrB,kBAAM4C,aAAa5C,UAAUvF,MAA7B;AACA,kBAAIA,WAAWmI,UAAf,EAA2B;AACzBD,mCAAmBnJ,IAAnB,CAAwBwG,SAAxB;AACD;AACF;AACF;AATkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUpE;AACD,aAAO2C,kBAAP;AACD;;;6BAEQzM,K,EAAO;AACd,UAAI,KAAKV,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBsC,MAAjB,IAA2B,IAA3D,EAAiE;AAC/D,aAAKtC,WAAL,CAAiBsC,MAAjB,CAAwB0B,IAAxB,CAA6BtD,KAA7B;AACD;AACF;;;kCAEauB,U,EAAY;AACxB,UAAI,KAAKjC,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBkB,WAAjB,IAAgC,IAAhE,EAAsE;AACpE,aAAKlB,WAAL,CAAiBkB,WAAjB,CAA6B8C,IAA7B,CAAkC/B,UAAlC;AACD;AACF;;;6CAEwBA,U,EAAY;AACnC,WAAKjC,WAAL,CAAiBkB,WAAjB,CAA6B8C,IAA7B,CAAkC/B,UAAlC;AACA,UAAIA,WAAWoL,cAAf,EAA+B;AAC7B,aAAK7N,UAAL,CAAgB2G,UAAhB,CAA2B,gCAA3B,EAA6D,EAAClE,YAAYA,UAAb,EAA7D;AACD,OAFD,MAEO;AACL,aAAKzC,UAAL,CAAgB2G,UAAhB,CAA2B,oBAA3B,EAAiD,EAAClE,YAAYA,UAAb,EAAjD;AACD;AACF;;;uCAEkBqL,S,EAAWC,Q,EAAU7M,K,EAAOU,I,EAAM;AACnD,UAAIkM,aAAa,IAAb,IAAqBC,YAAY,IAAjC,IAAyC7M,SAAS,IAAtD,EAA4D;AAC1D8M,cAAM,KAAK3N,UAAL,CAAgB,0EAAhB,CAAN;AACA;AACD;AACD,UAAM4N,UAAU,WAAhB;AACA,UAAMxI,SAASqI,UAAUrI,MAAzB;AACA,UAAMlB,cAAcuJ,UAAUvJ,WAA9B;AACA,UAAM2J,gBAAgBJ,UAAUI,aAAhC;AACA,UAAIzI,UAAU,IAAV,IAAkBlB,eAAe,IAAjC,IAAyC2J,iBAAiB,IAA9D,EAAoE;AAClEF,cAAM,KAAK3N,UAAL,CAAgB,qFAAhB,CAAN;AACA;AACD;AACD,WAAK8N,SAAL,CAAeF,OAAf,EAAwBxI,MAAxB,EAAgClB,WAAhC,EAA6C2J,aAA7C,EAA4DH,QAA5D,EAAsE7M,KAAtE,EAA6EU,IAA7E;AACD;;;iCAEY6D,M,EAAQlB,W,EAAa2J,a,EAAeH,Q,EAAU7M,K,EAAOU,I,EAAM;AACtE,UAAImM,YAAY,IAAZ,IAAoB7M,SAAS,IAAjC,EAAuC;AACrC8M,cAAM,KAAK3N,UAAL,CAAgB,0DAAhB,CAAN;AACA;AACD;AACD,UAAM4N,UAAU,KAAhB;AACA,WAAKE,SAAL,CAAeF,OAAf,EAAwBxI,MAAxB,EAAgClB,WAAhC,EAA6C2J,aAA7C,EAA4DH,QAA5D,EAAsE7M,KAAtE,EAA6EU,IAA7E;AACD;;;8BAESqM,O,EAASxI,M,EAAQlB,W,EAAa2J,a,EAAeH,Q,EAAU7M,K,EAAOU,I,EAAM;AAC5E,UAAMkB,SAAS,EAAf;AACA,UAAMsL,WAAW,KAAKC,cAAL,EAAjB;AACAD,eAASH,OAAT,GAAmBA,OAAnB;AACAG,eAAS3I,MAAT,GAAkBA,MAAlB;AACA2I,eAAS7J,WAAT,GAAuBA,WAAvB;AACA6J,eAASnD,IAAT,GAAgBiD,aAAhB;AACAE,eAASL,QAAT,GAAoBA,QAApB;AACAK,eAASlN,KAAT,GAAiBA,KAAjB;AACAkN,eAASxM,IAAT,GAAgBA,IAAhB;AACAkB,aAAO0B,IAAP,CAAY4J,QAAZ;AACA,UAAMxL,kBAAkB,IAAxB;AACA,UAAMC,aAAa,IAAnB;AACA,UAAMnB,cAAc,IAApB;AACA,WAAK4M,YAAL,CAAkB1L,eAAlB,EAAmCC,UAAnC,EAA+CC,MAA/C,EAAuDpB,WAAvD;AACD;;;;;AAED;;;;qCAIiB;AACf,UAAMR,QAAQ,EAAd;AACAA,YAAMqN,SAAN,GAAkB,KAAKrO,aAAL,CAAmBsO,YAAnB,EAAlB;AACAtN,YAAM0C,KAAN,GAAc,KAAK1D,aAAL,CAAmB2D,QAAnB,EAAd;AACA3C,YAAMuN,QAAN,GAAiB,KAAKvO,aAAL,CAAmBwO,WAAnB,EAAjB;AACAxN,YAAMwC,WAAN,GAAoB,KAAKxD,aAAL,CAAmByD,cAAnB,EAApB;AACAzC,YAAMuH,cAAN,GAAuBpG,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAAvB;AACA,aAAOnB,KAAP;AACD;;;mCAEc2B,U,EAAY;AACzB,UAAMD,kBAAkB,IAAxB;AACA,UAAME,SAAS,IAAf;AACA,UAAMpB,cAAc,IAApB;AACA,WAAK4M,YAAL,CAAkB1L,eAAlB,EAAmCC,UAAnC,EAA+CC,MAA/C,EAAuDpB,WAAvD;AACD;;;oCAGeA,W,EAAa;AAC3B,UAAMkB,kBAAkB,IAAxB;AACA,UAAMC,aAAa,IAAnB;AACA,UAAMC,SAAS,IAAf;AACA,WAAKwL,YAAL,CAAkB1L,eAAlB,EAAmCC,UAAnC,EAA+CC,MAA/C,EAAuDpB,WAAvD;AACD;;;iCAEYkB,e,EAAiBC,U,EAAYC,M,EAAQpB,W,EAAa;AAAA;;AAC7D;;;;AAIA,WAAKX,wBAAL,IAAiC,CAAjC;;AAEA;AACA,UAAMsD,kBAAkB,EAAxB;AACA,UAAIzB,mBAAmB,IAAnB,IAA2BA,gBAAgB+B,MAAhB,GAAyB,CAAxD,EAA2D;AAAA;AAAA;AAAA;;AAAA;AACzD,iCAA2B/B,eAA3B,wIAA4C;AAAA,gBAAnC2H,cAAmC;;AAC1C,gBAAIA,kBAAkB,IAAtB,EAA4B;AAC1BA,6BAAeoE,YAAf,GAA8B,KAAKvO,WAAL,CAAiBwO,WAAjB,EAA9B,CAD0B,CACoC;AAC9D,mBAAKC,iBAAL,CAAuBtE,cAAvB;AACAlG,8BAAgBG,IAAhB,CAAqB+F,cAArB;AACD;AACF;AAPwD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ1D;;AAED,UAAI1H,cAAc,IAAd,IAAsBA,WAAW8B,MAAX,GAAoB,CAA9C,EAAiD;AAAA;AAAA;AAAA;;AAAA;AAC/C,iCAAsB9B,UAAtB,wIAAkC;AAAA,gBAAzBmI,SAAyB;;AAChC,gBAAIA,aAAa,IAAjB,EAAuB;AACrBA,wBAAU2D,YAAV,GAAyB,KAAKvO,WAAL,CAAiBwO,WAAjB,EAAzB,CADqB,CACoC;AACzD,mBAAKE,YAAL,CAAkB9D,SAAlB;AACA3G,8BAAgBG,IAAhB,CAAqBwG,SAArB;AACD;AACF;AAP8C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQhD;;AAED,UAAIlI,UAAU,IAAV,IAAkBA,OAAO6B,MAAP,GAAgB,CAAtC,EAAyC;AAAA;AAAA;AAAA;;AAAA;AACvC,iCAAkB7B,MAAlB,wIAA0B;AAAA,gBAAjB5B,KAAiB;;AACxB,gBAAIA,SAAS,IAAb,EAAmB;AACjBA,oBAAMyN,YAAN,GAAqB,KAAKvO,WAAL,CAAiBwO,WAAjB,EAArB,CADiB,CACoC;AACrD,mBAAKG,QAAL,CAAc7N,KAAd;AACD;AACF;AANsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOxC,OAPD,MAOO;AACL4B,iBAAS,EAAT;AACD;;AAED,UAAIpB,eAAe,IAAf,IAAuBA,YAAYiD,MAAZ,GAAqB,CAAhD,EAAmD;AAAA;AAAA;AAAA;;AAAA;AACjD,iCAAuBjD,WAAvB,wIAAoC;AAAA,gBAA3Be,UAA2B;;AAClC,gBAAIA,cAAc,IAAlB,EAAwB;AACtBA,yBAAWkM,YAAX,GAA0B,KAAKvO,WAAL,CAAiBwO,WAAjB,EAA1B,CADsB,CACoC;AAC1D,kBAAInM,WAAWuC,EAAX,IAAiB,IAArB,EAA2B;AACzB;AACA,qBAAKgK,aAAL,CAAmBvM,UAAnB;AACD;AACF;AACF;AATgD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUlD,OAVD,MAUO;AACLf,sBAAc,EAAd;AACD;;AAED,UAAI,KAAKxB,aAAL,CAAmByC,SAAnB,EAAJ,EAAoC;AAClC,YAAMsM,2BAA2B;AAC/B5K,2BAAiBA,eADc;AAE/BvB,kBAAQA,MAFuB;AAG/BpB,uBAAaA;AAHkB,SAAjC;;AAMA;AACA,aAAKwN,mBAAL,CAAyBD,wBAAzB;AACA,YAAIE,WAAW,KAAKpP,EAAL,CAAQqP,KAAR,EAAf;AACAD,iBAASE,OAAT,CAAiBJ,wBAAjB;AACA,eAAOE,SAASG,OAAhB;AACD,OAZD,MAYO;AACL;AACA,YAAM7L,SAAS,EAAf;AACAA,eAAO8K,SAAP,GAAmB,KAAKrO,aAAL,CAAmBsO,YAAnB,EAAnB;AACA/K,eAAOG,KAAP,GAAe,KAAK1D,aAAL,CAAmB2D,QAAnB,EAAf;AACAJ,eAAOC,WAAP,GAAqB,KAAKxD,aAAL,CAAmByD,cAAnB,EAArB;AACAF,eAAOY,eAAP,GAAyBkL,QAAQC,MAAR,CAAenL,eAAf,CAAzB;AACAZ,eAAOX,MAAP,GAAgByM,QAAQC,MAAR,CAAe1M,MAAf,CAAhB;AACAW,eAAO/B,WAAP,GAAqB6N,QAAQC,MAAR,CAAe9N,WAAf,CAArB;;AAEA;AACA,YAAM4B,aAAa,EAAnB;AACAA,mBAAWC,MAAX,GAAoB,MAApB;AACAD,mBAAWE,GAAX,GAAiB,KAAKtD,aAAL,CAAmBmD,cAAnB,CAAkC,gBAAlC,CAAjB;AACAC,mBAAWkC,OAAX,GAAqB,EAAC,gBAAgB,mCAAjB,EAArB;AACAlC,mBAAW1B,IAAX,GAAkB6N,EAAEC,KAAF,CAAQjM,MAAR,CAAlB;;AAEA;AACA,eAAO,KAAK5D,KAAL,CAAWyD,UAAX,EAAuBY,IAAvB,CACL,kBAAU;AACR;AACA,cAAIC,UAAU,IAAV,IAAkBA,OAAOvC,IAAP,IAAe,IAArC,EAA2C;AACzC,gBAAMqN,4BAA2B9K,OAAOvC,IAAxC;;AAEA,mBAAKsN,mBAAL,CAAyBD,yBAAzB;;AAEA,mBAAOA,yBAAP;AACD;AACF,SAVI,EAUF,kBAAU;AACX;;AAEA;;;;AAIA,iBAAKlO,wBAAL,IAAiC,CAAjC;;AAEA,iBAAO,IAAP;AACD,SApBI,CAAP;AAsBD;AACF;;;wCAEmBkO,wB,EAA0B;AAC5C;AACA,UAAItG,iBAAiBtG,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAArB;;AAEA;AACA,UAAI4M,yBAAyB5K,eAA7B,EAA8C;AAC5C,YAAIsL,uBAAuBV,yBAAyB5K,eAApD;AACA,YAAIuL,uBAAuB,KAAKpP,WAAL,CAAiBoC,eAA5C;AACA,YAAI,KAAKpC,WAAL,CAAiBqC,UAArB,EAAiC;AAC/B+M,iCAAuBA,qBAAqB5J,MAArB,CAA4B,KAAKxF,WAAL,CAAiBqC,UAA7C,CAAvB;AACD;;AAED;AAP4C;AAAA;AAAA;;AAAA;AAQ5C,iCAA6B8M,oBAA7B,wIAAmD;AAAA,gBAA1CE,gBAA0C;;AACjD;;;;AAIA,iBAAK,IAAIC,IAAIF,qBAAqBjL,MAArB,GAA8B,CAA3C,EAA8CmL,KAAK,CAAnD,EAAsDA,GAAtD,EAA2D;AACzD,kBAAMC,mBAAmBH,qBAAqBE,CAArB,CAAzB;AACA,kBAAIC,iBAAiBpB,YAAjB,IACFoB,iBAAiBpB,YAAjB,KAAkCkB,iBAAiBlB,YADrD,EACmE;AACjEoB,iCAAiB/K,EAAjB,GAAsB6K,iBAAiB7K,EAAvC;AACA+K,iCAAiBpH,cAAjB,GAAkCkH,iBAAiBlH,cAAjB,GAAkCkH,iBAAiBlH,cAAnD,GAAoEA,cAAtG;AACAoH,iCAAiBpB,YAAjB,GAAgC,IAAhC,CAHiE,CAG3B;;AAEtC,oBAAI,KAAKzO,aAAL,CAAmB8P,OAAnB,MAAgC,SAAhC,IAA6CD,iBAAiB/K,EAAjB,IAAuB,IAAxE,EAA8E;AAC5E;;;;AAIA+K,mCAAiB/K,EAAjB,GAAsB,KAAKhE,kBAA3B;;AAEA;;;;AAIA,uBAAKA,kBAAL;AACD;;AAED,qBAAKhB,UAAL,CAAgB2G,UAAhB,CAA2B,0BAA3B,EAAuD,EAACrC,aAAayL,gBAAd,EAAvD;AACA;AACD;AACF;AACF;AAvC2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwC7C;AACD;AACA,UAAId,yBAAyBnM,MAA7B,EAAqC;AACnC,YAAMmN,cAAchB,yBAAyBnM,MAA7C;;AAEA,YAAMoN,cAAc,KAAK1P,WAAL,CAAiBsC,MAArC;;AAEA;AALmC;AAAA;AAAA;;AAAA;AAMnC,iCAAuBmN,WAAvB,wIAAoC;AAAA,gBAA3BE,UAA2B;;AAClC;;;;AAIA,iBAAK,IAAIL,KAAII,YAAYvL,MAAZ,GAAqB,CAAlC,EAAqCmL,MAAK,CAA1C,EAA6CA,IAA7C,EAAkD;AAChD,kBAAMM,aAAaF,YAAYJ,EAAZ,CAAnB;AACA,kBAAIM,WAAWzB,YAAX,IACFyB,WAAWzB,YAAX,KAA4BwB,WAAWxB,YADzC,EACuD;AACrDyB,2BAAWpL,EAAX,GAAgBmL,WAAWnL,EAA3B;AACAoL,2BAAWzH,cAAX,GAA4BwH,WAAWxH,cAAX,GAA4BwH,WAAWxH,cAAvC,GAAwDA,cAApF;AACAyH,2BAAWzB,YAAX,GAA0B,IAA1B,CAHqD,CAGrB;;AAEhC,qBAAK3O,UAAL,CAAgB2G,UAAhB,CAA2B,oBAA3B,EAAiD,EAACzF,OAAOkP,UAAR,EAAjD;AACA;AACD;AACF;AACF;AAvBkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBpC;;AAED;AACA,UAAInB,yBAAyBvN,WAA7B,EAA0C;AACxC,YAAM2O,mBAAmBpB,yBAAyBvN,WAAlD;AACA,YAAM4O,mBAAmB,KAAK9P,WAAL,CAAiBkB,WAA1C;;AAEA;AAJwC;AAAA;AAAA;;AAAA;AAKxC,iCAA4B2O,gBAA5B,wIAA8C;AAAA,gBAArCE,eAAqC;;AAC5C;;;;AAIA,iBAAK,IAAIT,MAAIQ,iBAAiB3L,MAAjB,GAA0B,CAAvC,EAA0CmL,OAAK,CAA/C,EAAkDA,KAAlD,EAAuD;AACrD,kBAAMU,kBAAkBF,iBAAiBR,GAAjB,CAAxB;AACA,kBAAIU,gBAAgB7B,YAAhB,IACF6B,gBAAgB7B,YAAhB,KAAiC4B,gBAAgB5B,YADnD,EACiE;AAC/D6B,gCAAgBxL,EAAhB,GAAqBuL,gBAAgBvL,EAArC;AACAwL,gCAAgB7H,cAAhB,GAAiC4H,gBAAgB5H,cAAhB,GAAiC4H,gBAAgB5H,cAAjD,GAAkEA,cAAnG;AACA6H,gCAAgB7B,YAAhB,GAA+B,IAA/B,CAH+D,CAG1B;;AAErC,qBAAK3O,UAAL,CAAgB2G,UAAhB,CAA2B,yBAA3B,EAAsD,EAAClE,YAAY+N,eAAb,EAAtD;AACA;AACD;AACF;AACF;AAtBuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBzC;;AAED;;;;AAIA,WAAKzP,wBAAL,IAAiC,CAAjC;;AAEA,UAAI,KAAKA,wBAAL,IAAiC,CAArC,EAAwC;AACtC;;;;;AAKA,aAAKoC,kBAAL;AACA,aAAKsN,iBAAL;AACD;AACF;;;;;AAED;;;;wCAIoB;AAClB,UAAI,CAAC,KAAKvQ,aAAL,CAAmByC,SAAnB,EAAL,EAAqC;AACnC,YAAM+N,mBAAmB,KAAKxQ,aAAL,CAAmByQ,mBAAnB,EAAzB;AACA,YAAID,oBAAoB,IAAxB,EAA8B;AAC5B,cAAM9M,QAAQ,KAAK1D,aAAL,CAAmB2D,QAAnB,EAAd;AACA,cAAM4K,WAAW,KAAKvO,aAAL,CAAmBwO,WAAnB,EAAjB;AACA,cAAMhL,cAAc,KAAKxD,aAAL,CAAmByD,cAAnB,EAApB;AACA,cAAMiN,gBAAgB,KAAKC,gBAAL,EAAtB;AACA,cAAMlQ,eAAe,KAAKmQ,eAAL,EAArB;AACA,cAAMC,oBAAoB,KAAKC,oBAAL,EAA1B;;AAEA;AACA,cAAMC,oBAAoB,EAA1B;AACAA,4BAAkBrN,KAAlB,GAA0BA,KAA1B;AACAqN,4BAAkBxC,QAAlB,GAA6BA,QAA7B;AACAwC,4BAAkBvN,WAAlB,GAAgCA,WAAhC;AACAuN,4BAAkBL,aAAlB,GAAkCA,aAAlC;AACAK,4BAAkBtQ,YAAlB,GAAiCA,YAAjC;AACAsQ,4BAAkBF,iBAAlB,GAAsCA,iBAAtC;;AAEA,cAAMG,SAAS3B,QAAQC,MAAR,CAAeyB,iBAAf,CAAf;AACA,cAAME,sBAAsB,EAA5B;AACAA,8BAAoBvN,KAApB,GAA4BA,KAA5B;AACAuN,8BAAoB1C,QAApB,GAA+BA,QAA/B;AACA0C,8BAAoBzN,WAApB,GAAkCA,WAAlC;AACAyN,8BAAoBD,MAApB,GAA6BA,MAA7B;;AAEA,cAAM5N,aAAa,EAAnB;AACAA,qBAAWC,MAAX,GAAoB,MAApB;AACAD,qBAAWE,GAAX,GAAiBkN,gBAAjB;AACApN,qBAAWkC,OAAX,GAAqB,EAAC,gBAAgB,mCAAjB,EAArB;AACAlC,qBAAW1B,IAAX,GAAkB6N,EAAEC,KAAF,CAAQyB,mBAAR,CAAlB;;AAEA,iBAAO,KAAKtR,KAAL,CAAWyD,UAAX,EAAuBY,IAAvB,CACL,kBAAU;AACR,mBAAO,IAAP;AACD,WAHI,EAGF,kBAAU;AACX,mBAAO,KAAP;AACD,WALI,CAAP;AAOD;AACF;AACF;;;4CAEuBN,K,EAAO6K,Q,EAAU/K,W,EAAa,CAErD;;;8CAEyB;AACxB,UAAMlD,cAAc,KAAKA,WAAzB;AACA,UAAIA,eAAe,IAAnB,EAAyB;AACvB,YAAMoC,kBAAkBpC,YAAYoC,eAApC;AACA,YAAIA,mBAAmB,IAAvB,EAA6B;AAC3B,iBAAOA,gBAAgBA,gBAAgB+B,MAAhB,GAAyB,CAAzC,CAAP;AACD;AACF;AACD,aAAO,IAAP;AACD;;;;;AAED;;;;6CAIyB;AACvB,UAAIyM,uBAAuB,KAAKC,uBAAL,EAA3B;AACA,UAAID,wBAAwB,CAACA,qBAAqBrE,QAAlD,EAA4D;AAC1D,eAAO,IAAP;AACD;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;+CAK2BtH,M,EAAQ;AACjC,UAAI6L,wBAAwB,KAAKzG,qBAAL,CAA2BpF,MAA3B,CAA5B;AACA,UAAI6L,yBAAyB,IAAzB,IAAiCA,sBAAsB3M,MAAtB,GAA+B,CAApE,EAAuE;AACrE,eAAO2M,sBAAsBA,sBAAsB3M,MAAtB,GAA+B,CAArD,CAAP;AACD;AACD,aAAO,IAAP;AACD;;;;;AAED;;;;;;;;kEAQ8Cc,M,EAAQlB,W,EAAa;AACjE,UAAIkB,MAAJ,EAAY;AACV,YAAMjF,cAAc,KAAKA,WAAzB;AACA,YAAIA,WAAJ,EAAiB;AACf;AACA,cAAMoC,kBAAkBpC,YAAYoC,eAApC;AACA,cAAIA,eAAJ,EAAqB;AACnB,iBAAK,IAAI2O,IAAI3O,gBAAgB+B,MAAhB,GAAyB,CAAtC,EAAyC4M,KAAK,CAA9C,EAAiDA,GAAjD,EAAsD;AACpD,kBAAMhH,iBAAiB3H,gBAAgB2O,CAAhB,CAAvB;AACA,kBAAIhH,cAAJ,EAAoB;AAClB,oBAAMiH,uBAAuBjH,eAAe9E,MAA5C;AACA,oBAAIA,WAAW+L,oBAAf,EAAqC;AACnC,sBAAIjN,WAAJ,EAAiB;AACf,wBAAMkN,4BAA4BlH,eAAehG,WAAjD;AACA,wBAAIA,gBAAgBkN,yBAApB,EAA+C;AAC7C,6BAAOlH,cAAP;AACD;AACF,mBALD,MAKO;AACL,2BAAOA,cAAP;AACD;AACF;AACF;AACF;AACF;AACF;AACF;AACD,aAAO,IAAP;AACD;;;;;AAED;;;;;kDAK8BmH,a,EAAe;AAC3C,UAAIA,iBAAiB,IAArB,EAA2B;AACzB,YAAM9O,kBAAkB,KAAKpC,WAAL,CAAiBoC,eAAzC;AACA,YAAIA,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,mCAA2BA,eAA3B,wIAA4C;AAAA,kBAAnC2H,cAAmC;;AAC1C,kBAAIA,kBAAkB,IAAlB,IAA0BA,eAAevF,EAAf,KAAsB0M,aAApD,EAAmE;AACjE,uBAAOnH,cAAP;AACD;AACF;AAL0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAM5B;;AAED,YAAM1H,aAAa,KAAKrC,WAAL,CAAiBqC,UAApC;AACA,YAAIA,cAAc,IAAlB,EAAwB;AAAA;AAAA;AAAA;;AAAA;AACtB,mCAAsBA,UAAtB,wIAAkC;AAAA,kBAAzBmI,SAAyB;;AAChC,kBAAIA,aAAa,IAAb,IAAqBA,UAAUhG,EAAV,KAAiB0M,aAA1C,EAAyD;AACvD,uBAAO1G,SAAP;AACD;AACF;AALqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMvB;AACF;AACD,aAAO,IAAP;AACD;;;;;AAED;;;yCAGqB;AACnB,aAAO,KAAKxK,WAAL,CAAiBoC,eAAxB;AACD;;;;;AAED;;;;;+CAK2B6C,M,EAAQ;AACjC,UAAMkM,0BAA0B,EAAhC;AACA,UAAIlM,UAAU,IAAd,EAAoB;AAClB,YAAMjF,cAAc,KAAKA,WAAzB;AACA,YAAIA,eAAe,IAAnB,EAAyB;AACvB,cAAMoC,kBAAkBpC,YAAYoC,eAApC;AACA,cAAIA,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,qCAA2BA,eAA3B,wIAA4C;AAAA,oBAAnC2H,cAAmC;;AAC1C,oBAAIA,kBAAkB,IAAtB,EAA4B;AAC1B,sBAAMiH,uBAAuBjH,eAAe9E,MAA5C;AACA,sBAAIA,UAAU+L,oBAAd,EAAoC;AAClCG,4CAAwBnN,IAAxB,CAA6B+F,cAA7B;AACD;AACF;AACF;AAR0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAS5B;AACF;AACF;AACD,aAAOoH,uBAAP;AACD;;;;;AAED;;;;;;;6DAOyClM,M,EAAQlB,W,EAAa;AAC5D,UAAMqN,wCAAwC,EAA9C;AACA,UAAInM,UAAU,IAAV,IAAkBlB,eAAe,IAArC,EAA2C;AACzC,YAAM/D,cAAc,KAAKA,WAAzB;AACA,YAAIA,eAAe,IAAnB,EAAyB;AACvB,cAAMoC,kBAAkBpC,YAAYoC,eAApC;AACA,cAAIA,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,qCAA2BA,eAA3B,wIAA4C;AAAA,oBAAnC2H,cAAmC;;AAC1C,oBAAIA,kBAAkB,IAAtB,EAA4B;AAC1B,sBAAMiH,uBAAuBjH,eAAe9E,MAA5C;AACA,sBAAMgM,4BAA4BlH,eAAehG,WAAjD;AACA,sBAAIkB,UAAU+L,oBAAV,IACAjN,eAAekN,yBADnB,EAC8C;AAC5CG,0DAAsCpN,IAAtC,CAA2C+F,cAA3C;AACD;AACF;AACF;AAV0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAW5B;AACF;AACF;;AAED,aAAOqH,qCAAP;AACD;;;;;AAED;;;;gCAIY;AACV,UAAI,KAAKpR,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBsC,MAAjB,IAA2B,IAA3D,EAAiE;AAC/D,eAAO,KAAKtC,WAAL,CAAiBsC,MAAxB;AACD,OAFD,MAEO;AACL,eAAO,EAAP;AACD;AACF;;;;;AAED;;;;;sCAKkB2C,M,EAAQ;AACxB,UAAMoM,iBAAiB,EAAvB;AACA,UAAIpM,UAAU,IAAd,EAAoB;AAClB,YAAI,KAAKjF,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBsC,MAAjB,IAA2B,IAA3D,EAAiE;AAC/D,cAAMA,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AAD+D;AAAA;AAAA;;AAAA;AAE/D,mCAAkBA,MAAlB,wIAA0B;AAAA,kBAAjB5B,KAAiB;;AACxB,kBAAIA,SAAS,IAAb,EAAmB;AACjB,oBAAM4Q,cAAc5Q,MAAMuE,MAA1B;AACA,oBAAIA,WAAWqM,WAAf,EAA4B;AAC1BD,iCAAerN,IAAf,CAAoBtD,KAApB;AACD;AACF;AACF;AAT8D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUhE;AACF;AACD,aAAO2Q,cAAP;AACD;;;;;AAED;;;;;;oDAMgCpM,M,EAAQlB,W,EAAa;AACnD,UAAMsN,iBAAiB,EAAvB;AACA,UAAIpM,UAAU,IAAd,EAAoB;AAClB,YAAI,KAAKjF,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBsC,MAAjB,IAA2B,IAA3D,EAAiE;AAC/D,cAAMA,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AAD+D;AAAA;AAAA;;AAAA;AAE/D,mCAAkBA,MAAlB,wIAA0B;AAAA,kBAAjB5B,KAAiB;;AACxB,kBAAIA,SAAS,IAAb,EAAmB;AACjB,oBAAM4Q,cAAc5Q,MAAMuE,MAA1B;AACA,oBAAMsM,mBAAmB7Q,MAAMqD,WAA/B;AACA,oBAAIkB,WAAWqM,WAAX,IAA0BvN,gBAAgBwN,gBAA9C,EAAgE;AAC9DF,iCAAerN,IAAf,CAAoBtD,KAApB;AACD;AACF;AACF;AAV8D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWhE;AACF;AACD,aAAO2Q,cAAP;AACD;;;;;AAED;;;;;;;;;sEASkD;AAChD,UAAM/O,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AACA,WAAK,IAAIkP,IAAIlP,OAAO6B,MAAP,GAAgB,CAA7B,EAAgCqN,KAAK,CAArC,EAAwCA,GAAxC,EAA6C;AAC3C,YAAM9Q,QAAQ4B,OAAOkP,CAAP,CAAd;AACA,YAAI9Q,SAAS,IAAb,EAAmB;AACjB,cAAM+Q,YAAY/Q,MAAMA,KAAxB;AACA,cAAI+Q,aAAa,aAAjB,EAAgC;AAC9B,gBAAMxM,SAASvE,MAAMuE,MAArB;AACA,gBAAMQ,OAAO,KAAK9F,cAAL,CAAoB+R,WAApB,CAAgCzM,MAAhC,CAAb;AACA,gBAAIQ,QAAQ,IAAZ,EAAkB;AAChB,kBAAI,KAAK9F,cAAL,CAAoBgS,QAApB,CAA6B1M,MAA7B,CAAJ,EAA0C;AACxC,uBAAOA,MAAP;AACD;AACF;AACF;AACF;AACF;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;iCAKaA,M,EAAQ;AACnB,UAAIA,UAAU,IAAd,EAAoB;AAClB;AACA,YAAMC,aAAa,KAAKqC,qBAAL,CAA2BtC,MAA3B,CAAnB;AACA,YAAIC,cAAc,IAAlB,EAAwB;AACtB,cAAIA,WAAWmB,WAAf,EAA4B;AAC1B,mBAAO,IAAP;AACD;AACF;AACF;AACD,aAAO,KAAP;AACD;;;;;AAED;;;;;0CAKsBpB,M,EAAQ;AAC5B,UAAIA,UAAU,IAAd,EAAoB;AAClB,eAAO,KAAK9E,YAAL,CAAkB8E,MAAlB,CAAP;AACD;AACD,aAAO,IAAP;AACD;;;;;AAED;;;;;;;wCAOoBA,M,EAAQ;AAC1B,UAAI2M,iBAAiB,CAArB;AACA,UAAIC,yBAAyB,CAA7B;AACA,UAAIC,aAAa,CAAjB;AACA,UAAIC,qBAAqB,CAAzB;AACA,UAAIrK,WAAW,EAAf;;AAEA,UAAI,KAAK/H,cAAL,CAAoB+F,WAApB,CAAgCT,MAAhC,CAAJ,EAA6C;AAC3C,YAAI+M,UAAU,KAAKrS,cAAL,CAAoBsS,mBAApB,CAAwChN,MAAxC,CAAd;AAD2C;AAAA;AAAA;;AAAA;AAE3C,iCAAe+M,OAAf,wIAAwB;AAAA,gBAAfxN,EAAe;;AACtB,gBAAIkM,SAAS,KAAKvQ,YAAL,CAAkBqE,EAAlB,CAAb;AACA,gBAAI,KAAK7E,cAAL,CAAoB+F,WAApB,CAAgClB,EAAhC,CAAJ,EAAyC;AACvC,kBAAIkM,OAAOhJ,QAAP,CAAgBqK,kBAAhB,GAAqC,CAAC,CAA1C,EAA6C;AAC3CH,kCAAkBlB,OAAOhJ,QAAP,CAAgBkK,cAAlC;AACAE,8BAAcpB,OAAOhJ,QAAP,CAAgBoK,UAA9B;AACAD,0CAA0BnB,OAAOhJ,QAAP,CAAgBmK,sBAA1C;AACAE,sCAAsBrB,OAAOhJ,QAAP,CAAgBqK,kBAAtC;AACD,eALD,MAKO;AACL;AACA,oBAAIG,gBAAgB,KAAKvK,mBAAL,CAAyBnD,EAAzB,CAApB;AACAoN,kCAAkBM,cAAcN,cAAhC;AACAE,8BAAcI,cAAcJ,UAA5B;AACAD,0CAA0BK,cAAcL,sBAAxC;AACAE,sCAAsBG,cAAcH,kBAApC;AACD;AACF,aAdD,MAcO;AACL,kBAAIrB,OAAO/J,SAAX,EAAsB;AACpBmL;;AAEA,oBAAIK,UAAU,KAAKxS,cAAL,CAAoByS,WAApB,CAAgC5N,EAAhC,CAAd;AACA,oBAAI2N,OAAJ,EAAa;AACXJ;AACD;;AAED,oBAAIrB,OAAOpK,WAAX,EAAwB;AACtBsL;;AAEA,sBAAIO,OAAJ,EAAa;AACXN;AACD;AACF;AACF;AACF;AACF;AApC0C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsC3C,YAAIQ,gBAAgBP,aAAaQ,KAAKC,KAAL,CAAWX,iBAAiBE,UAAjB,GAA8B,GAAzC,CAAb,GAA6D,CAAjF;AACA,YAAIU,wBAAwBT,qBAAqBO,KAAKC,KAAL,CAAWV,yBAAyBE,kBAAzB,GAA8C,GAAzD,CAArB,GAAqF,CAAjH;;AAEArK,mBAAW;AACT,4BAAkBkK,cADT;AAET,oCAA0BC,sBAFjB;AAGT,wBAAcC,UAHL;AAIT,gCAAsBC,kBAJb;AAKT,2BAAiBM,aALR;AAMT,mCAAyBG;AANhB,SAAX;AAQD;;AAED;;AAEA,aAAO9K,QAAP;AACD;;;;;AAED;;;;;;gCAMYzC,M,EAAQlB,W,EAAa;AAC/B,UAAIJ,SAAS,KAAb;AACA,UAAIsB,UAAUlB,WAAd,EAA2B;AACzB;;AAEA;AACA,YAAM3B,kBAAkB,KAAK0H,wCAAL,CAA8C7E,MAA9C,EAAsDlB,WAAtD,CAAxB;;AAEA;AACA,YAAM0O,kBAAkB,KAAKC,+BAAL,CAAqCzN,MAArC,EAA6ClB,WAA7C,CAAxB;;AAEA;AACA,YAAM4O,aAAa,KAAKC,iBAAL,CAAuB3N,MAAvB,CAAnB;;AAEA;AACA,YAAMqI,YAAY,KAAK3N,cAAL,CAAoBkT,kCAApB,CAAuD5N,MAAvD,EAA+DlB,WAA/D,CAAlB;;AAEA,YAAM0B,OAAO,KAAK9F,cAAL,CAAoB+R,WAApB,CAAgCzM,MAAhC,CAAb;AACA,YAAIqI,aAAa,IAAjB,EAAuB;AACrB;AACA,cAAMI,gBAAgBJ,UAAU7C,IAAhC;;AAEA,cAAIiD,iBAAiB,IAArB,EAA2B;AACzB;AACA,gBAAMhC,UAAU,KAAKpM,SAAL,CAAeqM,GAAf,CAAmB+B,gBAAgB,SAAnC,CAAhB;;AAEA;AACA,gBAAIhC,QAAQpF,WAAR,CAAoBgH,SAApB,EAA+BlL,eAA/B,EAAgDqQ,eAAhD,EAAiEE,UAAjE,EAA6ElN,IAA7E,CAAJ,EAAwF;AACtF9B,uBAAS,IAAT;AACD;AACF;AACF;AACF,OA9BD,MA8BO,IAAIsB,MAAJ,EAAY;AACjB;AACA,YAAM6N,UAAU,KAAKnT,cAAL,CAAoB+F,WAApB,CAAgCT,MAAhC,CAAhB;;AAEA,YAAMQ,QAAO,KAAK9F,cAAL,CAAoB+R,WAApB,CAAgCzM,MAAhC,CAAb;;AAEA,YAAI6N,OAAJ,EAAa;AACX;AACA,cAAI9L,aAAa,IAAjB;;AAEA;AACA,cAAMgL,UAAU,KAAKrS,cAAL,CAAoBsS,mBAApB,CAAwChN,MAAxC,CAAhB;;AAEA,cAAI+M,QAAQ7N,MAAZ,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,qCAAe6N,OAAf,wIAAwB;AAAA,oBAAfxN,EAAe;;AACtB,oBAAI,KAAKrE,YAAL,CAAkBqE,EAAlB,KAAyB,IAAzB,IAAiC,CAAC,KAAKrE,YAAL,CAAkBqE,EAAlB,EAAsBmC,SAAxD,IAAqE,CAAC,KAAKxG,YAAL,CAAkBqE,EAAlB,EAAsB8B,WAAhG,EAA6G;AAC3G;AACAU,+BAAa,KAAb;AACA;AACD;AACF;AAPiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQnB,WARD,MAQO;AACL;AACAA,yBAAa,KAAb;AACD;AACDrD,mBAASqD,UAAT;AACD,SApBD,MAoBO;AACL;;AAEA;AACA,cAAM+L,aAAa,KAAKpT,cAAL,CAAoBqT,qBAApB,CAA0C/N,MAA1C,CAAnB;;AAEA;AACA,cAAI+B,cAAa,IAAjB;;AAEA;;;;;AATK;AAAA;AAAA;;AAAA;AAcL,mCAAsB+L,UAAtB,wIAAkC;AAAA,kBAAzBzF,UAAyB;;AAChC,kBAAIA,cAAa,IAAjB,EAAuB;AACrB,oBAAMvJ,eAAcuJ,WAAU9I,EAA9B;AACA,oBAAMkJ,iBAAgBJ,WAAU7C,IAAhC;AACA,oBAAMwI,yBAAyB3F,WAAU2F,sBAAzC;AACA,oBAAMC,8BAA8B5F,WAAU4F,2BAA9C;;AAEA,oBAAI9F,aAAanI,MAAjB;AACA,oBAAIkO,WAAW1N,KAAf;AACA,oBAAI2N,kBAAkBrP,YAAtB;AACA,oBAAIsP,gBAAgB/F,UAApB;;AAEA,oBAAI2F,0BAA0B,IAA1B,IAAkCC,+BAA+B,IAArE,EAA2E;AACzE;;;;AAIA9F,+BAAa6F,sBAAb;AACAG,oCAAkBF,2BAAlB;AACAC,6BAAW,KAAKxT,cAAL,CAAoB+R,WAApB,CAAgCtE,UAAhC,CAAX;AACAiG,kCAAgB,KAAK1T,cAAL,CAAoBkT,kCAApB,CAAuDzF,UAAvD,EAAmEgG,eAAnE,CAAhB;AACD;;AAED,oBAAI1F,kBAAiB,IAArB,EAA2B;AACzB,sBAAI;AACF;AACA,wBAAMlC,cAAckC,iBAAgB,SAApC;;AAEA,wBAAI,KAAKpO,SAAL,CAAemM,GAAf,CAAmBD,WAAnB,CAAJ,EAAqC;AACnC;AACA,0BAAME,WAAU,KAAKpM,SAAL,CAAeqM,GAAf,CAAmBH,WAAnB,CAAhB;;AAEA;AACA,0BAAMpJ,mBAAkB,KAAK0H,wCAAL,CAA8CsD,UAA9C,EAA0DgG,eAA1D,CAAxB;;AAEA;AACA,0BAAMX,mBAAkB,KAAKC,+BAAL,CAAqCtF,UAArC,EAAiDgG,eAAjD,CAAxB;;AAEA;AACA,0BAAMT,cAAa,KAAKC,iBAAL,CAAuBxF,UAAvB,CAAnB;;AAEA;AACA,0BAAMkG,uBAAuB5H,SAAQpF,WAAR,CAAoB+M,aAApB,EAAmCjR,gBAAnC,EAAoDqQ,gBAApD,EAAqEE,WAArE,EAAiFQ,QAAjF,CAA7B;;AAEAnM,oCAAaA,eAAcsM,oBAA3B;AACD;AACF,mBAtBD,CAsBE,OAAO9B,CAAP,EAAU;AACV+B,4BAAQC,GAAR,CAAY,KAAK3T,UAAL,CAAgB,wCAAhB,IAA4DuT,eAAxE;AACD;AACF;AACF;AACF;AAjEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkELzP,mBAASqD,WAAT;AACD;AACF;AACD,aAAOrD,MAAP;AACD;;;;;AAED;;;;qCAIiB;AACf,aAAO,KAAK7D,WAAZ;AACD;;;;;AAED;;;;uCAImB;AACjB,UAAI,KAAKA,WAAL,IAAoB,IAAxB,EAA8B;AAC5B,eAAO,KAAKA,WAAL,CAAiB0E,EAAxB;AACD;AACD,aAAO,IAAP;AACD;;;;;AAED;;;;2CAIuBS,M,EAAQ;AAC7B,UAAIA,UAAU,IAAd,EAAoB;AAClB,YAAMQ,OAAO,KAAK9F,cAAL,CAAoB+R,WAApB,CAAgCzM,MAAhC,CAAb;AACA,aAAKwO,cAAL,CAAoBhO,IAApB;AACD;AACF;;;;;AAED;;;;mCAIeA,I,EAAM;AACnB,UAAMiO,sBAAsB,KAAK5T,WAAjC;AACA,UAAI4T,wBAAwBjO,IAA5B,EAAkC;AAChC,YAAIiO,uBACA,CAAC,KAAK/T,cAAL,CAAoB+F,WAApB,CAAgCgO,oBAAoBlP,EAApD,CADL,EAC8D;AAC5D,eAAKzE,YAAL,GAAoB2T,mBAApB;AACD;AACD,aAAK5T,WAAL,GAAmB2F,IAAnB;AACA,aAAKjG,UAAL,CAAgB2G,UAAhB,CAA2B,oBAA3B,EACI,EAACwN,cAAcD,mBAAf,EAAoC5T,aAAa,KAAKA,WAAtD,EADJ;AAED;AACF;;;;;AAED;;;qCAGiB;AACf,UAAM4T,sBAAsB,KAAK5T,WAAjC;AACA,UAAI4T,uBAAuB,IAA3B,EAAiC;AAC/B,aAAKlU,UAAL,CAAgB2G,UAAhB,CAA2B,UAA3B,EAAuC,EAACyN,YAAYF,mBAAb,EAAvC;AACD;AACF;;;;;AAED;;;;4DAIwCzO,M,EAAQ;AAC9C,UAAI,KAAK9E,YAAL,CAAkB8E,MAAlB,EAA0BoB,WAA9B,EAA2C;AACzC,aAAKwN,cAAL;AACA,aAAKC,sBAAL,CAA4B7O,MAA5B;AACD,OAHD,MAGO;AACL,aAAK8O,eAAL,CAAqB9O,MAArB;AACD;AACF;;;;;AAED;;;;oCAIgBA,M,EAAQ;AACtB,WAAKzF,UAAL,CAAgB2G,UAAhB,CAA2B,iBAA3B,EAA8C,EAAClB,QAAQA,MAAT,EAA9C;AACD;;;;;AAED;;;;;;+BAMY+O,O,EAASC,Y,EAAe;AAClC;AACA;AACAA,qBAAgBA,gBAAgB,GAAhC;;AAEA;AACA,UAAMC,aAAa,IAAIC,MAAJ;AAEf;AACA,cAAQF,YAAR,GAAuB,iBAAvB;;AAEA;AACA,uCAHA;;AAKA;AACA,eANA,GAMYA,YANZ,GAM2B,YATZ,EAWjB,IAXiB,CAAnB;;AAcA;AACA;AACA,UAAMG,UAAU,CAAC,EAAD,CAAhB;;AAEA;AACA;AACA,UAAIC,aAAa,IAAjB;;AAGA;AACA;AACA,aAAOA,aAAaH,WAAWI,IAAX,CAAiBN,OAAjB,CAApB,EAAgD;;AAE9C;AACA,YAAMO,sBAAsBF,WAAY,CAAZ,CAA5B;;AAEA;AACA;AACA;AACA;AACA,YACEE,oBAAoBpQ,MAApB,IACCoQ,uBAAuBN,YAF1B,EAGC;;AAEC;AACA;AACAG,kBAAQpQ,IAAR,CAAc,EAAd;AACD;;AAED;AACA;AACA;AACA,YAAIqQ,WAAY,CAAZ,CAAJ,EAAoB;;AAElB;AACA;AACA,cAAMG,mBAAkBH,WAAY,CAAZ,EAAgBI,OAAhB,CACtB,IAAIN,MAAJ,CAAY,MAAZ,EAAoB,GAApB,CADsB,EAEtB,IAFsB,CAAxB;AAKD,SATD,MASO;AACL;AACA,cAAMK,oBAAkBH,WAAY,CAAZ,CAAxB;AACD;;AAED;AACA;AACA,YAAIK,aAAaF,eAAjB;AACA,YAAMG,WAAWC,WAAWJ,eAAX,CAAjB;AACA,YAAI,CAACK,MAAMF,QAAN,CAAL,EAAsB;AACpBD,uBAAaC,QAAb;AACD;AACDP,gBAASA,QAAQjQ,MAAR,GAAiB,CAA1B,EAA8BH,IAA9B,CAAoC0Q,UAApC;AACD;AACD;AACA,aAAQN,OAAR;AACD;;;;;AAED;;;;oCAIgB;AACd,UAAMlT,cAAc,KAAKlB,WAAL,CAAiBkB,WAArC;AACA,UAAMgC,cAAc,KAAKxD,aAAL,CAAmByD,cAAnB,EAApB;AACA,aAAO,KAAK1D,iBAAL,CAAuBqV,aAAvB,CAAqC5T,WAArC,EAAkDgC,WAAlD,CAAP;AACD;;AAED;;;;;;;2CAIuB;AACrB;AACA,UAAM+B,SAAS,QAAf;;AAEA;AACA,UAAMyC,WAAW,KAAKC,mBAAL,CAAyB1C,MAAzB,CAAjB;;AAEA,aAAOyC,QAAP;AACD;;AAED;;;;;;mCAGe;AACb,aAAO,KAAKtH,SAAZ;AACD;;AAED;;;;;;;qDAIiC;AAC/B;AACA,UAAI2U,+BAA+B,CAAnC;;AAEA,UAAI1S,aAAa,KAAK2S,aAAL,EAAjB;AACA,UAAI3S,cAAc,IAAlB,EAAwB;AAAA;AAAA;AAAA;;AAAA;AACtB,iCAAsBA,UAAtB,wIAAkC;AAAA,gBAAzBmI,SAAyB;;AAChC,gBAAIA,aAAa,IAAjB,EAAuB;AACrB,kBAAIyK,kBAAkBzK,UAAUvF,MAAhC;AACA,kBAAI,KAAKtF,cAAL,CAAoBuV,UAApB,CAA+BD,eAA/B,KAAmDzK,UAAUxK,WAAV,IAAyB,IAAhF,EAAsF;AACpF,oBAAIkE,QAAQsG,UAAUxK,WAAV,CAAsBkE,KAAlC;AADoF;AAAA;AAAA;;AAAA;AAEpF,yCAAiBA,KAAjB,wIAAwB;AAAA,wBAAfuB,IAAe;;AACtB,wBAAIR,SAASQ,KAAKjB,EAAlB;AACA;AACA,wBAAI2Q,sBAAsB,kBAA1B;;AAEA;AACA,wBAAIxR,SAASsB,OAAOmQ,KAAP,CAAaD,mBAAb,CAAb;;AAEA,wBAAIxR,UAAU,IAAd,EAAoB;AAClB;;AAEA;;;;;AAKA,0BAAI0R,qBAAqBC,SAAS3R,OAAO,CAAP,CAAT,CAAzB;;AAEA,0BAAI0R,qBAAqBN,4BAAzB,EAAuD;AACrD;;;;AAIAA,uDAA+BM,kBAA/B;AACD;AACF;AACF;AA5BmF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BrF;AACF;AACF;AAnCqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoCvB;;AAED,UAAI,KAAK/U,qBAAL,GAA6ByU,4BAAjC,EAA+D;AAC7D;AACA,aAAKzU,qBAAL,GAA6ByU,4BAA7B;AACD;;AAED;AACA,WAAKzU,qBAAL;;AAEA;AACA,aAAO,iBAAiB,KAAKA,qBAA7B;AACD;;AAED;;;;;;;qCAIiB;AACf,UAAI,KAAKN,WAAL,IAAoB,IAApB,IAA4B,KAAKA,WAAL,CAAiBkB,WAAjB,IAAgC,IAAhE,EAAsE;AACpE,eAAO,KAAKlB,WAAL,CAAiBkB,WAAxB;AACD;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;qDAKiC+D,M,EAAQ;AACvC,UAAMsQ,wBAAwB,EAA9B;AACA,UAAItQ,MAAJ,EAAY;AACV,YAAMjF,cAAc,KAAKA,WAAzB;AACA,YAAIA,WAAJ,EAAiB;AACf,cAAMyF,OAAO,KAAK9F,cAAL,CAAoB+R,WAApB,CAAgCzM,MAAhC,CAAb;AACA,cAAIQ,QAAQ,IAAZ,EAAkB;AAChB,gBAAMsN,aAAatN,KAAKsN,UAAxB;AACA,gBAAIA,cAAc,IAAlB,EAAwB;AAAA;AAAA;AAAA;;AAAA;AACtB,uCAAsBA,UAAtB,wIAAkC;AAAA,sBAAzBzF,SAAyB;;AAChC,sBAAIA,aAAa,IAAjB,EAAuB;AACrB,wBAAMvJ,cAAcuJ,UAAU9I,EAA9B;AACA,wBAAIuF,iBACA,KAAKwB,6CAAL,CAAmDtG,MAAnD,EAA2DlB,WAA3D,CADJ;AAEA,wBAAIgG,kBAAkB,IAAtB,EAA4B;AAC1B;;;;;AAKAA,uCAAiB,EAAjB;AACAA,qCAAe9E,MAAf,GAAwBA,MAAxB;AACA8E,qCAAehG,WAAf,GAA6BA,WAA7B;AACD;AACDwR,0CAAsBvR,IAAtB,CAA2B+F,cAA3B;AACD;AACF;AAlBqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBvB;AACF;AACF;AACF;AACD,aAAOwL,qBAAP;AACD;;AAED;;;;;;;;oDAKgCtQ,M,EAAQ;AACtC,UAAIA,UAAU,IAAd,EAAoB;AAClB,YAAMjF,cAAc,KAAKA,WAAzB;AACA,YAAIA,WAAJ,EAAiB;AACf,cAAMoC,kBAAkB,KAAKoT,0BAAL,CAAgCvQ,MAAhC,CAAxB;AACA,iBAAO7C,gBAAgBA,gBAAgB+B,MAAhB,GAAyB,CAAzC,CAAP;AACD;AACF;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;kDAK8BsR,kB,EAAoB;AAChD,UAAI9R,SAAS,IAAb;AACA,UAAI8R,sBAAsB,IAA1B,EAAgC;AAC9B,YAAIA,mBAAmBC,OAAvB,EAAgC;AAC9B;;AAEA,cAAIC,gBAAgB,CAApB;AACA,cAAM5M,WAAW0M,mBAAmB1M,QAApC;AAJ8B;AAAA;AAAA;;AAAA;AAK9B,mCAAgCA,QAAhC,wIAA0C;AAAA,kBAAjC6M,mBAAiC;;AACxC,kBAAI5O,aAAa,IAAjB;AACA,kBAAI4O,uBAAuB,IAA3B,EAAiC;AAC/B;AACA,oBAAM5M,eAAe4M,oBAAoB3M,IAAzC;;AAEA,oBAAID,gBAAgB,aAApB,EAAmC;AACjC,sBAAM/D,SAAS2Q,oBAAoB3Q,MAAnC;AACA,sBAAMlB,cAAc6R,oBAAoB7R,WAAxC;;AAEA;AACA,sBAAM8R,qBAAqB,KAAKC,+BAAL,CAAqC7Q,MAArC,EAA6ClB,WAA7C,EAA0D4R,aAA1D,CAA3B;;AAEA,sBAAIE,sBAAsB,IAA1B,EAAgC;AAC9B;AACAlS,6BAAS,KAAT;AACA;AACD,mBAJD,MAIO;AACL;AACAgS,oCAAgBE,mBAAmB1N,cAAnC;AACD;AACF,iBAfD,MAeO,IAAIa,gBAAgB,SAApB,EAA+B;AACpC,sBAAM/D,UAAS2Q,oBAAoB3Q,MAAnC;AACA,sBAAMlB,gBAAc6R,oBAAoB7R,WAAxC;;AAEA;AACA,sBAAM8R,sBAAqB,KAAKE,2BAAL,CAAiC9Q,OAAjC,EAAyClB,aAAzC,EAAsD4R,aAAtD,CAA3B;;AAEA,sBAAIE,uBAAsB,IAA1B,EAAgC;AAC9B;AACAlS,6BAAS,KAAT;AACA;AACD,mBAJD,MAIO;AACL;AACAgS,oCAAgBE,oBAAmB1N,cAAnC;AACD;AACF,iBAfM,MAeA,IAAIa,gBAAgB,WAApB,EAAiC;AACtC,sBAAM/D,WAAS2Q,oBAAoB3Q,MAAnC;;AAEA;AACA,sBAAM+Q,YAAY,KAAKC,kBAAL,CAAwBhR,QAAxB,EAAgC0Q,aAAhC,CAAlB;;AAEA,sBAAIK,aAAa,IAAjB,EAAuB;AACrB;AACArS,6BAAS,KAAT;AACA;AACD,mBAJD,MAIO;AACL;AACAgS,oCAAgBK,UAAU7N,cAA1B;AACD;AACF;AACF;AACF;AAzD6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0D/B;AACF;AACD,aAAOxE,MAAP;AACD;;AAED;;;;;;;;;gDAM4BsB,M,EAAQlB,W,EAAamJ,S,EAAW;AAC1D,UAAM9K,kBAAkB,KAAKpC,WAAL,CAAiBoC,eAAzC;AACA,UAAIA,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,iCAA+BA,eAA/B,wIAAgD;AAAA,gBAAvCyT,kBAAuC;;AAC9C,gBAAIA,sBAAsB,IAAtB,IACAA,mBAAmB1N,cAAnB,GAAoC+E,SADpC,IAEA2I,mBAAmB5Q,MAAnB,KAA8BA,MAF9B,IAGA4Q,mBAAmB9R,WAAnB,KAAmCA,WAHvC,EAGoD;AAClD,qBAAO8R,kBAAP;AACD;AACF;AAR0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAS5B;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;;oDAMgC5Q,M,EAAQlB,W,EAAamJ,S,EAAW;AAC9D,UAAM9K,kBAAkB,KAAKpC,WAAL,CAAiBoC,eAAzC;AACA,UAAIA,mBAAmB,IAAvB,EAA6B;AAAA;AAAA;AAAA;;AAAA;AAC3B,iCAA+BA,eAA/B,wIAAgD;AAAA,gBAAvCyT,kBAAuC;;AAC9C,gBAAIA,sBAAsB,IAAtB,IACAA,mBAAmB1N,cAAnB,GAAoC+E,SADpC,IAEA2I,mBAAmB5Q,MAAnB,KAA8BA,MAF9B,IAGA4Q,mBAAmB9R,WAAnB,KAAmCA,WAHnC,IAIA8R,mBAAmBtJ,QAJvB,EAIiC;AAC/B,qBAAOsJ,kBAAP;AACD;AACF;AAT0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU5B;AACD,aAAO,IAAP;AACD;;AAED;;;;;;uCAGmB5Q,M,EAAQiI,S,EAAW;AACpC,UAAM5K,SAAS,KAAKtC,WAAL,CAAiBsC,MAAhC;AACA,UAAIA,UAAU,IAAd,EAAoB;AAAA;AAAA;AAAA;;AAAA;AAClB,iCAAsBA,MAAtB,wIAA8B;AAAA,gBAArB0T,SAAqB;;AAC5B,gBAAIA,aAAa,IAAb,IACAA,UAAU7N,cAAV,GAA2B+E,SAD3B,IAEA8I,UAAU/Q,MAAV,KAAqBA,MAFrB,IAGA+Q,UAAUtV,KAAV,KAAoB,aAHxB,EAGuC;AACrC,qBAAOsV,SAAP;AACD;AACF;AARiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASnB;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;;;;;;4CAUwB/Q,M,EAAQlB,W,EAAamS,uB,EAAyB;AACpE,UAAMtT,iBAAiB,KAAKlD,aAAL,CAAmBmD,cAAnB,CAAkC,gBAAlC,CAAvB;AACA,UAAMC,aAAa,EAAnB;AACAA,iBAAWC,MAAX,GAAoB,KAApB;AACAD,iBAAWE,GAAX,GAAiBJ,cAAjB;;AAEA,UAAMK,SAAS,EAAf;AACAA,aAAOG,KAAP,GAAe,KAAK1D,aAAL,CAAmB2D,QAAnB,EAAf;AACAJ,aAAOgC,MAAP,GAAgBA,MAAhB;AACAhC,aAAOc,WAAP,GAAqBA,WAArB;AACAd,aAAOK,cAAP,GAAwB,IAAxB;AACAL,aAAOM,SAAP,GAAmB,KAAnB;AACAN,aAAOO,cAAP,GAAwB,KAAxB;AACAP,aAAOkT,aAAP,GAAuB,IAAvB;;AAEA,UAAID,2BAA2B,QAA/B,EAAyC;AACvCjT,eAAOgL,QAAP,GAAkB,KAAKvO,aAAL,CAAmBwO,WAAnB,EAAlB;AACD;;AAEDpL,iBAAWG,MAAX,GAAoBA,MAApB;;AAEA,aAAO,KAAK5D,KAAL,CAAWyD,UAAX,EAAuBY,IAAvB,CAA4B,UAACC,MAAD,EAAY;AAC7C,YAAMC,aAAaD,OAAOvC,IAA1B;AACA,YAAIwC,cAAc,IAAlB,EAAwB;AACtB,iBAAOA,WAAWC,eAAlB;AACD;AACD,eAAO,EAAP;AACD,OANM,CAAP;AAOD;;AAED;;;;;;;;kCAKc;AACZ,UAAIxD,WAAW,IAAf;AACA,WAAK,IAAI+V,CAAT,IAAc,KAAKjW,YAAnB,EAAiC;AAC/B,YAAI,KAAKA,YAAL,CAAkBkW,cAAlB,CAAiCD,CAAjC,CAAJ,EAAyC;AACvC,cAAIlR,aAAa,KAAK/E,YAAL,CAAkBiW,CAAlB,CAAjB;AACA,cAAInR,SAASC,WAAWD,MAAxB;;AAEA,cAAIC,WAAWyB,SAAX,IAAwB,CAAC,KAAKhH,cAAL,CAAoB+F,WAApB,CAAgCT,MAAhC,CAA7B,EAAsE;AACpE;AACA;AACA,gBAAIqR,eAAe,KAAK3W,cAAL,CAAoB4W,kBAApB,CAAuCtR,MAAvC,CAAnB;;AAEA,gBAAIqR,YAAJ,EAAkB;AAChB;AACA;AACAjW,0BAAYiW,YAAZ;AACD;AACF;AACF;AACF;AACD,aAAOjW,QAAP;AACD;;;;;;AAGHlB,mBAAmBqX,OAAnB,GAA6B,CAC3B,SAD2B,EAE3B,OAF2B,EAG3B,WAH2B,EAI3B,IAJ2B,EAK3B,YAL2B,EAM3B,mBAN2B,EAO3B,eAP2B,EAQ3B,gBAR2B,EAS3B,aAT2B,CAA7B;;kBAYerX,kB","file":"studentDataService.js","sourcesContent":["class StudentDataService {\n  constructor(\n      $filter,\n      $http,\n      $injector,\n      $q,\n      $rootScope,\n      AnnotationService,\n      ConfigService,\n      ProjectService,\n      UtilService) {\n    this.$filter = $filter;\n    this.$http = $http;\n    this.$injector = $injector;\n    this.$q = $q;\n    this.$rootScope = $rootScope;\n    this.AnnotationService = AnnotationService;\n    this.ConfigService = ConfigService;\n    this.ProjectService = ProjectService;\n    this.UtilService = UtilService;\n    this.$translate = this.$filter('translate');\n    this.currentNode = null;\n    this.previousStep = null;\n    this.studentData = null;\n    this.stackHistory = [];  // array of node id's\n    this.visitedNodesHistory = [];\n    this.nodeStatuses = {};\n    this.runStatus = null;\n    this.maxScore = null;\n\n    this.maxPlanningNodeNumber = 0;\n\n    /*\n     * A counter to keep track of how many saveToServer requests we have\n     * made that we haven't received a response for yet. When this value\n     * goes back down to 0, we will send update the student status and then\n     * save it to the server.\n     */\n    this.saveToServerRequestCount = 0;\n\n    /*\n     * A dummy student work id that is used in preview mode when we simulate\n     * saving of student data.\n     */\n    this.dummyStudentWorkId = 1;\n\n    // listen for node status changes\n    this.$rootScope.$on('nodeStatusesChanged', (event, args) => {\n      // calculate active global annotations and group them by group name as needed\n      this.AnnotationService.calculateActiveGlobalAnnotationGroups();\n\n      // go through the global annotations and see if they can be un-globalized by checking if their criterias have been met.\n      let globalAnnotationGroups = this.AnnotationService.getActiveGlobalAnnotationGroups();\n      globalAnnotationGroups.map((globalAnnotationGroup) => {\n        let globalAnnotations = globalAnnotationGroup.annotations;\n        globalAnnotations.map((globalAnnotation) => {\n          if (globalAnnotation.data != null && globalAnnotation.data.isGlobal) {\n            let unGlobalizeConditional = globalAnnotation.data.unGlobalizeConditional;\n            let unGlobalizeCriteriaArray = globalAnnotation.data.unGlobalizeCriteria;\n            if (unGlobalizeCriteriaArray != null) {\n              if (unGlobalizeConditional === \"any\") {\n                // at least one criteria in unGlobalizeCriteriaArray must be satisfied in any order before un-globalizing this annotation\n                let anySatified = false;\n                for (let unGlobalizeCriteria of unGlobalizeCriteriaArray) {\n                  let unGlobalizeCriteriaResult = this.evaluateCriteria(unGlobalizeCriteria);\n                  anySatified = anySatified || unGlobalizeCriteriaResult;\n                }\n                if (anySatified) {\n                  globalAnnotation.data.unGlobalizedTimestamp = Date.parse(new Date());  // save when criteria was satisfied\n                  this.saveAnnotations([globalAnnotation]);  // save changes to server\n                }\n              } else if (unGlobalizeConditional === \"all\") {\n                // all criteria in unGlobalizeCriteriaArray must be satisfied in any order before un-globalizing this annotation\n                let allSatisfied = true;\n                for (let unGlobalizeCriteria of unGlobalizeCriteriaArray) {\n                  let unGlobalizeCriteriaResult = this.evaluateCriteria(unGlobalizeCriteria);\n                  allSatisfied = allSatisfied && unGlobalizeCriteriaResult;\n                }\n                if (allSatisfied) {\n                  globalAnnotation.data.unGlobalizedTimestamp = Date.parse(new Date());  // save when criteria was satisfied\n                  this.saveAnnotations([globalAnnotation]);  // save changes to server\n                }\n              }\n            }\n          }\n        });\n      })\n    });\n\n    /**\n     * Listen for the 'newAnnotationReceived' event which is fired when\n     * student receives a new annotation from the server\n     */\n    this.$rootScope.$on('newAnnotationReceived', (event, args) => {\n      if (args) {\n        // get the annotation that was saved to the server\n        let annotation = args.annotation;\n        this.handleAnnotationReceived(annotation);\n      }\n    });\n  }\n\n  retrieveStudentData() {\n    if (this.ConfigService.isPreview()) {\n      // initialize dummy student data\n      this.studentData = {};\n      this.studentData.componentStates = [];\n      this.studentData.nodeStates = [];\n      this.studentData.events = [];\n      this.studentData.annotations = [];\n      this.studentData.userName = this.$translate('PREVIEW_STUDENT');\n      this.studentData.userId = '0';\n\n      // set the annotations into the annotation service\n      this.AnnotationService.setAnnotations(this.studentData.annotations);\n\n      // populate the student history\n      this.populateHistories(this.studentData.events);\n\n      // update the node statuses\n      this.updateNodeStatuses();\n    } else {\n      const studentDataURL = this.ConfigService.getConfigParam('studentDataURL');\n\n      const httpParams = {};\n      httpParams.method = 'GET';\n      httpParams.url = studentDataURL;\n\n      const params = {};\n      params.workgroupId = this.ConfigService.getWorkgroupId();\n      params.runId = this.ConfigService.getRunId();\n      params.getStudentWork = true;\n      params.getEvents = true;\n      params.getAnnotations = true;\n      params.toWorkgroupId = this.ConfigService.getWorkgroupId();\n      httpParams.params = params;\n\n      // make the request for the student data\n      return this.$http(httpParams).then((result) => {\n        const resultData = result.data;\n        if (resultData != null) {\n          this.studentData = {};\n\n          // get student work\n          this.studentData.componentStates = [];\n          this.studentData.nodeStates = [];\n          const studentWorkList = resultData.studentWorkList;\n          for (let studentWork of studentWorkList) {\n            if (studentWork.componentId != null) {\n              this.studentData.componentStates.push(studentWork);\n            } else {\n              this.studentData.nodeStates.push(studentWork);\n            }\n          }\n\n          // Check to see if this Project contains any Planning activities\n          if (this.ProjectService.project.nodes != null && this.ProjectService.project.nodes.length > 0) {\n            // Overload/add new nodes based on student's work in the NodeState for the planning group.\n            for (let planningGroupNode of this.ProjectService.project.nodes) {\n              if (planningGroupNode.planning) {\n                let lastestNodeStateForPlanningGroupNode = this.getLatestNodeStateByNodeId(planningGroupNode.id);\n                if (lastestNodeStateForPlanningGroupNode != null) {\n                  let studentModifiedNodes = lastestNodeStateForPlanningGroupNode.studentData.nodes;\n                  if (studentModifiedNodes != null) {\n                    for (let studentModifiedNode of studentModifiedNodes) {\n                      let studentModifiedNodeId = studentModifiedNode.id;\n                      if (studentModifiedNode.planning) {\n                        // If this is a Planning Node that exists in the project, replace the one in the original project with this one.\n                        for (let n = 0; n < this.ProjectService.project.nodes.length; n++) {\n                          if (this.ProjectService.project.nodes[n].id === studentModifiedNodeId) {\n                            // Only overload the ids. This will allow authors to add more planningNodes during the run if needed.\n                            this.ProjectService.project.nodes[n].ids = studentModifiedNode.ids;\n                          }\n                        }\n                      } else {\n                        // Otherwise, this is an instance of a PlanningNode template, so just append it to the end of the Project.nodes\n                        this.ProjectService.project.nodes.push(studentModifiedNode);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            // Re-parse the project with the modified changes\n            this.ProjectService.parseProject();\n          }\n\n          this.studentData.events = resultData.events;\n          this.studentData.annotations = resultData.annotations;\n          this.AnnotationService.setAnnotations(this.studentData.annotations);\n          this.populateHistories(this.studentData.events);\n          this.updateNodeStatuses();\n        }\n\n        return this.studentData;\n      });\n    }\n  };\n\n  /**\n   * Retrieve the run status\n   */\n  retrieveRunStatus() {\n    if (this.ConfigService.isPreview()) {\n      this.runStatus = {};\n    } else {\n      const runStatusURL = this.ConfigService.getConfigParam('runStatusURL');\n      const runId = this.ConfigService.getConfigParam('runId');\n\n      const params = {\n        runId:runId\n      };\n\n      const httpParams = {};\n      httpParams.method = 'GET';\n      httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n      httpParams.url = runStatusURL;\n      httpParams.params = params;\n\n      return this.$http(httpParams).then((result) => {\n        if (result != null) {\n          const data = result.data;\n          if (data != null) {\n            this.runStatus = data;\n          }\n        }\n      });\n    }\n  }\n\n  getNodeStatuses() {\n    return this.nodeStatuses;\n  };\n\n  setNodeStatusByNodeId(nodeId, nodeStatus) {\n    if (nodeId != null && nodeStatus != null) {\n      const nodeStatuses = this.nodeStatuses;\n      if (nodeStatuses != null) {\n        nodeStatuses[nodeId] = nodeStatus;\n      }\n    }\n  }\n\n  getNodeStatusByNodeId(nodeId) {\n    const nodeStatuses = this.nodeStatuses;\n    if (nodeId != null && nodeStatuses != null) {\n      return nodeStatuses[nodeId];\n    }\n    return null;\n  };\n\n  updateNodeStatuses() {\n    let nodes = this.ProjectService.getNodes();\n    let planningNodes = this.ProjectService.getPlanningNodes();\n    const groups = this.ProjectService.getGroups();\n\n    if (nodes != null) {\n      if (planningNodes != null) {\n        nodes = nodes.concat(planningNodes);\n      }\n      for (let node of nodes) {\n        if (!this.ProjectService.isGroupNode(node.id)) {\n          this.updateNodeStatusByNode(node);\n        }\n      }\n    }\n\n    let group;\n    if (groups != null) {\n      for (let group of groups) {\n        group.depth = this.ProjectService.getNodeDepth(group.id);\n      }\n\n      // sort by descending depth order (need to calculate completion for lowest level groups first)\n      groups.sort(function(a, b) {\n        return b.depth - a.depth;\n      });\n\n      for (let group of groups) {\n        this.updateNodeStatusByNode(group);\n      }\n    }\n\n    // update max score\n    this.maxScore = this.getMaxScore();\n    this.$rootScope.$broadcast('nodeStatusesChanged');\n  };\n\n  /**\n   * Update the node status for a node\n   * @param node the node to update\n   */\n  updateNodeStatusByNode(node) {\n    if (node != null) {\n      const nodeId = node.id;\n      const tempNodeStatus = {};\n      tempNodeStatus.nodeId = nodeId;\n      tempNodeStatus.isVisitable = true;\n      tempNodeStatus.isCompleted = true;\n\n      // get the constraints that affect this node\n      let constraintsForNode = this.ProjectService.getConstraintsForNode(node);\n\n      if (this.ConfigService.getConfigParam('constraints') == false) {\n        /*\n         * constraints have been disabled, most likely because we are\n         * in preview without constraints mode\n         */\n        constraintsForNode = null;\n      }\n\n      if (constraintsForNode == null || constraintsForNode.length == 0) {\n        if (this.ProjectService.getFlattenedProjectAsNodeIds().indexOf(nodeId) == -1 &&\n          !this.ProjectService.isGroupNode(nodeId)) {\n          // there are no transitions to this node so it is not visible\n          tempNodeStatus.isVisible = false;\n          tempNodeStatus.isVisitable = true;\n        } else {\n          // this node does not have any constraints so it is clickable\n          tempNodeStatus.isVisible = true;\n          tempNodeStatus.isVisitable = true;\n        }\n      } else {\n        const isVisibleResults = [];\n        const isVisitableResults = [];\n\n        let result = false;\n        const firstResult = true;\n\n        for (let constraintForNode of constraintsForNode) {\n          if (constraintForNode != null) {\n            // evaluate the constraint to see if the node can be visited\n            const tempResult = this.evaluateConstraint(node, constraintForNode);\n\n            const action = constraintForNode.action;\n\n            if (action != null) {\n              if (action === 'makeThisNodeNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeThisNodeNotVisitable') {\n                isVisitableResults.push(tempResult);\n              } else if (action === 'makeAllNodesAfterThisNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n                isVisitableResults.push(tempResult);\n              } else if (action === 'makeAllOtherNodesNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeAllOtherNodesNotVisitable') {\n                isVisitableResults.push(tempResult);\n              }\n            }\n          }\n        }\n\n        let isVisible = true;\n        let isVisitable = true;\n\n        for (let isVisibleResult of isVisibleResults) {\n          isVisible = isVisible && isVisibleResult;\n        }\n\n        for (let isVisitableResult of isVisitableResults) {\n          isVisitable = isVisitable && isVisitableResult;\n        }\n\n        tempNodeStatus.isVisible = isVisible;\n        tempNodeStatus.isVisitable = isVisitable;\n      }\n\n      tempNodeStatus.isCompleted = this.isCompleted(nodeId);\n      tempNodeStatus.isVisited = this.isNodeVisited(nodeId);\n\n      const nodeStatus = this.getNodeStatusByNodeId(nodeId);\n\n      if (nodeStatus == null) {\n        this.setNodeStatusByNodeId(nodeId, tempNodeStatus);\n      } else {\n        /*\n         * get the previous isCompleted value so that we can later check\n         * if it has changed\n         */\n        const previousIsCompletedValue = this.nodeStatuses[nodeId].isCompleted;\n\n        this.nodeStatuses[nodeId].isVisited = tempNodeStatus.isVisited;\n        this.nodeStatuses[nodeId].isVisible = tempNodeStatus.isVisible;\n        this.nodeStatuses[nodeId].isVisitable = tempNodeStatus.isVisitable;\n        this.nodeStatuses[nodeId].isCompleted = tempNodeStatus.isCompleted;\n\n        if (previousIsCompletedValue == false && tempNodeStatus.isCompleted) {\n          /*\n           * the node status just changed from false to true so we\n           * will fire an event\n           */\n          this.$rootScope.$broadcast('nodeCompleted', { nodeId: nodeId });\n        }\n      }\n\n      this.nodeStatuses[nodeId].progress = this.getNodeProgressById(nodeId);\n      this.nodeStatuses[nodeId].icon = this.ProjectService.getNodeIconByNodeId(nodeId);\n\n      // get the latest component state for the node\n      const latestComponentStatesForNode = this.getLatestComponentStateByNodeId(nodeId);\n      if (latestComponentStatesForNode != null) {\n        // set the latest component state timestamp into the node status\n        this.nodeStatuses[nodeId].latestComponentStateClientSaveTime = latestComponentStatesForNode.clientSaveTime;\n        this.nodeStatuses[nodeId].latestComponentStateServerSaveTime = latestComponentStatesForNode.serverSaveTime;\n      }\n    }\n  };\n\n  /**\n   * Evaluate the constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node has satisfied the constraint\n   */\n  evaluateConstraint(node, constraintForNode) {\n    if (constraintForNode != null) {\n      const removalCriteria = constraintForNode.removalCriteria;\n      if (removalCriteria != null) {\n        return this.evaluateNodeConstraint(node, constraintForNode);\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Evaluate the guided navigation constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node can be visited or not\n   */\n  evaluateGuidedNavigationConstraint(node, constraintForNode) {\n    let result = false;\n    if (node != null) {\n      const nodeId = node.id;\n\n      if (this.isNodeVisited(nodeId)) {\n        // the node has been visited before so it should be clickable\n        result = true;\n      } else {\n        // get all the nodes that have been visited\n        const visitedNodes = this.getVisitedNodesHistory();\n\n        let transitionsToNodeId = [];\n\n        for (let visitedNodeId of visitedNodes) {\n          // get the transitions from the visited node to the node status node\n          const transitions = this.ProjectService.getTransitionsByFromAndToNodeId(visitedNodeId, nodeId);\n\n          // TODO: check if the transition can be used by the student\n\n          // concat the node ids\n          transitionsToNodeId = transitionsToNodeId.concat(transitions);\n        }\n\n        if (transitionsToNodeId != null && transitionsToNodeId.length > 0) {\n          // there is a transition between the current node and the node status node\n\n          /*\n           * there are transitions from the current node to the node status node so\n           * the node status node is clickable\n           */\n          result = true;\n        } else {\n          /*\n           * there is no transition between the visited nodes and the node status node\n           * so we will set the node to be not clickable\n           */\n          result = false;\n        }\n\n        if (this.ProjectService.isStartNode(node)) {\n          /*\n           * the node is the start node of the project or a start node of a group\n           * so we will make it clickable\n           */\n          result = true;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Evaluate the node constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node satisifies the constraint\n   */\n  evaluateNodeConstraint(node, constraintForNode) {\n    let result = false;\n\n    if (constraintForNode != null) {\n      const removalCriteria = constraintForNode.removalCriteria;\n      const removalConditional = constraintForNode.removalConditional;\n      if (removalCriteria == null) {\n        result = true;\n      } else {\n        let firstResult = true;\n        for (let tempCriteria of removalCriteria) {\n          if (tempCriteria != null) {\n            // evaluate the criteria\n            const tempResult = this.evaluateCriteria(tempCriteria);\n\n            if (firstResult) {\n              // this is the first criteria in this for loop\n              result = tempResult;\n              firstResult = false;\n            } else {\n              // this is not the first criteria\n\n              if (removalConditional === 'any') {\n                // any of the criteria can be true to remove the constraint\n                result = result || tempResult;\n              } else {\n                // all the criteria need to be true to remove the constraint\n                result = result && tempResult;\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n\n  /**\n   * Evaluate the criteria\n   * @param criteria the criteria\n   * @returns whether the criteria is satisfied or not\n   */\n  evaluateCriteria(criteria) {\n    let result = false;\n    if (criteria != null) {\n      const functionName = criteria.name;\n      if (functionName == null) {\n\n      } else if (functionName === 'branchPathTaken') {\n        result = this.evaluateBranchPathTakenCriteria(criteria);\n      } else if (functionName === 'isVisible') {\n\n      } else if (functionName === 'isVisitable') {\n\n      } else if (functionName === 'isVisited') {\n        result = this.evaluateIsVisitedCriteria(criteria);\n      } else if (functionName === 'isVisitedAfter') {\n        result = this.evaluateIsVisitedAfterCriteria(criteria);\n      } else if (functionName === 'isRevisedAfter') {\n        result = this.evaluateIsRevisedAfterCriteria(criteria);\n      } else if (functionName === 'isVisitedAndRevisedAfter') {\n        result = this.evaluateIsVisitedAndRevisedAfterCriteria(criteria);\n      } else if (functionName === 'isCompleted') {\n        result = this.evaluateIsCompletedCriteria(criteria);\n      } else if (functionName === 'isCorrect') {\n        result = this.evaluateIsCorrectCriteria(criteria);\n      } else if (functionName === 'choiceChosen') {\n        result = this.evaluateChoiceChosenCriteria(criteria);\n      } else if (functionName === 'isPlanningActivityCompleted') {\n        result = this.evaluateIsPlanningActivityCompletedCriteria(criteria);\n      } else if (functionName === 'score') {\n        result = this.evaluateScoreCriteria(criteria);\n      } else if (functionName === 'usedXSubmits') {\n        result = this.evaluateUsedXSubmitsCriteria(criteria);\n      } else if (functionName === 'wroteXNumberOfWords') {\n        result = this.evaluateNumberOfWordsWrittenCriteria(criteria);\n      } else if (functionName === '') {\n\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if the isCompleted criteria was satisfied\n   * @param criteria an isCompleted criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsCompletedCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n      const nodeId = params.nodeId;\n      return this.isCompleted(nodeId);\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isCorrect criteria was satisfied\n   * @param criteria an isCorrect criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsCorrectCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n\n      if (nodeId != null && componentId != null) {\n        const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n        if (componentStates != null) {\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const studentData = componentState.studentData;\n              if (studentData != null) {\n                if (studentData.isCorrect) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isPlanningActivityCompleted criteria was satisfied\n   * @param criteria a isPlanningActivityCompleted criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsPlanningActivityCompletedCriteria(criteria) {\n    let result = false;\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n\n      // get the group id\n      const nodeId = params.nodeId;\n\n      // get the number of planning steps the student needs to create\n      const planningStepsCreated = params.planningStepsCreated;\n\n      // get whether the student needs to complete all the steps in the activity\n      const planningStepsCompleted = params.planningStepsCompleted;\n\n      let planningStepsCreatedSatisfied = false;\n      let planningStepsCompletedSatisfied = false;\n\n      let planningNodes = [];\n\n      if (planningStepsCreated == null) {\n        // there is no value set so we will regard it as satisfied\n        planningStepsCreatedSatisfied = true;\n      } else {\n        /*\n         * there is a value for number of planning steps that need to be created\n         * so we will check if the student created enough planning steps\n         */\n\n        // get the node states for the activity\n        const nodeStates = this.getNodeStatesByNodeId(nodeId);\n\n        if (nodeStates != null) {\n          for (let ns = nodeStates.length - 1; ns >= 0; ns--) {\n            let planningStepCount = 0;\n            const nodeState = nodeStates[ns];\n            if (nodeState != null) {\n              const studentData = nodeState.studentData;\n              if (studentData != null) {\n                const nodes = studentData.nodes;\n                if (nodes != null) {\n                  for (let node of nodes) {\n                    if (node != null) {\n                      if (node.type === 'node' && node.planningNodeTemplateId != null) {\n                        // we have found a planning step the student created\n                        planningStepCount++;\n                      }\n                    }\n                  }\n\n                  if (planningStepCount >= planningStepsCreated) {\n                    // the student has created a sufficient number of planning steps\n                    planningStepsCreatedSatisfied = true;\n                    planningNodes = nodes;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (planningStepsCompleted == null) {\n        planningStepsCompletedSatisfied = true;\n      } else {\n        /*\n         * check if the activity is completed. this checks if all\n         * the children of the activity are completed.\n         */\n        if (this.isCompleted(nodeId)) {\n          planningStepsCompletedSatisfied = true;\n        }\n      }\n\n      if (planningStepsCreatedSatisfied && planningStepsCompletedSatisfied) {\n        result = true;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Check if this branchPathTaken criteria was satisfied\n   * @param criteria a branchPathTaken criteria\n   * @returns whether the branchPathTaken criteria was satisfied\n   */\n  evaluateBranchPathTakenCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      // get the expected from and to node ids\n      const expectedFromNodeId = criteria.params.fromNodeId;\n      const expectedToNodeId = criteria.params.toNodeId;\n\n      // get all the branchPathTaken events from the from node id\n      const branchPathTakenEvents = this.getBranchPathTakenEventsByNodeId(expectedFromNodeId);\n\n      if (branchPathTakenEvents != null) {\n        for (let branchPathTakenEvent of branchPathTakenEvents) {\n          if (branchPathTakenEvent != null) {\n            const data = branchPathTakenEvent.data;\n            if (data != null) {\n              // get the from and to node ids of the event\n              const fromNodeId = data.fromNodeId;\n              const toNodeId = data.toNodeId;\n              if (expectedFromNodeId === fromNodeId && expectedToNodeId === toNodeId) {\n                // the from and to node ids match the ones we are looking for\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Check if the isVisited criteria was satisfied\n   * @param criteria the isVisited criteria\n   * @returns whether the node id is visited\n   */\n  evaluateIsVisitedCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      const nodeId = criteria.params.nodeId;\n      const events = this.studentData.events;\n      if (events != null) {\n        for (let event of events) {\n          if (event != null) {\n            if (nodeId == event.nodeId && 'nodeEntered' === event.event) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isVisitedAfter criteria was satisfied\n   * @param criteria the isVisitedAfter criteria\n   * @returns whether the node id is visited after the criteriaCreatedTimestamp\n   */\n  evaluateIsVisitedAfterCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      let isVisitedAfterNodeId = criteria.params.isVisitedAfterNodeId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      let events = this.studentData.events;\n      if (events != null) {\n        for (let event of events) {\n          if (event != null) {\n            if (isVisitedAfterNodeId == event.nodeId &&\n              'nodeEntered' === event.event &&\n              event.clientSaveTime > criteriaCreatedTimestamp) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isRevisedAfter criteria was satisfied\n   * @param criteria the isRevisedAfter criteria\n   * @returns whether the specified node&component was revisted after the criteriaCreatedTimestamp\n   */\n  evaluateIsRevisedAfterCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      let isRevisedAfterNodeId = criteria.params.isRevisedAfterNodeId;\n      let isRevisedAfterComponentId = criteria.params.isRevisedAfterComponentId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      // the student has entered the node after the criteriaCreatedTimestamp.\n      // now check if student has revised the work after this event\n      let latestComponentStateForRevisedComponent = this.getLatestComponentStateByNodeIdAndComponentId(isRevisedAfterNodeId, isRevisedAfterComponentId);\n      if (latestComponentStateForRevisedComponent.clientSaveTime > criteriaCreatedTimestamp) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isVisitedAndRevisedAfter criteria was satisfied\n   * @param criteria the isVisitedAndRevisedAfter criteria\n   * @returns whether the specified nodes were visited and specified node&component was revisted after the criteriaCreatedTimestamp\n   */\n  evaluateIsVisitedAndRevisedAfterCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      // get the node id we want to check if was visited\n      let isVisitedAfterNodeId = criteria.params.isVisitedAfterNodeId;\n      let isRevisedAfterNodeId = criteria.params.isRevisedAfterNodeId;\n      let isRevisedAfterComponentId = criteria.params.isRevisedAfterComponentId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      let events = this.studentData.events;\n      if (events != null) {\n        for (let event of events) {\n          if (event != null) {\n            if (isVisitedAfterNodeId == event.nodeId && 'nodeEntered' === event.event && event.clientSaveTime > criteriaCreatedTimestamp) {\n              // the student has entered the node after the criteriaCreatedTimestamp.\n              // now check if student has revised the work after this event\n              let latestComponentStateForRevisedComponent = this.getLatestComponentStateByNodeIdAndComponentId(isRevisedAfterNodeId, isRevisedAfterComponentId);\n              if (latestComponentStateForRevisedComponent.clientSaveTime > event.clientSaveTime) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get all the branchPathTaken events by node id\n   * @params fromNodeId the from node id\n   * @returns all the branchPathTaken events from the given node id\n   */\n  getBranchPathTakenEventsByNodeId(fromNodeId) {\n    const branchPathTakenEvents = [];\n    const events = this.studentData.events;\n    if (events != null) {\n      for (let event of events) {\n        if (event != null) {\n          if (fromNodeId === event.nodeId && 'branchPathTaken' === event.event) {\n            // we have found a branchPathTaken event from the from node id\n            branchPathTakenEvents.push(event);\n          }\n        }\n      }\n    }\n    return branchPathTakenEvents;\n  }\n\n  /**\n   * Evaluate the choice chosen criteria\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the criteria was satisfied or not\n   */\n  evaluateChoiceChosenCriteria(criteria) {\n    const serviceName = 'MultipleChoiceService';  // Assume MC component.\n    if (this.$injector.has(serviceName)) {\n      const service = this.$injector.get(serviceName);\n      return service.choiceChosen(criteria);\n    }\n    return false;\n  };\n\n  /**\n   * Evaluate the score criteria\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the criteria was satisfied or not\n   */\n  evaluateScoreCriteria(criteria) {\n    const params = criteria.params;\n    if (params != null) {\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n      const scores = params.scores;\n      const workgroupId = this.ConfigService.getWorkgroupId();\n      const scoreType = 'any';\n      if (nodeId != null && componentId != null && scores != null) {\n        const latestScoreAnnotation = this.AnnotationService.getLatestScoreAnnotation(nodeId, componentId, workgroupId, scoreType);\n        if (latestScoreAnnotation != null) {\n          const scoreValue = this.AnnotationService.getScoreValueFromScoreAnnotation(latestScoreAnnotation);\n\n          // check if the score value matches what the criteria is looking for. works when scores is array of integers or integer strings\n          if (scores.indexOf(scoreValue) != -1 || (scoreValue != null && scores.indexOf(scoreValue.toString()) != -1)) {\n            /*\n             * the student has received a score that matches a score\n             * we're looking for\n             */\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Evaluate the used x submits criteria which requires the student to submit\n   * at least x number of times.\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the student submitted at least x number\n   * of times\n   */\n  evaluateUsedXSubmitsCriteria(criteria) {\n    const params = criteria.params;\n    if (params != null) {\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n      const requiredSubmitCount = params.requiredSubmitCount;\n\n      if (nodeId != null && componentId != null) {\n        const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n        if (componentStates != null) {\n          // counter for manually counting the component states with isSubmit=true\n          let manualSubmitCounter = 0;\n\n          // counter for remembering the highest submitCounter value found in studentData objects\n          let highestSubmitCounter = 0;\n\n          /*\n           * We are counting with two submit counters for backwards compatibility.\n           * Some componentStates only have isSubmit=true and do not keep an\n           * updated submitCounter for the number of submits.\n           */\n\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              if (componentState.isSubmit) {\n                manualSubmitCounter++;\n              }\n              const studentData = componentState.studentData;\n              if (studentData != null) {\n                if (studentData.submitCounter != null) {\n                  if (studentData.submitCounter > highestSubmitCounter) {\n                    /*\n                     * the submit counter in the student data is higher\n                     * than we have previously seen\n                     */\n                    highestSubmitCounter = studentData.submitCounter;\n                  }\n                }\n              }\n            }\n          }\n\n          if (manualSubmitCounter >= requiredSubmitCount || highestSubmitCounter >= requiredSubmitCount) {\n            // the student submitted the required number of times\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Evaluate the number of words written criteria.\n   * @param criteria The criteria to evaluate.\n   * @return A boolean value whether the student wrote the required number of\n   * words.\n   */\n  evaluateNumberOfWordsWrittenCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n      const requiredNumberOfWords = params.requiredNumberOfWords;\n\n      if (nodeId != null && componentId != null) {\n        const componentState = this.getLatestComponentStateByNodeIdAndComponentId(nodeId, componentId);\n        if (componentState != null) {\n          const studentData = componentState.studentData;\n          const response = studentData.response;\n          const numberOfWords = this.UtilService.wordCount(response);\n          if (numberOfWords >= requiredNumberOfWords) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Populate the stack history and visited nodes history\n   * @param events the events\n   */\n  populateHistories(events) {\n    this.stackHistory = [];\n    this.visitedNodesHistory = [];\n\n    if (events != null) {\n      for (let event of events) {\n        if (event != null && event.event === 'nodeEntered') {\n          this.updateStackHistory(event.nodeId);\n          this.updateVisitedNodesHistory(event.nodeId);\n        }\n      }\n    }\n  };\n\n  getStackHistoryAtIndex(index) {\n    if (index < 0) {\n      index = this.stackHistory.length + index;\n    }\n    if (this.stackHistory != null && this.stackHistory.length > 0) {\n      return this.stackHistory[index];\n    }\n    return null;\n  };\n\n  getStackHistory() {\n    return this.stackHistory;\n  };\n\n  updateStackHistory(nodeId) {\n    const indexOfNodeId = this.stackHistory.indexOf(nodeId);\n    if (indexOfNodeId === -1) {\n      this.stackHistory.push(nodeId);\n    } else {\n      this.stackHistory.splice(indexOfNodeId + 1, this.stackHistory.length);\n    }\n  };\n\n  updateVisitedNodesHistory(nodeId) {\n    const indexOfNodeId = this.visitedNodesHistory.indexOf(nodeId);\n    if (indexOfNodeId === -1) {\n      this.visitedNodesHistory.push(nodeId);\n    }\n  };\n\n  getVisitedNodesHistory() {\n    return this.visitedNodesHistory;\n  };\n\n  isNodeVisited(nodeId) {\n    const visitedNodesHistory = this.visitedNodesHistory;\n    if (visitedNodesHistory != null) {\n      const indexOfNodeId = visitedNodesHistory.indexOf(nodeId);\n      if (indexOfNodeId !== -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  createComponentState() {\n    const componentState = {};\n    componentState.timestamp = Date.parse(new Date());\n    return componentState;\n  };\n\n  addComponentState(componentState) {\n    if (this.studentData != null && this.studentData.componentStates != null) {\n      this.studentData.componentStates.push(componentState);\n    }\n  };\n\n  addNodeState(nodeState) {\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      this.studentData.nodeStates.push(nodeState);\n    }\n  };\n\n  /**\n   * Returns all NodeStates\n   * @returns Array of all NodeStates\n   */\n  getNodeStates() {\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      return this.studentData.nodeStates;\n    }\n    return [];\n  };\n\n  /**\n   * Get all NodeStates for a specific node\n   * @param nodeId id of node\n   * @returns Array of NodeStates for the specified node\n   */\n  getNodeStatesByNodeId(nodeId) {\n    const nodeStatesByNodeId = [];\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      const nodeStates = this.studentData.nodeStates;\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          const tempNodeId = nodeState.nodeId;\n          if (nodeId === tempNodeId) {\n            nodeStatesByNodeId.push(nodeState);\n          }\n        }\n      }\n    }\n    return nodeStatesByNodeId;\n  };\n\n  addEvent(event) {\n    if (this.studentData != null && this.studentData.events != null) {\n      this.studentData.events.push(event);\n    }\n  };\n\n  addAnnotation(annotation) {\n    if (this.studentData != null && this.studentData.annotations != null) {\n      this.studentData.annotations.push(annotation);\n    }\n  };\n\n  handleAnnotationReceived(annotation) {\n    this.studentData.annotations.push(annotation);\n    if (annotation.notebookItemId) {\n      this.$rootScope.$broadcast('notebookItemAnnotationReceived', {annotation: annotation});\n    } else {\n      this.$rootScope.$broadcast('annotationReceived', {annotation: annotation});\n    }\n  }\n\n  saveComponentEvent(component, category, event, data) {\n    if (component == null || category == null || event == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_COMPONENT_EVENT_COMPONENT_CATEGORY_EVENT_ERROR'));\n      return;\n    }\n    const context = \"Component\";\n    const nodeId = component.nodeId;\n    const componentId = component.componentId;\n    const componentType = component.componentType;\n    if (nodeId == null || componentId == null || componentType == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_COMPONENT_EVENT_NODE_ID_COMPONENT_ID_COMPONENT_TYPE_ERROR'));\n      return;\n    }\n    this.saveEvent(context, nodeId, componentId, componentType, category, event, data);\n  };\n\n  saveVLEEvent(nodeId, componentId, componentType, category, event, data) {\n    if (category == null || event == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_VLE_EVENT_CATEGORY_EVENT_ERROR'));\n      return;\n    }\n    const context = \"VLE\";\n    this.saveEvent(context, nodeId, componentId, componentType, category, event, data);\n  };\n\n  saveEvent(context, nodeId, componentId, componentType, category, event, data) {\n    const events = [];\n    const newEvent = this.createNewEvent();\n    newEvent.context = context;\n    newEvent.nodeId = nodeId;\n    newEvent.componentId = componentId;\n    newEvent.type = componentType;\n    newEvent.category = category;\n    newEvent.event = event;\n    newEvent.data = data;\n    events.push(newEvent);\n    const componentStates = null;\n    const nodeStates = null;\n    const annotations = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n  /**\n   * Create a new empty event\n   * @return a new empty event\n   */\n  createNewEvent() {\n    const event = {};\n    event.projectId = this.ConfigService.getProjectId();\n    event.runId = this.ConfigService.getRunId();\n    event.periodId = this.ConfigService.getPeriodId();\n    event.workgroupId = this.ConfigService.getWorkgroupId();\n    event.clientSaveTime = Date.parse(new Date());\n    return event;\n  };\n\n  saveNodeStates(nodeStates) {\n    const componentStates = null;\n    const events = null;\n    const annotations = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n\n  saveAnnotations(annotations) {\n    const componentStates = null;\n    const nodeStates = null;\n    const events = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n  saveToServer(componentStates, nodeStates, events, annotations) {\n    /*\n     * increment the request count since we are about to save data\n     * to the server\n     */\n    this.saveToServerRequestCount += 1;\n\n    // merge componentStates and nodeStates into StudentWork before posting\n    const studentWorkList = [];\n    if (componentStates != null && componentStates.length > 0) {\n      for (let componentState of componentStates) {\n        if (componentState != null) {\n          componentState.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved componentStates.\n          this.addComponentState(componentState);\n          studentWorkList.push(componentState);\n        }\n      }\n    }\n\n    if (nodeStates != null && nodeStates.length > 0) {\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          nodeState.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved componentStates.\n          this.addNodeState(nodeState);\n          studentWorkList.push(nodeState);\n        }\n      }\n    }\n\n    if (events != null && events.length > 0) {\n      for (let event of events) {\n        if (event != null) {\n          event.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved events.\n          this.addEvent(event);\n        }\n      }\n    } else {\n      events = [];\n    }\n\n    if (annotations != null && annotations.length > 0) {\n      for (let annotation of annotations) {\n        if (annotation != null) {\n          annotation.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved annotations.\n          if (annotation.id == null) {\n            // add to local annotation array if this annotation has not been saved to the server before.\n            this.addAnnotation(annotation);\n          }\n        }\n      }\n    } else {\n      annotations = [];\n    }\n\n    if (this.ConfigService.isPreview()) {\n      const savedStudentDataResponse = {\n        studentWorkList: studentWorkList,\n        events: events,\n        annotations: annotations\n      };\n\n      // if we're in preview, don't make any request to the server but pretend we did\n      this.saveToServerSuccess(savedStudentDataResponse);\n      let deferred = this.$q.defer();\n      deferred.resolve(savedStudentDataResponse);\n      return deferred.promise;\n    } else {\n      // set the workgroup id and run id\n      const params = {};\n      params.projectId = this.ConfigService.getProjectId();\n      params.runId = this.ConfigService.getRunId();\n      params.workgroupId = this.ConfigService.getWorkgroupId();\n      params.studentWorkList = angular.toJson(studentWorkList);\n      params.events = angular.toJson(events);\n      params.annotations = angular.toJson(annotations);\n\n      // get the url to POST the student data\n      const httpParams = {};\n      httpParams.method = 'POST';\n      httpParams.url = this.ConfigService.getConfigParam('studentDataURL');\n      httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n      httpParams.data = $.param(params);\n\n      // make the request to post the student data\n      return this.$http(httpParams).then(\n        result => {\n          // get the local references to the component states that were posted and set their id and serverSaveTime\n          if (result != null && result.data != null) {\n            const savedStudentDataResponse = result.data;\n\n            this.saveToServerSuccess(savedStudentDataResponse);\n\n            return savedStudentDataResponse;\n          }\n        }, result => {\n          // a server error occured\n\n          /*\n           * decrement the request count since this request failed\n           * but is now completed\n           */\n          this.saveToServerRequestCount -= 1;\n\n          return null;\n        }\n      );\n    }\n  };\n\n  saveToServerSuccess(savedStudentDataResponse) {\n    // set dummy serverSaveTime for use if we're in preview mode\n    let serverSaveTime = Date.parse(new Date());\n\n    // handle saved studentWork\n    if (savedStudentDataResponse.studentWorkList) {\n      let savedStudentWorkList = savedStudentDataResponse.studentWorkList;\n      let localStudentWorkList = this.studentData.componentStates;\n      if (this.studentData.nodeStates) {\n        localStudentWorkList = localStudentWorkList.concat(this.studentData.nodeStates);\n      }\n\n      // set the id and serverSaveTime in the local studentWorkList\n      for (let savedStudentWork of savedStudentWorkList) {\n        /*\n         * loop through all the student work that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localStudentWorkList.length - 1; l >= 0; l--) {\n          const localStudentWork = localStudentWorkList[l];\n          if (localStudentWork.requestToken &&\n            localStudentWork.requestToken === savedStudentWork.requestToken) {\n            localStudentWork.id = savedStudentWork.id;\n            localStudentWork.serverSaveTime = savedStudentWork.serverSaveTime ? savedStudentWork.serverSaveTime : serverSaveTime;\n            localStudentWork.requestToken = null; // requestToken is no longer needed.\n\n            if (this.ConfigService.getMode() == \"preview\" && localStudentWork.id == null) {\n              /*\n               * we are in preview mode so we will set a dummy\n               * student work id into the student work\n               */\n              localStudentWork.id = this.dummyStudentWorkId;\n\n              /*\n               * increment the dummy student work id for the next\n               * student work\n               */\n              this.dummyStudentWorkId++;\n            }\n\n            this.$rootScope.$broadcast('studentWorkSavedToServer', {studentWork: localStudentWork});\n            break;\n          }\n        }\n      }\n    }\n    // handle saved events\n    if (savedStudentDataResponse.events) {\n      const savedEvents = savedStudentDataResponse.events;\n\n      const localEvents = this.studentData.events;\n\n      // set the id and serverSaveTime in the local event\n      for (let savedEvent of savedEvents) {\n        /*\n         * loop through all the events that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localEvents.length - 1; l >= 0; l--) {\n          const localEvent = localEvents[l];\n          if (localEvent.requestToken &&\n            localEvent.requestToken === savedEvent.requestToken) {\n            localEvent.id = savedEvent.id;\n            localEvent.serverSaveTime = savedEvent.serverSaveTime ? savedEvent.serverSaveTime : serverSaveTime;\n            localEvent.requestToken = null; // requestToken is no longer needed.\n\n            this.$rootScope.$broadcast('eventSavedToServer', {event: localEvent});\n            break;\n          }\n        }\n      }\n    }\n\n    // handle saved annotations\n    if (savedStudentDataResponse.annotations) {\n      const savedAnnotations = savedStudentDataResponse.annotations;\n      const localAnnotations = this.studentData.annotations;\n\n      // set the id and serverSaveTime in the local annotation\n      for (let savedAnnotation of savedAnnotations) {\n        /*\n         * loop through all the events that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localAnnotations.length - 1; l >= 0; l--) {\n          const localAnnotation = localAnnotations[l];\n          if (localAnnotation.requestToken &&\n            localAnnotation.requestToken === savedAnnotation.requestToken) {\n            localAnnotation.id = savedAnnotation.id;\n            localAnnotation.serverSaveTime = savedAnnotation.serverSaveTime ? savedAnnotation.serverSaveTime : serverSaveTime;\n            localAnnotation.requestToken = null; // requestToken is no longer needed.\n\n            this.$rootScope.$broadcast('annotationSavedToServer', {annotation: localAnnotation});\n            break;\n          }\n        }\n      }\n    }\n\n    /*\n     * decrement the request count since we have received a response to\n     * one of our save requests\n     */\n    this.saveToServerRequestCount -= 1;\n\n    if (this.saveToServerRequestCount == 0) {\n      /*\n       * we have received the reponse to all of the saveToServer requests\n       * so we will now update the student status and save it to the\n       * server\n       */\n      this.updateNodeStatuses();\n      this.saveStudentStatus();\n    }\n  };\n\n  /**\n   * POSTs student status to server\n   * Returns a promise of the POST request\n   */\n  saveStudentStatus() {\n    if (!this.ConfigService.isPreview()) {\n      const studentStatusURL = this.ConfigService.getStudentStatusURL();\n      if (studentStatusURL != null) {\n        const runId = this.ConfigService.getRunId();\n        const periodId = this.ConfigService.getPeriodId();\n        const workgroupId = this.ConfigService.getWorkgroupId();\n        const currentNodeId = this.getCurrentNodeId();\n        const nodeStatuses = this.getNodeStatuses();\n        const projectCompletion = this.getProjectCompletion();\n\n        // create the JSON that will be saved to the database\n        const studentStatusJSON = {};\n        studentStatusJSON.runId = runId;\n        studentStatusJSON.periodId = periodId;\n        studentStatusJSON.workgroupId = workgroupId;\n        studentStatusJSON.currentNodeId = currentNodeId;\n        studentStatusJSON.nodeStatuses = nodeStatuses;\n        studentStatusJSON.projectCompletion = projectCompletion;\n\n        const status = angular.toJson(studentStatusJSON);\n        const studentStatusParams = {};\n        studentStatusParams.runId = runId;\n        studentStatusParams.periodId = periodId;\n        studentStatusParams.workgroupId = workgroupId;\n        studentStatusParams.status = status;\n\n        const httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = studentStatusURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n        httpParams.data = $.param(studentStatusParams);\n\n        return this.$http(httpParams).then(\n          result => {\n            return true;\n          }, result => {\n            return false;\n          }\n        );\n      }\n    }\n  };\n\n  retrieveComponentStates(runId, periodId, workgroupId) {\n\n  };\n\n  getLatestComponentState() {\n    const studentData = this.studentData;\n    if (studentData != null) {\n      const componentStates = studentData.componentStates;\n      if (componentStates != null) {\n        return componentStates[componentStates.length - 1];\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Check whether the component has unsubmitted work\n   * @return boolean whether or not there is unsubmitted work\n   */\n  isComponentSubmitDirty() {\n    let latestComponentState = this.getLatestComponentState();\n    if (latestComponentState && !latestComponentState.isSubmit) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Get the latest NodeState for the specified node id\n   * @param nodeId the node id\n   * @return the latest node state with the matching node id or null if none are found\n   */\n  getLatestNodeStateByNodeId(nodeId) {\n    let allNodeStatesByNodeId = this.getNodeStatesByNodeId(nodeId);\n    if (allNodeStatesByNodeId != null && allNodeStatesByNodeId.length > 0) {\n      return allNodeStatesByNodeId[allNodeStatesByNodeId.length - 1];\n    }\n    return null;\n  };\n\n  /**\n   * Get the latest component state for the given node id and component\n   * id.\n   * @param nodeId the node id\n   * @param componentId the component id (optional)\n   * @return the latest component state with the matching node id and\n   * component id or null if none are found\n   */\n  getLatestComponentStateByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId) {\n      const studentData = this.studentData;\n      if (studentData) {\n        // get the component states\n        const componentStates = studentData.componentStates;\n        if (componentStates) {\n          for (let c = componentStates.length - 1; c >= 0; c--) {\n            const componentState = componentStates[c];\n            if (componentState) {\n              const componentStateNodeId = componentState.nodeId;\n              if (nodeId === componentStateNodeId) {\n                if (componentId) {\n                  const componentStateComponentId = componentState.componentId;\n                  if (componentId === componentStateComponentId) {\n                    return componentState;\n                  }\n                } else {\n                  return componentState;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Get the student work by specified student work id, which can be a ComponentState or NodeState\n   * @param studentWorkId the student work id\n   * @return an StudentWork or null\n   */\n  getStudentWorkByStudentWorkId(studentWorkId) {\n    if (studentWorkId != null) {\n      const componentStates = this.studentData.componentStates;\n      if (componentStates != null) {\n        for (let componentState of componentStates) {\n          if (componentState != null && componentState.id === studentWorkId) {\n            return componentState;\n          }\n        }\n      }\n\n      const nodeStates = this.studentData.nodeStates;\n      if (nodeStates != null) {\n        for (let nodeState of nodeStates) {\n          if (nodeState != null && nodeState.id === studentWorkId) {\n            return nodeState;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns all the component states for this workgroup\n   */\n  getComponentStates() {\n    return this.studentData.componentStates;\n  };\n\n  /**\n   * Get the component states for the given node id\n   * @param nodeId the node id\n   * @return an array of component states for the given node id\n   */\n  getComponentStatesByNodeId(nodeId) {\n    const componentStatesByNodeId = [];\n    if (nodeId != null) {\n      const studentData = this.studentData;\n      if (studentData != null) {\n        const componentStates = studentData.componentStates;\n        if (componentStates != null) {\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const componentStateNodeId = componentState.nodeId;\n              if (nodeId == componentStateNodeId) {\n                componentStatesByNodeId.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n    return componentStatesByNodeId;\n  };\n\n  /**\n   * Get the component states for the given node id and component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @return an array of component states for the given node id and\n   * component id\n   */\n  getComponentStatesByNodeIdAndComponentId(nodeId, componentId) {\n    const componentStatesByNodeIdAndComponentId = [];\n    if (nodeId != null && componentId != null) {\n      const studentData = this.studentData;\n      if (studentData != null) {\n        const componentStates = studentData.componentStates;\n        if (componentStates != null) {\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const componentStateNodeId = componentState.nodeId;\n              const componentStateComponentId = componentState.componentId;\n              if (nodeId == componentStateNodeId &&\n                  componentId == componentStateComponentId) {\n                componentStatesByNodeIdAndComponentId.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return componentStatesByNodeIdAndComponentId;\n  };\n\n  /**\n   * Get all events\n   * @returns all events for the student\n   */\n  getEvents() {\n    if (this.studentData != null && this.studentData.events != null) {\n      return this.studentData.events;\n    } else {\n      return [];\n    }\n  };\n\n  /**\n   * Get the events for a node id\n   * @param nodeId the node id\n   * @returns the events for the node id\n   */\n  getEventsByNodeId(nodeId) {\n    const eventsByNodeId = [];\n    if (nodeId != null) {\n      if (this.studentData != null && this.studentData.events != null) {\n        const events = this.studentData.events;\n        for (let event of events) {\n          if (event != null) {\n            const eventNodeId = event.nodeId;\n            if (nodeId === eventNodeId) {\n              eventsByNodeId.push(event);\n            }\n          }\n        }\n      }\n    }\n    return eventsByNodeId;\n  };\n\n  /**\n   * Get the events for a component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of events for the component id\n   */\n  getEventsByNodeIdAndComponentId(nodeId, componentId) {\n    const eventsByNodeId = [];\n    if (nodeId != null) {\n      if (this.studentData != null && this.studentData.events != null) {\n        const events = this.studentData.events;\n        for (let event of events) {\n          if (event != null) {\n            const eventNodeId = event.nodeId;\n            const eventComponentId = event.componentId;\n            if (nodeId === eventNodeId && componentId === eventComponentId) {\n              eventsByNodeId.push(event);\n            }\n          }\n        }\n      }\n    }\n    return eventsByNodeId;\n  };\n\n  /**\n   * Get the node id of the latest node entered event for an active node that\n   * exists in the project. We need to check if the node exists in the project\n   * in case the node has been deleted from the project. We also need to check\n   * that the node is active in case the node has been moved to the inactive\n   * section of the project.\n   * @return the node id of the latest node entered event for an active node\n   * that exists in the project\n   */\n  getLatestNodeEnteredEventNodeIdWithExistingNode() {\n    const events = this.studentData.events;\n    for (let e = events.length - 1; e >= 0; e--) {\n      const event = events[e];\n      if (event != null) {\n        const eventName = event.event;\n        if (eventName == 'nodeEntered') {\n          const nodeId = event.nodeId;\n          const node = this.ProjectService.getNodeById(nodeId);\n          if (node != null) {\n            if (this.ProjectService.isActive(nodeId)) {\n              return nodeId;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if the student can visit the node\n   * @param nodeId the node id\n   * @returns whether the student can visit the node\n   */\n  canVisitNode(nodeId) {\n    if (nodeId != null) {\n      // get the node status for the node\n      const nodeStatus = this.getNodeStatusByNodeId(nodeId);\n      if (nodeStatus != null) {\n        if (nodeStatus.isVisitable) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Get the node status by node id\n   * @param nodeId the node id\n   * @returns the node status object for a node\n   */\n  getNodeStatusByNodeId(nodeId) {\n    if (nodeId != null) {\n      return this.nodeStatuses[nodeId];\n    }\n    return null;\n  };\n\n  /**\n   * Get progress information for a given node\n   * @param nodeId the node id\n   * @returns object with number of completed items (both all and for items\n   * that capture student work), number of visible items (all/with work),\n   * completion % (for all items, items with student work)\n   */\n  getNodeProgressById(nodeId) {\n    let completedItems = 0;\n    let completedItemsWithWork = 0;\n    let totalItems = 0;\n    let totalItemsWithWork = 0;\n    let progress = {};\n\n    if (this.ProjectService.isGroupNode(nodeId)) {\n      let nodeIds = this.ProjectService.getChildNodeIdsById(nodeId);\n      for (let id of nodeIds) {\n        let status = this.nodeStatuses[id];\n        if (this.ProjectService.isGroupNode(id)) {\n          if (status.progress.totalItemsWithWork > -1) {\n            completedItems += status.progress.completedItems;\n            totalItems += status.progress.totalItems;\n            completedItemsWithWork += status.progress.completedItemsWithWork;\n            totalItemsWithWork += status.progress.totalItemsWithWork;\n          } else {\n            // we have a legacy node status so we'll need to calculate manually\n            let groupProgress = this.getNodeProgressById(id);\n            completedItems += groupProgress.completedItems;\n            totalItems += groupProgress.totalItems;\n            completedItemsWithWork += groupProgress.completedItemsWithWork;\n            totalItemsWithWork += groupProgress.totalItemsWithWork;\n          }\n        } else {\n          if (status.isVisible) {\n            totalItems++;\n\n            let hasWork = this.ProjectService.nodeHasWork(id);\n            if (hasWork) {\n              totalItemsWithWork++;\n            }\n\n            if (status.isCompleted) {\n              completedItems++;\n\n              if (hasWork) {\n                completedItemsWithWork++;\n              }\n            }\n          }\n        }\n      }\n\n      let completionPct = totalItems ? Math.round(completedItems / totalItems * 100) : 0;\n      let completionPctWithWork = totalItemsWithWork ? Math.round(completedItemsWithWork / totalItemsWithWork * 100) : 0;\n\n      progress = {\n        \"completedItems\": completedItems,\n        \"completedItemsWithWork\": completedItemsWithWork,\n        \"totalItems\": totalItems,\n        \"totalItemsWithWork\": totalItemsWithWork,\n        \"completionPct\": completionPct,\n        \"completionPctWithWork\": completionPctWithWork\n      };\n    }\n\n    // TODO: implement for steps (using components instead of child nodes)?\n\n    return progress;\n  };\n\n  /**\n   * Check if the given node or component is completed\n   * @param nodeId the node id\n   * @param componentId (optional) the component id\n   * @returns whether the node or component is completed\n   */\n  isCompleted(nodeId, componentId) {\n    let result = false;\n    if (nodeId && componentId) {\n      // check that the component is completed\n\n      // get the component states for the component\n      const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n\n      // get the component events\n      const componentEvents = this.getEventsByNodeIdAndComponentId(nodeId, componentId);\n\n      // get the node events\n      const nodeEvents = this.getEventsByNodeId(nodeId);\n\n      // get the component object\n      const component = this.ProjectService.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n      const node = this.ProjectService.getNodeById(nodeId);\n      if (component != null) {\n        // get the component type\n        const componentType = component.type;\n\n        if (componentType != null) {\n          // get the service for the component type\n          const service = this.$injector.get(componentType + 'Service');\n\n          // check if the component is completed\n          if (service.isCompleted(component, componentStates, componentEvents, nodeEvents, node)) {\n            result = true;\n          }\n        }\n      }\n    } else if (nodeId) {\n      // check if node is a group\n      const isGroup = this.ProjectService.isGroupNode(nodeId);\n\n      const node = this.ProjectService.getNodeById(nodeId);\n\n      if (isGroup) {\n        // node is a group\n        let tempResult = true;\n\n        // check that all the nodes in the group are visible and completed\n        const nodeIds = this.ProjectService.getChildNodeIdsById(nodeId);\n\n        if (nodeIds.length) {\n          for (let id of nodeIds) {\n            if (this.nodeStatuses[id] == null || !this.nodeStatuses[id].isVisible || !this.nodeStatuses[id].isCompleted) {\n              // the child is not visible or not completed so the group is not completed\n              tempResult = false;\n              break;\n            }\n          }\n        } else {\n          // there are no nodes in the group (could be a planning activity, for example), so set isCompleted to false\n          tempResult = false;\n        }\n        result = tempResult;\n      } else {\n        // check that all the components in the node are completed\n\n        // get all the components in the node\n        const components = this.ProjectService.getComponentsByNodeId(nodeId);\n\n        // we will default to is completed true\n        let tempResult = true;\n\n        /*\n         * All components must be completed in order for the node to be completed\n         * so we will loop through all the components and check if they are\n         * completed\n         */\n        for (let component of components) {\n          if (component != null) {\n            const componentId = component.id;\n            const componentType = component.type;\n            const showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n            const showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n\n            let tempNodeId = nodeId;\n            let tempNode = node;\n            let tempComponentId = componentId;\n            let tempComponent = component;\n\n            if (showPreviousWorkNodeId != null && showPreviousWorkComponentId != null) {\n              /*\n               * this is a show previous work component so we will check if the\n               * previous component was completed\n               */\n              tempNodeId = showPreviousWorkNodeId;\n              tempComponentId = showPreviousWorkComponentId;\n              tempNode = this.ProjectService.getNodeById(tempNodeId);\n              tempComponent = this.ProjectService.getComponentByNodeIdAndComponentId(tempNodeId, tempComponentId);\n            }\n\n            if (componentType != null) {\n              try {\n                // get the service name\n                const serviceName = componentType + 'Service';\n\n                if (this.$injector.has(serviceName)) {\n                  // get the service for the component type\n                  const service = this.$injector.get(serviceName);\n\n                  // get the component states for the component\n                  const componentStates = this.getComponentStatesByNodeIdAndComponentId(tempNodeId, tempComponentId);\n\n                  // get the component events\n                  const componentEvents = this.getEventsByNodeIdAndComponentId(tempNodeId, tempComponentId);\n\n                  // get the node events\n                  const nodeEvents = this.getEventsByNodeId(tempNodeId);\n\n                  // check if the component is completed\n                  const isComponentCompleted = service.isCompleted(tempComponent, componentStates, componentEvents, nodeEvents, tempNode);\n\n                  tempResult = tempResult && isComponentCompleted;\n                }\n              } catch (e) {\n                console.log(this.$translate('ERROR_COULD_NOT_CALCULATE_IS_COMPLETED') + tempComponentId);\n              }\n            }\n          }\n        }\n        result = tempResult;\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Get the current node\n   * @returns the current node object\n   */\n  getCurrentNode() {\n    return this.currentNode;\n  };\n\n  /**\n   * Get the current node id\n   * @returns the current node id\n   */\n  getCurrentNodeId() {\n    if (this.currentNode != null) {\n      return this.currentNode.id;\n    }\n    return null;\n  };\n\n  /**\n   * Set the current node\n   * @param nodeId the node id\n   */\n  setCurrentNodeByNodeId(nodeId) {\n    if (nodeId != null) {\n      const node = this.ProjectService.getNodeById(nodeId);\n      this.setCurrentNode(node);\n    }\n  };\n\n  /**\n   * Set the current node\n   * @param node the node object\n   */\n  setCurrentNode(node) {\n    const previousCurrentNode = this.currentNode;\n    if (previousCurrentNode !== node) {\n      if (previousCurrentNode &&\n          !this.ProjectService.isGroupNode(previousCurrentNode.id)) {\n        this.previousStep = previousCurrentNode;\n      }\n      this.currentNode = node;\n      this.$rootScope.$broadcast('currentNodeChanged',\n          {previousNode: previousCurrentNode, currentNode: this.currentNode});\n    }\n  };\n\n  /**\n   * End the current node\n   */\n  endCurrentNode() {\n    const previousCurrentNode = this.currentNode;\n    if (previousCurrentNode != null) {\n      this.$rootScope.$broadcast('exitNode', {nodeToExit: previousCurrentNode});\n    }\n  };\n\n  /**\n   * End the current node and set the current node\n   * @param nodeId the node id of the new current node\n   */\n  endCurrentNodeAndSetCurrentNodeByNodeId(nodeId) {\n    if (this.nodeStatuses[nodeId].isVisitable) {\n      this.endCurrentNode();\n      this.setCurrentNodeByNodeId(nodeId);\n    } else {\n      this.nodeClickLocked(nodeId);\n    }\n  };\n\n  /**\n   * Broadcast a listenable event that a locked node has been clicked (attempted to be opened)\n   * @param nodeId\n   */\n  nodeClickLocked(nodeId) {\n    this.$rootScope.$broadcast('nodeClickLocked', {nodeId: nodeId});\n  };\n\n  /**\n   * This will parse a delimited string into an array of\n   * arrays. The default delimiter is the comma, but this\n   * can be overriden in the second argument.\n   * Source: http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\n   */\n  CSVToArray( strData, strDelimiter ) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    strDelimiter = (strDelimiter || \",\");\n\n    // Create a regular expression to parse the CSV values.\n    const objPattern = new RegExp(\n      (\n        // Delimiters.\n        \"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n        // Quoted fields.\n        \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n        // Standard fields.\n        \"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\"\n      ),\n      \"gi\"\n    );\n\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    const arrData = [[]];\n\n    // Create an array to hold our individual pattern\n    // matching groups.\n    let arrMatches = null;\n\n\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (arrMatches = objPattern.exec( strData )) {\n\n      // Get the delimiter that was found.\n      const strMatchedDelimiter = arrMatches[ 1 ];\n\n      // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n      if (\n        strMatchedDelimiter.length &&\n        (strMatchedDelimiter != strDelimiter)\n      ){\n\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push( [] );\n      }\n\n      // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n      if (arrMatches[ 2 ]){\n\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        const strMatchedValue = arrMatches[ 2 ].replace(\n          new RegExp( \"\\\"\\\"\", \"g\" ),\n          \"\\\"\"\n        );\n\n      } else {\n        // We found a non-quoted value.\n        const strMatchedValue = arrMatches[ 3 ];\n      }\n\n      // Now that we have our value string, let's add\n      // it to the data array.\n      let finalValue = strMatchedValue;\n      const floatVal = parseFloat(strMatchedValue);\n      if (!isNaN(floatVal)) {\n        finalValue = floatVal;\n      }\n      arrData[ arrData.length - 1 ].push( finalValue );\n    }\n    // Return the parsed data.\n    return( arrData );\n  };\n\n  /**\n   * Get the total score for the workgroup\n   * @returns the total score for the workgroup\n   */\n  getTotalScore() {\n    const annotations = this.studentData.annotations;\n    const workgroupId = this.ConfigService.getWorkgroupId();\n    return this.AnnotationService.getTotalScore(annotations, workgroupId);\n  }\n\n  /**\n   * Get the project completion for the signed in student\n   * @returns the project completion percentage for the signed in student\n   */\n  getProjectCompletion() {\n    // group0 is always the root node of the whole project\n    const nodeId = 'group0';\n\n    // get the progress including all of the children nodes\n    const progress = this.getNodeProgressById(nodeId);\n\n    return progress;\n  }\n\n  /**\n   * Get the run status\n   */\n  getRunStatus() {\n    return this.runStatus;\n  }\n\n  /**\n   * Get the next available planning node instance node id\n   * @returns the next available planning node instance node id\n   */\n  getNextAvailablePlanningNodeId() {\n    // used to keep track of the highest planning node number we have found, which is 1-based\n    let currentMaxPlanningNodeNumber = 1;\n\n    let nodeStates = this.getNodeStates();\n    if (nodeStates != null) {\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          let nodeStateNodeId = nodeState.nodeId;\n          if (this.ProjectService.isPlanning(nodeStateNodeId) && nodeState.studentData != null) {\n            let nodes = nodeState.studentData.nodes;\n            for (let node of nodes) {\n              let nodeId = node.id;\n              // regex to match the planning node id e.g. planningNode2\n              let planningNodeIdRegEx = /planningNode(.*)/;\n\n              // run the regex on the node id\n              let result = nodeId.match(planningNodeIdRegEx);\n\n              if (result != null) {\n                // we have found a planning node instance node id\n\n                /*\n                 * get the number part of the planning node instance node id\n                 * e.g. if the nodeId is planningNode2, the number part\n                 * would be 2\n                 */\n                let planningNodeNumber = parseInt(result[1]);\n\n                if (planningNodeNumber > currentMaxPlanningNodeNumber) {\n                  /*\n                   * update the max number part if we have found a new\n                   * higher number\n                   */\n                  currentMaxPlanningNodeNumber = planningNodeNumber;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (this.maxPlanningNodeNumber < currentMaxPlanningNodeNumber) {\n      // Update maxPlanningNodeNumber if we find a bigger number in the NodeStates\n      this.maxPlanningNodeNumber = currentMaxPlanningNodeNumber;\n    }\n\n    // Increment maxPlanningNodeNumber each time this function is called.\n    this.maxPlanningNodeNumber++;\n\n    // return the next available planning node instance node id\n    return 'planningNode' + this.maxPlanningNodeNumber;\n  }\n\n  /**\n   * Get the annotations\n   * @returns the annotations\n   */\n  getAnnotations() {\n    if (this.studentData != null && this.studentData.annotations != null) {\n      return this.studentData.annotations;\n    }\n    return null;\n  }\n\n  /**\n   * Get the latest component states for a node\n   * @param nodeId get the component states for the node\n   * @return an array containing the work for the node\n   */\n  getLatestComponentStatesByNodeId(nodeId) {\n    const latestComponentStates = [];\n    if (nodeId) {\n      const studentData = this.studentData;\n      if (studentData) {\n        const node = this.ProjectService.getNodeById(nodeId);\n        if (node != null) {\n          const components = node.components;\n          if (components != null) {\n            for (let component of components) {\n              if (component != null) {\n                const componentId = component.id;\n                let componentState =\n                    this.getLatestComponentStateByNodeIdAndComponentId(nodeId, componentId);\n                if (componentState == null) {\n                  /*\n                   * there is no component state for the component so we will\n                   * create an object that just contains the node id and\n                   * component id\n                   */\n                  componentState = {};\n                  componentState.nodeId = nodeId;\n                  componentState.componentId = componentId;\n                }\n                latestComponentStates.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n    return latestComponentStates;\n  }\n\n  /**\n   * Get the latest component state for a node\n   * @param nodeId get the latest component state for the node\n   * @return the latest component state for the node\n   */\n  getLatestComponentStateByNodeId(nodeId) {\n    if (nodeId != null) {\n      const studentData = this.studentData;\n      if (studentData) {\n        const componentStates = this.getComponentStatesByNodeId(nodeId);\n        return componentStates[componentStates.length - 1];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if the completion criteria is satisfied\n   * @param completionCriteria the completion criteria\n   * @return whether the completion criteria was satisfied\n   */\n  isCompletionCriteriaSatisfied(completionCriteria) {\n    let result = true;\n    if (completionCriteria != null) {\n      if (completionCriteria.inOrder) {\n        // the criteria need to be satisfied in order\n\n        let tempTimestamp = 0;\n        const criteria = completionCriteria.criteria;\n        for (let completionCriterion of criteria) {\n          let tempResult = true;\n          if (completionCriterion != null) {\n            // get the function name e.g. 'isVisited', 'isSaved', 'isSubmitted'\n            const functionName = completionCriterion.name;\n\n            if (functionName == 'isSubmitted') {\n              const nodeId = completionCriterion.nodeId;\n              const componentId = completionCriterion.componentId;\n\n              // get the first submit component state after the timestamp\n              const tempComponentState = this.getComponentStateSubmittedAfter(nodeId, componentId, tempTimestamp);\n\n              if (tempComponentState == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempComponentState.serverSaveTime;\n              }\n            } else if (functionName == 'isSaved') {\n              const nodeId = completionCriterion.nodeId;\n              const componentId = completionCriterion.componentId;\n\n              // get the first save component state after the timestamp\n              const tempComponentState = this.getComponentStateSavedAfter(nodeId, componentId, tempTimestamp);\n\n              if (tempComponentState == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempComponentState.serverSaveTime;\n              }\n            } else if (functionName == 'isVisited') {\n              const nodeId = completionCriterion.nodeId;\n\n              // get the first visit event after the timestamp\n              const tempEvent = this.getVisitEventAfter(nodeId, tempTimestamp);\n\n              if (tempEvent == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempEvent.serverSaveTime;\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the first save component state after the given timestamp\n   * @param nodeId the node id of the component state\n   * @param componentId the component id of the component state\n   * @param timestamp look for a save component state after this timestamp\n   */\n  getComponentStateSavedAfter(nodeId, componentId, timestamp) {\n    const componentStates = this.studentData.componentStates;\n    if (componentStates != null) {\n      for (let tempComponentState of componentStates) {\n        if (tempComponentState != null &&\n            tempComponentState.serverSaveTime > timestamp &&\n            tempComponentState.nodeId === nodeId &&\n            tempComponentState.componentId === componentId) {\n          return tempComponentState;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the first submit component state after the given timestamp\n   * @param nodeId the node id of the component state\n   * @param componentId the component id of the component state\n   * @param timestamp look for a submit component state after this timestamp\n   */\n  getComponentStateSubmittedAfter(nodeId, componentId, timestamp) {\n    const componentStates = this.studentData.componentStates;\n    if (componentStates != null) {\n      for (let tempComponentState of componentStates) {\n        if (tempComponentState != null &&\n            tempComponentState.serverSaveTime > timestamp &&\n            tempComponentState.nodeId === nodeId &&\n            tempComponentState.componentId === componentId &&\n            tempComponentState.isSubmit) {\n          return tempComponentState;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the first visit event after the timestamp\n   */\n  getVisitEventAfter(nodeId, timestamp) {\n    const events = this.studentData.events;\n    if (events != null) {\n      for (let tempEvent of events) {\n        if (tempEvent != null &&\n            tempEvent.serverSaveTime > timestamp &&\n            tempEvent.nodeId === nodeId &&\n            tempEvent.event === 'nodeEntered') {\n          return tempEvent;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get classmate student work\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param showClassmateWorkSource Where to get the work from.\n   * 'period' will get the classmate work only from the period the student is in.\n   * null will get work from the whole class (all periods).\n   *\n   * @return a promise that will return the component states from classmates\n   */\n  getClassmateStudentWork(nodeId, componentId, showClassmateWorkSource) {\n    const studentDataURL = this.ConfigService.getConfigParam('studentDataURL');\n    const httpParams = {};\n    httpParams.method = 'GET';\n    httpParams.url = studentDataURL;\n\n    const params = {};\n    params.runId = this.ConfigService.getRunId();\n    params.nodeId = nodeId;\n    params.componentId = componentId;\n    params.getStudentWork = true;\n    params.getEvents = false;\n    params.getAnnotations = false;\n    params.onlyGetLatest = true;\n\n    if (showClassmateWorkSource == 'period') {\n      params.periodId = this.ConfigService.getPeriodId();\n    }\n\n    httpParams.params = params;\n\n    return this.$http(httpParams).then((result) => {\n      const resultData = result.data;\n      if (resultData != null) {\n        return resultData.studentWorkList;\n      }\n      return [];\n    });\n  }\n\n  /**\n   * Get the max possible score for the project\n   * @returns the sum of the max scores for all the nodes in the project visible\n   * to the current workgroup or null if none of the visible components has max scores.\n   */\n  getMaxScore() {\n    let maxScore = null;\n    for (let p in this.nodeStatuses) {\n      if (this.nodeStatuses.hasOwnProperty(p)) {\n        let nodeStatus = this.nodeStatuses[p];\n        let nodeId = nodeStatus.nodeId;\n\n        if (nodeStatus.isVisible && !this.ProjectService.isGroupNode(nodeId)) {\n          // node is visible and is not a group\n          // get node max score\n          let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\n\n          if (nodeMaxScore) {\n            // there is a max score for the node, so add to total\n            // TODO geoffreykwan: trying to add to null?\n            maxScore += nodeMaxScore;\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n}\n\nStudentDataService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'AnnotationService',\n  'ConfigService',\n  'ProjectService',\n  'UtilService'\n];\n\nexport default StudentDataService;\n"]}