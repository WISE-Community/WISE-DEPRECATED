{"version":3,"sources":["projectService.es6"],"names":[],"mappings":"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","file":"projectService.js","sourcesContent":["'use strict';\n\nclass ProjectService {\n\n    constructor($http, $injector, $rootScope, ConfigService) {\n        this.$http = $http;\n        this.$injector = $injector;\n        this.$rootScope = $rootScope;\n        this.ConfigService = ConfigService;\n        this.project = null;\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.metadata = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n\n        // filtering options for navigation displays\n        this.filters = [\n            {'name': 'all', 'label': 'All'},\n            //{'name': 'todo', 'label': 'Todo'},\n            //{'name': 'completed', 'label': 'Completed'},\n            {'name': 'bookmark', 'label': 'Bookmarks'} // TODO: Add when bookmarks are active\n        ];\n    };\n\n    setProject(project) {\n        this.project = project;\n        this.parseProject();\n    };\n\n    /**\n     * Initialize the data structures used to hold project information\n     */\n    clearProjectFields() {\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.metadata = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n    };\n\n    getStyle() {\n        var style = '';\n        var project = this.project;\n        if (project != null) {\n            style = project.style;\n        }\n        return style;\n    };\n\n    getFilters() {\n        return this.filters;\n    };\n\n    /**\n     * Returns the name/title of the current project\n     */\n    getProjectTitle() {\n        var name = this.getProjectMetadata().title;\n        return name ? name : 'A WISE Project (No name)';\n    };\n    \n    /**\n     * Set the project title\n     */\n    setProjectTitle(projectTitle) {\n        var metadata = this.getProjectMetadata();\n        \n        if (metadata != null) {\n            metadata.title = projectTitle;\n        }\n    }\n\n    getProjectMetadata() {\n        return this.metadata ? this.metadata : {};\n    };\n\n    getNodes() {\n        var nodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            nodes = project.nodes;\n        }\n\n        return nodes;\n    };\n\n    getPlanningNodes() {\n        var planningNodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            planningNodes = project.planningNodes;\n        }\n\n        return planningNodes;\n    };\n\n    getChildNodeIdsById(nodeId) {\n        var childIds = [];\n        var node = this.getNodeById(nodeId);\n\n        if (node.ids) {\n            childIds = node.ids;\n        }\n\n        return childIds;\n    };\n\n    getGroupNodes() {\n        return this.groupNodes;\n    };\n\n    isNode(id) {\n        var result = false;\n        var nodes = this.getNodes();\n\n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n\n                    if (nodeId === id) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    // adds or update transition if exists\n    addTransition(transition) {\n\n        var existingTransitions = this.getTransitions();\n        var replaced = false;\n        for (var t = 0; t < existingTransitions.length; t++) {\n            var existingTransition = existingTransitions[t];\n            if (existingTransition.id === transition.id) {\n                existingTransitions.splice(t, 1, transition);\n                replaced = true;\n            }\n        }\n        if (!replaced) {\n            existingTransitions.push(transition);\n        }\n    };\n\n    addNode(node) {\n        var existingNodes = this.project.nodes;\n\n        var replaced = false;\n        if (node != null && existingNodes != null) {\n            for (var n = 0; n < existingNodes.length; n++) {\n                var existingNode = existingNodes[n];\n                var existingNodeId = existingNode.id;\n                if (existingNodeId === node.id) {\n                    existingNodes.splice(n, 1, node);\n                    replaced = true;\n                }\n            }\n        }\n        if (!replaced) {\n            existingNodes.push(node);\n        }\n    };\n\n    addApplicationNode(node) {\n\n        var applicationNodes = this.applicationNodes;\n\n        if (node != null && applicationNodes != null) {\n            applicationNodes.push(node);\n        }\n    };\n\n    addGroupNode(node) {\n\n        var groupNodes = this.groupNodes;\n\n        if (node != null && groupNodes != null) {\n            groupNodes.push(node);\n        }\n\n        this.$rootScope.$broadcast('groupsChanged');\n    };\n\n    addNodeToGroupNode(groupId, nodeId) {\n        if (groupId != null && nodeId != null) {\n            var group = this.getNodeById(groupId);\n            if (group != null) {\n                var groupChildNodeIds = group.ids;\n                if (groupChildNodeIds != null) {\n                    if (groupChildNodeIds.indexOf(nodeId) === -1) {\n                        groupChildNodeIds.push(nodeId);\n                    }\n                }\n            }\n        }\n    };\n\n    isGroupNode(id) {\n        var result = false;\n\n        var groupNode = this.getNodeById(id);\n\n        if (groupNode != null) {\n            var type = groupNode.type;\n\n            if (type === 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isApplicationNode(id) {\n        var result = false;\n\n        var applicationNode = this.getNodeById(id);\n\n        if (applicationNode != null) {\n            var type = applicationNode.type;\n\n            if (type !== 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getGroups() {\n        return this.groupNodes;\n    };\n\n    loadNodes(nodes) {\n        if (nodes != null) {\n            for (var n = 0 ; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n                    var nodeType = node.type;\n                    var content = node.content;\n                    var constraints = node.constraints;\n\n                    if (content != null) {\n                        //node.content = this.injectAssetPaths(content);\n                    }\n\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n\n                    this.addNode(node);\n\n                    if (nodeType === 'group') {\n                        this.addGroupNode(node);\n                    } else {\n                        this.addApplicationNode(node);\n                    }\n\n                    var groupId = node.groupId;\n\n                    if (groupId != null) {\n                        this.addNodeToGroupNode(groupId, nodeId);\n                    }\n\n                    if (constraints != null) {\n                        for (var c = 0; c < constraints.length; c++) {\n                            var constraint = constraints[c];\n\n                            this.activeConstraints.push(constraint);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Load the planning template nodes\n     * @param planning template nodes\n     */\n    loadPlanningNodes(planningNodes) {\n        if (planningNodes != null) {\n\n            // loop through all the planning template nodes\n            for (var p = 0; p < planningNodes.length; p++) {\n                var planningNode = planningNodes[p];\n\n                if (planningNode != null) {\n                    var nodeId = planningNode.id;\n\n                    this.setIdToNode(nodeId, planningNode);\n                    this.setIdToElement(nodeId, planningNode);\n\n                    // TODO: may need to add more function calls here to add the planning\n                }\n            }\n        }\n    }\n\n    parseProject() {\n        var project = this.project;\n        if (project != null) {\n\n            // clear and initialize our project data structures\n            this.clearProjectFields();\n\n            if (project.metadata) {\n                this.metadata = project.metadata;\n            }\n\n            var nodes = project.nodes;\n            this.loadNodes(nodes);\n\n            // load the planning node templates\n            var planningNodes = project.planningNodes;\n            this.loadPlanningNodes(planningNodes);\n\n            // load the inactive nodes\n            var inactiveNodes = project.inactiveNodes;\n            this.loadInactiveNodes(inactiveNodes);\n\n            var constraints = project.constraints;\n\n            if (constraints != null) {\n                for (var c = 0; c < constraints.length; c++) {\n                    var constraint = constraints[c];\n\n                    if (constraint != null) {\n                        var constraintId = constraint.id;\n                        constraint.active = true;\n\n                        this.setIdToElement(constraintId, constraint);\n                    }\n                }\n            }\n\n            // set root node\n            this.rootNode = this.getRootNode(nodes[0].id);\n\n            // set project order\n            this.setNodeOrder(this.rootNode, this.nodeCount);\n            //this.nodeCount = 0;\n\n            var n = nodes.length;\n            var branches = this.getBranches();\n            var branchNodeIds = [];\n\n            // set node positions\n            var id, pos;\n\n            while (n--) {\n                id = nodes[n].id;\n                if (id === this.rootNode.id) {\n                    this.setIdToPosition(id, '0');\n                } else if (this.isNodeIdInABranch(branches, id)) {\n                    // node is in a branch, so process later\n                    branchNodeIds.push(id);\n                } else {\n                    pos = this.getPositionById(id);\n                    this.setIdToPosition(id, pos);\n                }\n            }\n\n            // set branch node positions\n            var b = branchNodeIds.length;\n            while (b--) {\n                id = branchNodeIds[b];\n                pos = this.getBranchNodePositionById(id);\n                this.setIdToPosition(id, pos);\n            }\n        }\n    };\n\n    setNodeOrder(node) {\n        this.idToOrder[node.id] = {'order': this.nodeCount};\n        this.nodeCount++;\n        if (this.isGroupNode(node.id)) {\n            var childIds = node.ids;\n            for (var i = 0; i < childIds.length; i++) {\n                var child = this.getNodeById(childIds[i]);\n                this.setNodeOrder(child);\n            }\n        }\n    };\n\n    /**\n     * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getPositionById(id) {\n        for (var i = 0; i < this.rootNode.ids.length; i++) {\n            var node = this.getNodeById(this.rootNode.ids[i]);\n            var path = this.getPathToNode(node, i+1, id);\n            if (path != undefined && path != null) {\n                return path;\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Returns the order of the given node id in the project. Returns null if no node with id exists.\n     * @param id String node id\n     * @return Number order of the given node id in the project\n     */\n    getOrderById(id) {\n        if (this.idToOrder[id]) {\n            return this.idToOrder[id].order;\n        }\n\n        return null;\n    };\n    /**\n     * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n     * @param order Number\n     * @return Number node id of the given order in the project\n     */\n    getIdByOrder(order) {\n        var nodeId = null;\n\n        for (var id in this.idToOrder) {\n            if (this.idToOrder[id].order === order) {\n                if (this.isGroupNode(id) && order > 1) {\n                    nodeId = this.getIdByOrder(order-1);\n                } else {\n                    nodeId = id;\n                }\n                break;\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getBranchNodePositionById(id) {\n        var branches = this.getBranches();\n        var b = branches.length;\n\n        // TODO: should we localize this? should we support more than 26?\n        var integerToAlpha = function(int) {\n            var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n            if (int > -1 && int < 26) {\n                return alphabet[int];\n            } else {\n                return int;\n            }\n        };\n\n        while (b--) {\n            var branch = branches[b];\n            var branchPaths = branch.branchPaths;\n            for (var p = 0; p < branchPaths.length; p++) {\n                var branchPath = branchPaths[p];\n                var nodeIndex = branchPath.indexOf(id);\n                if (nodeIndex > -1) {\n                    var startPoint = branch.branchStartPoint;\n                    var startPointPos = this.idToPosition[startPoint];\n                    var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n                    return branchPathPos + (nodeIndex+1);\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n     * @param node a node to start searching down\n     * @param path the position of the given node\n     * @param id the node id to search for\n     * @return string path of the given node id in the project\n     */\n    getPathToNode(node, path, id) {\n        if (node.id === id) {\n            return path + '';\n        } else if (node.type === 'group') {\n            var num = 0;\n            var branches = this.getBranches();\n            for (var i = 0; i < node.ids.length; i++) {\n                var nodeId = node.ids[i];\n                if (this.isNodeIdInABranch(branches, nodeId)) {\n                    this.getBranchNodePositionById(nodeId);\n                } else {\n                    ++num;\n                    var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n                    if (pos) {\n                        return pos;\n                    }\n                }\n            }\n        }\n    };\n\n    setIdToPosition(id, pos) {\n        if (id != null) {\n            this.idToPosition[id] = pos;\n        }\n    };\n\n    getNodePositionById(id) {\n        if (id != null) {\n            return this.idToPosition[id];\n        }\n    };\n\n    setIdToNode(id, element) {\n        if (id != null) {\n            this.idToNode[id] = element;\n        }\n    };\n\n    setIdToElement(id, element) {\n        if (id != null) {\n            this.idToElement[id] = element;\n        }\n    };\n\n    /**\n     * Replace relative asset paths with absolute paths\n     * e.g.\n     * assets/myimage.jpg\n     * will be replaced with\n     * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n     * @param content a string or JSON object\n     * @return the same type of object that was passed in as the content\n     * but with relative asset paths replaced with absolute paths\n     */\n    injectAssetPaths(content) {\n\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.replaceAssetPaths(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.replaceAssetPaths(content);\n            }\n        }\n\n        return content;\n    };\n\n    /**\n     * Replace the relative asset paths with absolute paths\n     * @param contentString the content string\n     * @return the content string with relative asset paths replaced\n     * with absolute asset paths\n     */\n    replaceAssetPaths(contentString) {\n\n        if (contentString != null) {\n\n            // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n            var contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n            // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n            // the string we're looking for can't start with '/ and \"/.\n            // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n            contentString = contentString.replace(\n                new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html|js)(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\n                (matchedString) => {\n                    // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n                    var delimiter = '';\n                    var matchedStringWithoutQuotes = '';\n\n                    if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\n                        // the string has escaped quotes for example \\\"hello.png\\\"\n\n                        // get everything between the escaped quotes\n                        matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\n\n                        // get the delimiter which will be \\' or \\\"\n                        delimiter = matchedString.substr(0,2);\n                    } else {\n                        // the string does not have escaped qoutes for example \"hello.png\"\n\n                        // get everything between the quotes\n                        matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\n\n                        // get the delimiter which will be ' or \"\n                        delimiter = matchedString.substr(0,1);\n                    }\n\n                    //var matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\n                    // make a new string with the contentBaseURL + assets/ prepended to the path\n                    return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\n                }\n            );\n        }\n\n        return contentString;\n    };\n    \n    /**\n     * Inject the ng-click attribute that will call the snipImage function\n     * @param content the content\n     * @returns the modified content\n     */\n    injectClickToSnipImage(content) {\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.injectClickToSnipImageIntoContentString(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.injectClickToSnipImageIntoContentString(content);\n            }\n        }\n\n        return content;\n    }\n    \n    /**\n     * Inject the ng-click attribute that will call the snipImage function\n     * @param contentString the content in string format\n     * @returns the modified content string\n     */\n    injectClickToSnipImageIntoContentString(contentString) {\n        \n        if (contentString != null) {\n            \n            // regex to match image elements\n            var imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\n            \n            // replace all instances that match\n            contentString = contentString.replace(imgMatcher,\n                (matchedString, matchGroup1) => {\n                    \n                    /*\n                     * insert the ng-click attribute\n                     * Before: <img src=\"abc.png\"/>\n                     * After: <img ng-click=\"vleController.snipImage($event)\"/>\n                     */\n                    var newString = matchedString.replace('img', 'img ng-click=\\\\\\\"vleController.snipImage($event)\\\\\\\"');\n                    \n                    return newString;\n                }\n            );\n        }\n        \n        return contentString;\n    }\n\n    /**\n     * Returns the node specified by the nodeId\n     * Return null if nodeId param is null or the specified node does not exist in the project.\n     */\n    getNodeById(nodeId) {\n        var element = null;\n\n        if (nodeId != null && this.idToNode[nodeId]) {\n            element = this.idToNode[nodeId];\n        }\n\n        return element;\n    };\n\n    /**\n     * Returns the title of the node with the nodeId\n     * Return null if nodeId param is null or the specified node does not exist in the project.\n     */\n    getNodeTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            title = node.title;\n        }\n\n        return title;\n    };\n\n    /**\n     * Get the node position and title\n     * @param nodeId the node id\n     * @returns the node position and title, e.g. \"1.1 Introduction\"\n     */\n    getNodePositionAndTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n\n            var position = this.getNodePositionById(nodeId);\n\n            if (position != null) {\n                title = position + ': ' + node.title;\n            } else {\n                title = node.title;\n            }\n        }\n\n        return title;\n    };\n\n    getNodeIconByNodeId(nodeId) {\n        var node = this.getNodeById(nodeId);\n        var nodeIcon = null;\n\n        if (node != null) {\n            var nodeType = node.type;\n\n            // set defaults (TODO: get from configService?)\n            var defaultName = (nodeType === 'group') ? 'explore' : 'school';\n            nodeIcon = {\n                color: 'rgba(0,0,0,0.54)',\n                type: 'font',\n                fontSet: 'material-icons',\n                fontName: defaultName,\n                imgSrc: '',\n                imgAlt: 'node icon'\n            };\n\n            // TODO: check for different statuses\n            var icons = node.icons;\n            if (!!icons && !!icons.default) {\n                var icon = icons.default;\n                nodeIcon = $.extend(true, nodeIcon, icon);\n            }\n\n            // check for empty image source\n            if (!nodeIcon.imgSrc) {\n                // revert to font icon\n                nodeIcon.type = 'font';\n            }\n        }\n\n        return nodeIcon;\n    };\n\n    getParentGroup(nodeId) {\n        var result = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var groupNodes = this.getGroupNodes();\n\n                for (var g = 0; g < groupNodes.length; g++) {\n                    var groupNode = groupNodes[g];\n\n                    if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n                        result = groupNode;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the parent group id\n     * @param nodeId the parent group id\n     * @returns the parent group id\n     */\n    getParentGroupId(nodeId) {\n\n        var parentGroupId = null;\n\n        if (nodeId != null) {\n            var parentGroup = this.getParentGroup(nodeId);\n\n            if (parentGroup != null) {\n                parentGroupId = parentGroup.id;\n            }\n        }\n\n        return parentGroupId;\n    }\n\n    getNodeDepth(nodeId, val) {\n        var result = null;\n\n        if (nodeId != null) {\n            var depth = (typeof val === \"number\") ? val : 0;\n            var parent = this.getParentGroup(nodeId);\n            if (parent) {\n                depth = this.getNodeDepth(parent.id, depth + 1);\n            }\n            result = depth;\n        }\n\n        return result;\n    };\n\n    getRootNode(nodeId) {\n        var result = null;\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        if (parentGroup == null) {\n            result = this.getNodeById(nodeId);\n        } else {\n            result = this.getRootNode(parentGroup.id);\n        }\n\n        return result;\n    };\n\n    isNodeDirectChildOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var nodeId = node.id;\n            var groupIds = group.ids;\n\n            if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isNodeDescendentOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var descendents = this.getDescendentsOfGroup(group);\n            var nodeId = node.id;\n\n            if (descendents.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getDescendentsOfGroup(group) {\n        var descendents = [];\n\n        if (group != null) {\n            var childIds = group.ids;\n\n            if (childIds != null) {\n                descendents = childIds;\n\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n\n                    var node = this.getNodeById(childId);\n\n                    if (node != null) {\n                        var childDescendents = this.getDescendentsOfGroup(node);\n\n                        descendents = descendents.concat(childDescendents);\n                    }\n                }\n            }\n        }\n\n        return descendents;\n    };\n\n    isStartNode(node) {\n        var result = false;\n\n        if (node != null) {\n            var nodeId = node.id;\n\n            var projectStartId = this.getStartNodeId();\n\n            if (nodeId === projectStartId) {\n                result = true;\n            }\n\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    var groupStartId = group.startId;\n\n                    if (nodeId === groupStartId) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns the Project's start node id, or null if it's not defined in the project\n     */\n    getStartNodeId() {\n        var startNodeId = null;\n        var project = this.project;\n        if (project != null) {\n            startNodeId = project.startNodeId;\n        }\n        return startNodeId;\n    };\n\n    /**\n     * Set the start node id\n     * @param nodeId the new start node id\n     */\n    setStartNodeId(nodeId) {\n\n        if (nodeId != null) {\n            var project = this.project;\n            if (project != null) {\n                project.startNodeId = nodeId;\n            }\n        }\n    }\n\n    /**\n     * Get the start group id\n     * @return the start group id\n     */\n    getStartGroupId() {\n        var startGroupId = null;\n\n        var project = this.project;\n        if (project != null) {\n            startGroupId = project.startGroupId;\n        }\n\n        return startGroupId;\n    }\n\n    /**\n     * Check if the given node id is the start node id\n     * @return whether the node id is the start node id\n     */\n    isStartNodeId(nodeId) {\n\n        var result = false;\n\n        var project = this.project;\n\n        if (project != null) {\n            var startNodeId = project.startNodeId;\n\n            if (nodeId === startNodeId) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    getConstraintsForNode(node) {\n        var constraints = [];\n\n        var allConstraints = this.activeConstraints;\n\n        for (var c = 0; c < allConstraints.length; c++) {\n            var constraint = allConstraints[c];\n\n            if (this.isNodeAffectedByConstraint(node, constraint)) {\n                constraints.push(constraint);\n            }\n        }\n\n        return constraints;\n    };\n\n    /**\n     * Check if a node is affected by the constraint\n     * @param node check if the node is affected\n     * @param constraint the constraint that might affect the node\n     * @returns whether the node is affected by the constraint\n     */\n    isNodeAffectedByConstraint(node, constraint) {\n        var result = false;\n\n        if (node != null && constraint != null) {\n            var nodeId = node.id;\n            var targetId = constraint.targetId;\n            var action = constraint.action;\n\n            if (action === 'makeAllNodesAfterThisNotVisible') {\n                if (this.isNodeIdAfter(targetId, node.id)) {\n                    result = true;\n                }\n            } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n                if (this.isNodeIdAfter(targetId, node.id)) {\n                    result = true;\n                }\n            } else {\n                var targetNode = this.getNodeById(targetId);\n\n                if (targetNode != null) {\n                    var nodeType = targetNode.type;\n\n                    if (nodeType === 'node') {\n                        // the target is an application\n\n                        if (nodeId === targetId) {\n                            result = true;\n                        }\n                    } else if (nodeType === 'group') {\n                        // the target is a group\n\n                        if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id comes after another node id in the project\n     * @param nodeIdBefore the node id before\n     * @param nodeIdAfter the node id after\n     */\n    isNodeIdAfter(nodeIdBefore, nodeIdAfter) {\n        var result = false;\n\n        if (nodeIdBefore != null && nodeIdAfter != null) {\n\n            if (this.isApplicationNode(nodeIdBefore)) {\n                // the node id before is a step\n\n                // get all the paths from the beforeNodeId to the end of the project\n                var pathsToEnd = this.getAllPaths([], nodeIdBefore, true);\n\n                if (pathsToEnd != null) {\n\n                    // loop through all the paths\n                    for (var p = 0; p < pathsToEnd.length; p++) {\n\n                        var pathToEnd = pathsToEnd[p];\n\n                        if (pathToEnd != null) {\n\n                            /*\n                             * remove the first node id and its parent id because\n                             * we will check the remaining node ids in the array\n                             * for the nodeIdAfter\n                             */\n\n                            // get the index of the node id before\n                            var index = pathToEnd.indexOf(nodeIdBefore);\n\n                            if (index != -1) {\n                                // remove the node id before\n                                pathToEnd.splice(index, 1);\n                            }\n\n                            // get the parent group of the node id before\n                            var parentGroup = this.getParentGroup(nodeIdBefore);\n\n                            if (parentGroup != null) {\n                                // remove the parent group of the node id before\n                                var parentGroupId = parentGroup.id;\n                                var parentGroupIndex = pathToEnd.indexOf(parentGroupId);\n                                if (parentGroupIndex != -1) {\n                                    pathToEnd.splice(parentGroupIndex, 1);\n                                }\n                            }\n\n                            if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                                // we have found the nodeIdAfter in the path to the end of the project\n                                result = true;\n                            }\n                        }\n                    }\n                }\n            } else {\n                // the node id before is an activity\n\n                // get the group\n                var group = this.getNodeById(nodeIdBefore);\n\n                if (group != null) {\n\n                    // get the transitions from the group\n                    var transitions = this.getTransitionsByFromNodeId(nodeIdBefore);\n\n                    if (transitions != null) {\n\n                        // loop through all the transitions\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                // get the paths between to toNodeId and the end of the project\n                                var pathsToEnd = this.getAllPaths([], toNodeId, true);\n\n                                // loop through all the paths\n                                for (var p = 0; p < pathsToEnd.length; p++) {\n\n                                    // get a path\n                                    var pathToEnd = pathsToEnd[p];\n\n                                    if (pathToEnd != null) {\n                                        if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                                            // we have found the nodeIdAfter in the path to the end of the project\n                                            result = true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    getNavigationMode() {\n        var navigationMode = null;\n        var project = this.project;\n        if (project != null) {\n            navigationMode = project.navigationMode;\n        }\n        return navigationMode;\n    };\n\n    getTransitions() {\n        var transitions = null;\n        var project = this.project;\n        if (project != null) {\n            transitions = project.transitions;\n        }\n        return transitions;\n    };\n\n    /**\n     * Returns all possible transition criteria for the specified node and component.\n     */\n    getPossibleTransitionCriteria(nodeId, componentId) {\n        let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n        if (component != null) {\n            let componentType = component.type;\n            let componentService = this.$injector.get(componentType + 'Service');\n            if (componentService.getPossibleTransitionCriteria) {\n                return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\n            } else {\n                return [];\n            }\n        } else {\n            return [];\n        }\n    };\n\n    /**\n     * Get the transition logic for a node\n     * @param fromNodeId the from node id\n     * @returns the transition logic object\n     */\n    getTransitionLogicByFromNodeId(fromNodeId) {\n        var transitionLogic = null;\n\n        if (fromNodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                // get the transition logic\n                transitionLogic = node.transitionLogic;\n            }\n        }\n\n        return transitionLogic;\n    };\n\n    /**\n     * Get the transitions for a node\n     * @param fromNodeId the node to get transitions from\n     * @returns an array of transitions\n     */\n    getTransitionsByFromNodeId(fromNodeId) {\n\n        var transitions = null;\n\n        if (fromNodeId != null) {\n            // get the transition logic\n            var transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\n\n            if (transitionLogic != null) {\n                // get the transitions\n                transitions = transitionLogic.transitions;\n            }\n        }\n\n        return transitions;\n    }\n\n    /**\n     * Get nodes that have a transition to the given node id\n     * @param toNodeId the node id\n     * @returns an array of node objects that transition to the\n     * given node id\n     */\n    getNodesByToNodeId(toNodeId) {\n        var nodesByToNodeId = [];\n\n        if (toNodeId != null) {\n\n            // get all the nodes\n            var nodes = this.project.nodes;\n\n            // loop through all the nodes\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        // loop through all the transitions for the node\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                if (toNodeId === transition.to) {\n                                    // this node has a transition to the node id\n                                    nodesByToNodeId.push(node);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return nodesByToNodeId;\n    };\n\n    /**\n     * Get node ids of all the nodes that have a to transition to the given node id\n     * @param toNodeId\n     * @returns all the node ids that have a transition to the given node id\n     */\n    getNodeIdsByToNodeId(toNodeId) {\n        var nodeIds = [];\n\n        // get all the nodes that transition to the toNodeId\n        var nodes = this.getNodesByToNodeId(toNodeId);\n\n        if (nodes != null) {\n\n            // loop through all the nodes to get the node ids\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    nodeIds.push(node.id);\n                }\n            }\n        }\n\n        return nodeIds;\n    }\n\n    /**\n     * Get the group nodes that point to a given node id\n     * @param toNodeId\n     */\n    getGroupNodesByToNodeId(toNodeId) {\n        var groupsThatPointToNodeId = [];\n\n        if (toNodeId != null) {\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    if (this.hasTransitionTo(group, toNodeId)) {\n                        groupsThatPointToNodeId.push(group);\n                    }\n                }\n            }\n        }\n\n        return groupsThatPointToNodeId;\n    }\n\n    /**\n     * Check if a node has a transition to a node id\n     * @param node check if this node has a transition to the node id\n     * @param toNodeId we will look for a transition to this node id\n     * @returns whether the node has a transition to the node id\n     */\n    hasTransitionTo(node, toNodeId) {\n        var result = false;\n\n        if (node != null && toNodeId != null) {\n            var transitionLogic = node.transitionLogic;\n\n            if (transitionLogic != null) {\n                var transitions = transitionLogic.transitions;\n\n                if (transitions != null) {\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n\n                        if (toNodeId === transition.to) {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the transitions that traverse from the fromNodeId and to the toNodeId\n     * @param fromNodeId the from node id\n     * @param toNodeId the to node id\n     * @returns an array of transitions that traverse from the fromNodeId and\n     * to the toNodeId\n     */\n    getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n        var transitionsResults = [];\n\n        if (fromNodeId != null && toNodeId != null) {\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var to = transition.to;\n\n                                if (toNodeId === to) {\n                                    transitionsResults.push(transition);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    /**\n     * Retrieves the project JSON from Config.projectURL and returns it.\n     * If Config.projectURL is undefined, returns null.\n     */\n    retrieveProject() {\n        var projectURL = this.ConfigService.getConfigParam('projectURL');\n\n        if (projectURL == null) {\n            return null;\n        } else {\n            /*\n             * add a unique GET parameter value so that it always retrieves the\n             * latest version of the project file from the server and never\n             * retrieves the project from cache.\n             */\n            projectURL += '?noCache=' + (new Date()).getTime();\n        }\n\n        return this.$http.get(projectURL).then((result) => {\n            var projectJSON = result.data;\n            this.setProject(projectJSON);\n            return projectJSON;\n        });\n    };\n\n    /**\n     * Saves the project to Config.saveProjectURL and returns commit history promise.\n     * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\n     */\n    saveProject(commitMessage = \"Made changes via WISE5 Authoring Tool\") {\n\n        // perform any cleanup before saving the project\n        this.cleanupBeforeSave();\n\n        var projectId = this.ConfigService.getProjectId();\n        var saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\n        if (projectId == null || saveProjectURL == null) {\n            return null;\n        }\n\n        // Get the project from this service\n        var projectJSONString = angular.toJson(this.project, 4);\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = saveProjectURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.projectId = projectId;\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSONString;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var commitHistory = result.data;\n            return commitHistory;\n        });\n    };\n    \n    /**\n     * Perform any necessary cleanup before we save the project.\n     * For example we need to remove the checked field in the inactive node\n     * objects.\n     */\n    cleanupBeforeSave() {\n        var inactiveNodes = this.project.inactiveNodes;\n        \n        if (inactiveNodes != null) {\n            \n            // loop through all the inactive nodes\n            for (var i = 0; i < inactiveNodes.length; i++) {\n                var inactiveNode = inactiveNodes[i];\n                \n                if (inactiveNode != null) {\n                    // remove the checked field\n                    delete inactiveNode.checked;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the project with the specified id and returns a new project id if the project is\n     * successfully copied\n     */\n    copyProject(projectId) {\n        var copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\n\n        if (copyProjectURL == null) {\n            return null;\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = copyProjectURL + \"/\" + projectId;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var projectId = result.data;\n            return projectId;\n        });\n    };\n\n    /**\n     * Registers a new project having the projectJSON content with the server.\n     * Returns a new project Id if the project is successfully registered.\n     * Returns null if Config.registerNewProjectURL is undefined.\n     * Throws an error if projectJSONString is invalid JSON string\n     */\n    registerNewProject(projectJSONString, commitMessage) {\n        var registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\n\n        if (registerNewProjectURL == null) {\n            return null;\n        }\n\n        try {\n            // Try parsing the JSON string and throw an error if there's an issue parsing it.\n            JSON.parse(projectJSONString);\n        } catch (e) {\n            throw new Error(\"Invalid projectJSONString.\");\n        }\n\n        if (!commitMessage) {\n            commitMessage = \"\";\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = registerNewProjectURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSONString;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var projectId = result.data;\n            return projectId;\n        });\n    };\n\n    /**\n     * Retrieves and returns the project's commit history.\n     */\n    getCommitHistory() {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'GET'\n        }).then((result) => {\n            return result.data;\n        });\n    };\n\n    /**\n     * Returns the theme path for the current project\n     */\n    getThemePath() {\n        var wiseBaseURL = this.ConfigService.getWISEBaseURL();\n        var project = this.project;\n        if (project && project.theme) {\n            // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n            return wiseBaseURL + '/wise5/vle/themes/' + project.theme;\n        } else {\n            // TODO: get default theme name from ConfigService\n            return wiseBaseURL + '/wise5/vle/themes/default';\n        }\n    };\n\n    /**\n     * Returns the theme settings for the current project\n     */\n    getThemeSettings() {\n        let themeSettings = {};\n        let project = this.project;\n\n        if (project && project.themeSettings) {\n            if (project.theme) {\n                themeSettings = project.themeSettings[project.theme];\n            } else {\n                themeSettings = project.themeSettings[\"default\"];\n            }\n        }\n\n        return themeSettings ? themeSettings : {};\n    };\n\n    /**\n     * Flatten the project to obtain a list of node ids\n     */\n    getFlattenedProjectAsNodeIds() {\n        var nodeIds = [];\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the possible paths through the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // consolidate all the paths to create a single list of node ids\n        nodeIds = this.consolidatePaths(allPaths);\n        //nodeIds = this.consolidatePaths(allPaths.reverse());\n\n        return nodeIds;\n    };\n\n    /**\n     * Get all the possible paths through the project. This function\n     * recursively calls itself to traverse the project depth first.\n     * @param pathSoFar the node ids in the path so far. the node ids\n     * in this array are referenced to make sure we don't loop back\n     * on the path.\n     * @param nodeId the node id we want to get the paths from\n     * @param includeGroups whether to include the group node ids in the paths\n     * @return an array of paths. each path is an array of node ids.\n     */\n    getAllPaths(pathSoFar, nodeId, includeGroups) {\n        var allPaths = [];\n\n        if (nodeId != null) {\n            if (this.isApplicationNode(nodeId)) {\n                // the node is an application node\n\n                var path = [];\n\n                // get all the transitions from this node\n                var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n                if (transitions != null) {\n\n                    if (includeGroups) {\n                        // get the parent group\n                        var parentGroup = this.getParentGroup(nodeId);\n                        if (parentGroup != null) {\n\n                            // get the parent group id\n                            var parentGroupId = parentGroup.id;\n\n                            if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\n                                // add the parent group id\n                                pathSoFar.push(parentGroup.id);\n                            }\n                        }\n                    }\n\n                    /*\n                     * add the node id to the path so far so we can later check\n                     * which nodes are already in the path to prevent looping\n                     * back in the path\n                     */\n                    pathSoFar.push(nodeId);\n\n                    if (transitions.length === 0) {\n                        /*\n                         * there are no transitions from the node id so we will\n                         * look for a transition in the parent group\n                         */\n\n                        var addedCurrentNodeId = false;\n\n                        var parentGroupId = this.getParentGroupId(nodeId);\n                        var parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n                        if (parentGroupTransitions != null) {\n                            for (var p = 0; p < parentGroupTransitions.length; p++) {\n                                var parentGroupTransition = parentGroupTransitions[p];\n\n                                if (parentGroupTransition != null) {\n\n                                    var toNodeId = parentGroupTransition.to;\n\n                                    if (pathSoFar.indexOf(toNodeId) == -1) {\n                                        /*\n                                         * recursively get the paths by getting all\n                                         * the paths for the to node\n                                         */\n                                        var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n\n                                            addedCurrentNodeId = true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (!addedCurrentNodeId) {\n                            /*\n                             * if the parent group doesn't have any transitions we will\n                             * need to add the current node id to the path\n                             */\n\n                            // add the node id to the path\n                            path.push(nodeId);\n\n                            // add the path to the all paths array\n                            allPaths.push(path);\n                        }\n                    } else {\n                        // there are transitions from this node id\n\n                        // loop through all the transitions from this node id\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transitionResult = [];\n\n                            // get a transition\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                // get the to node id\n                                var toNodeId = transition.to;\n\n                                if (pathSoFar.indexOf(toNodeId) == -1) {\n                                    // we have not found the to node in the path yet so we can traverse it\n\n                                    /*\n                                     * recursively get the paths by getting all\n                                     * the paths from the to node\n                                     */\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                    if (allPathsFromToNode != null) {\n                                        // loop through all the paths from the to node\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            if (includeGroups) {\n                                                // we need to add the group id to the path\n\n                                                if (tempPath.length > 0) {\n\n                                                    // get the first node id in the path\n                                                    var firstNodeId = tempPath[0];\n\n                                                    // get the parent id of the first node\n                                                    var firstParentGroupId = this.getParentGroupId(firstNodeId);\n\n                                                    // get the parent id of the current node\n                                                    var parentGroupId = this.getParentGroupId(nodeId);\n\n                                                    if (parentGroupId != firstParentGroupId) {\n                                                        /*\n                                                         * the parent ids are different which means this is a boundary\n                                                         * between two groups. for example if the project looked like\n                                                         * group1>node1>node2>group2>node3>node4\n                                                         * and the current node was node2 then the first node in the\n                                                         * path would be node3 which means we would need to place\n                                                         * group2 on the bath before node3\n                                                         */\n                                                        tempPath.unshift(firstParentGroupId);\n                                                    }\n                                                }\n                                            }\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n                                        }\n                                    }\n                                } else {\n                                    /*\n                                     * the node is already in the path so far which means\n                                     * the transition is looping back to a previous node.\n                                     * we do not want to take this transition because\n                                     * it will lead to an infinite loop. we will just\n                                     * add the current node id to the path and not take\n                                     * the transition which essentially ends the path.\n                                     */\n                                    // add the node id to the path\n                                    path.push(nodeId);\n\n                                    // add the path to the all paths array\n                                    allPaths.push(path);\n                                }\n                            }\n                        }\n                    }\n\n                    if (pathSoFar.length > 0) {\n                        // get the last node id\n                        var lastNodeId = pathSoFar[pathSoFar.length - 1];\n\n                        // check if the last node id is a group id\n                        if (this.isGroupNode(lastNodeId)) {\n                            /*\n                             * the last node id is a group id so we will remove it\n                             * since we are moving back up the path as we traverse\n                             * the nodes depth first\n                             */\n                            pathSoFar.pop();\n                        }\n                    }\n\n                    /*\n                     * remove the latest node id (this will be a step node id)\n                     * since we are moving back up the path as we traverse the\n                     * nodes depth first\n                     */\n                    pathSoFar.pop();\n                }\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n\n                /*\n                 * add the node id to the path so far so we can later check\n                 * which nodes are already in the path to prevent looping\n                 * back in the path\n                 */\n                pathSoFar.push(nodeId);\n\n                // get the group node\n                var groupNode = this.getNodeById(nodeId);\n\n                if (groupNode != null) {\n                    var startId = groupNode.startId;\n\n                    if (startId == null || startId == \"\") {\n                        // there is no start id so we will take the transition from the group\n                        // TODO? there is no start id so we will loop through all the child nodes\n\n                        // get the transitions from the group\n                        var transitions = this.getTransitionsByFromNodeId(groupNode.id);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    // get the paths from the to node to the end of the project\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                    if (allPathsFromToNode != null) {\n                                        // loop through all the paths from the to node\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        // there is a start id so we will traverse it\n\n                        // get the paths from the start id to the end of the project\n                        var allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\n\n                        if (allPathsFromToNode != null) {\n                            // loop through all the paths from the to node\n                            for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                // get a path\n                                var tempPath = allPathsFromToNode[a];\n\n                                // prepend the current node id to the path\n                                tempPath.unshift(nodeId);\n\n                                // add the path to our collection of paths\n                                allPaths.push(tempPath);\n                            }\n                        }\n                    }\n                }\n\n                /*\n                 * remove the latest node id since we are moving back\n                 * up the path as we traverse the nodes depth first\n                 */\n                pathSoFar.pop();\n            }\n        }\n\n        return allPaths;\n    };\n\n    /**\n     * Consolidate all the paths into a linear list of node ids\n     * @param paths an array of paths. each path is an array of node ids.\n     * @return an array of node ids that have been properly ordered\n     */\n    consolidatePaths(paths) {\n        var consolidatedPath = [];\n\n        if (paths != null) {\n\n            /*\n             * continue until all the paths are empty. as we consolidate\n             * node ids, we will remove them from the paths. once all the\n             * paths are empty we will be done consolidating the paths.\n             */\n            while(!this.arePathsEmpty(paths)) {\n\n                // start with the first path\n                var currentPath = this.getNonEmptyPathIndex(paths);\n\n                // get the first node id in the current path\n                var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n\n                if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                    // the first node ids in all the paths are the same\n\n                    // remove the node id from all the paths\n                    this.removeNodeIdFromPaths(nodeId, paths);\n\n                    // add the node id to our consolidated path\n                    consolidatedPath.push(nodeId);\n                } else {\n                    // not all the top node ids are the same which means we have branched\n\n                    // get all the paths that contain the node id\n                    var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n                    if (pathsThatContainNodeId != null) {\n                        if (pathsThatContainNodeId.length === 1) {\n                            // only the current path we are on has the node id\n\n                            // remove the node id from the path\n                            this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n                            // add the node id to our consolidated path\n                            consolidatedPath.push(nodeId);\n                        } else {\n                            // there are multiple paths that have this node id\n\n                            // consume all the node ids up to the given node id\n                            var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n                            // remove the node id from the paths\n                            this.removeNodeIdFromPaths(nodeId, paths);\n\n                            // add the node id to the end of the consumed path\n                            consumedPath.push(nodeId);\n\n                            // add the consumed path to our consolidated path\n                            consolidatedPath = consolidatedPath.concat(consumedPath);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        return consolidatedPath;\n    };\n\n    /**\n     * Consume the node ids in the paths until we get to the given node id\n     * @param paths the paths to consume\n     * @param nodeId the node id to stop consuming at\n     * @return an array of node ids that we have consumed\n     */\n    consumePathsUntilNodeId(paths, nodeId) {\n        var consumedNodeIds = [];\n\n        if (paths != null && nodeId != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id to stop consuming at\n                if (path != null && path.indexOf(nodeId) != -1) {\n                    /*\n                     * the path does contain the node id to stop consuming at\n                     * so we will consume the node ids in this path until\n                     * we get to the given node id to stop consuming at\n                     */\n\n                    // loop through the node ids in the path\n                    for (var x = 0; x < path.length; x++) {\n\n                        // get a node id\n                        var tempNodeId = path[x];\n\n                        if (nodeId === tempNodeId) {\n                            /*\n                             * the node id is the same as the one we need to\n                             * stop consuming at so we will stop looking\n                             * at this path\n                             */\n                            break;\n                        } else {\n                            /*\n                             * the node id is not the one that we need to stop consuming at\n                             * so we will consume it\n                             */\n\n                            // get all the paths that contain the node id\n                            var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n                            if (pathsThatContainNodeId.length === 1) {\n                                // there is only one path with this node id\n\n                                // remove the node id from the path\n                                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            } else {\n                                // there are multiple paths with this node id\n\n                                // tempNodeId must come before nodeId\n\n                                var pathsToConsume = [];\n\n                                // loop through all the paths that contain the node id\n                                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\n\n                                    // get a path that contains the node id\n                                    var pathThatContainsNodeId = pathsThatContainNodeId[g];\n\n                                    // get the index of the node id we want to remove\n                                    var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                                    // get the index of the node id we want to stop consuming at\n                                    var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                                    /*\n                                     * check if the node id we want to remove comes before\n                                     * the node id we want to stop consuming at. we need to\n                                     * do this to prevent an infinite loop. an example of\n                                     * when this can happen is if there are two paths\n                                     *\n                                     * path1 = 1, 2, 3, 4, 5\n                                     * path2 = 1, 2, 4, 3, 5\n                                     *\n                                     * as we consume path1 we will need to consume 3. in order to\n                                     * consume 3, we must consume consume up to 3 in path2.\n                                     * in order to consume up to 3 in path2 we must consume 4.\n                                     * in order to consume 4, we must consume everything before\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                                     * this means we need to consume 3 which brings us back up\n                                     * to the top of this paragraph creating an infinite loop.\n                                     *\n                                     * this check below will prevent infinite loops by only\n                                     * adding paths that have the tempNodeId come before the\n                                     * nodeId to stop consuming at.\n                                     */\n                                    if (tempNodeIdIndex < nodeIdIndex) {\n                                        pathsToConsume.push(pathThatContainsNodeId);\n                                    }\n                                }\n\n                                /*\n                                 * take the paths that contain the given node id and consume\n                                 * the paths until the given node id\n                                 */\n                                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                                // remove the node id from the paths that contain it\n                                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                                // add the temp consumed node ids to our consumed node ids array\n                                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n\n        }\n\n        return consumedNodeIds;\n    };\n\n    /**\n     * Get the path at the given index and get the first node id in\n     * the path\n     * @param paths an array of paths. each path is an array of node ids\n     * @param index the index of the path we want\n     * @return the first node in the given path\n     */\n    getFirstNodeIdInPathAtIndex(paths, index) {\n        var nodeId = null;\n\n        if (paths != null && index != null) {\n            // get the path at the given index\n            var path = paths[index];\n\n            if (path != null && path.length > 0) {\n                // get the first node id in the path\n                nodeId = path[0];\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Remove the node ifrom the paths\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     */\n    removeNodeIdFromPaths(nodeId, paths) {\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Remove the node id from the path\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     * @param pathIndex the path to remove from\n     */\n    removeNodeIdFromPath(nodeId, paths, pathIndex) {\n\n        if (nodeId != null && paths != null && pathIndex != null) {\n\n            // get the path at the given index\n            var path = paths[pathIndex];\n\n            if (path != null) {\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a ndoe id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Check if the first node ids in the paths are the same\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths have the same first node id\n     */\n    areFirstNodeIdsInPathsTheSame(paths) {\n        var result = true;\n\n        var nodeId = null;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // get the first node id in the path\n                var tempNodeId = path[0];\n\n                if (nodeId == null) {\n                    /*\n                     * this is the first path we have looked at so we will\n                     * remember the node id\n                     */\n                    nodeId = tempNodeId;\n                } else if (nodeId != tempNodeId) {\n                    /*\n                     * the node id does not match the first node id from a\n                     * previous path so the paths do not all have the same\n                     * first node id\n                     */\n                    result = false;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if all the paths are empty\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths are empty\n     */\n    arePathsEmpty(paths) {\n        var result = true;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the length of the path\n                    if (path.length !== 0) {\n                        // the path is not empty\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the paths that contain the node id\n     * @param nodeId the node id we are looking for\n     * @param paths an array of paths. each path is an array of node ids\n     * @return an array of paths that contain the given node id\n     */\n    getPathsThatContainNodeId(nodeId, paths) {\n        var pathsThatContainNodeId = [];\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id\n                if (path.indexOf(nodeId) != -1) {\n                    /*\n                     * add the path to the array of paths that contain\n                     * the node id\n                     */\n                    pathsThatContainNodeId.push(path);\n                }\n            }\n        }\n\n        return pathsThatContainNodeId;\n    };\n\n    /**\n     * Get a non empty path index. It will loop through the paths and\n     * return the index of the first non empty path.\n     * @param paths an array of paths. each path is an array of node ids\n     * @return the index of the path that is not empty\n     */\n    getNonEmptyPathIndex(paths) {\n        var index = null;\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // check the length of the path\n                if (path.length !== 0) {\n                    // the path is not empty so we will return this index\n                    index = p;\n                    break;\n                }\n            }\n        }\n\n        return index;\n    };\n\n    /**\n     * Get the branches in the project\n     */\n    getBranches() {\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the paths in the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // find the branches in the project from the paths\n        var branches = this.findBranches(allPaths);\n\n        return branches;\n    };\n\n    /**\n     * Find the branches in the project\n     * @param paths all the possible paths through the project\n     * @return an array of branch objects. each branch object contains\n     * the branch start point, the branch paths, and the branch\n     * end point\n     */\n    findBranches(paths) {\n        var branches = [];\n\n        var previousNodeId = null;\n\n        /*\n         * continue until all the paths are empty. we will remove\n         * node ids from the paths as we traverse the paths to find\n         * the branches\n         */\n        while (!this.arePathsEmpty(paths)) {\n\n            // get the first node id in the first path\n            var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n            if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                // the first node ids in all the paths are the same\n\n                // remove the node id from all the paths\n                this.removeNodeIdFromPaths(nodeId, paths);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nodeId;\n            } else {\n                // not all the top node ids are the same which means we have branched\n\n                // create a branch object\n                var branchMetaObject = this.createBranchMetaObject(previousNodeId);\n                branchMetaObject.branchStartPoint = previousNodeId;\n\n                // find the branch end point\n                var nextCommonNodeId = this.findNextCommonNodeId(paths);\n                branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n                // get the branch paths\n                var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n                branchPaths = this.removeDuplicatePaths(branchPaths);\n                branchMetaObject.branchPaths = branchPaths;\n\n                // add the branch object to our array\n                branches.push(branchMetaObject);\n\n                // trim the paths so that they start at the branch end point\n                this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nextCommonNodeId;\n            }\n        }\n\n        return branches;\n    };\n\n    /**\n     * Create a branch meta object that will contain the branch start\n     * point, branch paths, and branch end point\n     * @return an object that contains a branch start point, branch paths,\n     * and a branch end point\n     */\n    createBranchMetaObject() {\n        var branchMetaObject = {};\n\n        branchMetaObject.branchStartPoint = null;\n        branchMetaObject.branchPaths = [];\n        branchMetaObject.branchEndPoint = null;\n\n        return branchMetaObject;\n    };\n\n    /**\n     * Find the next common node id in all the paths\n     * @param paths the paths to find the common node id in\n     * @return a node id that is in all the paths or null\n     * if there is no node id that is in all the paths\n     */\n    findNextCommonNodeId(paths) {\n        var nextCommonNodeId = null;\n        var subPaths = [];\n\n        if (paths != null) {\n            if (paths.length > 0) {\n                // get the first path\n                var path = paths[0];\n\n                // loop through all the node ids in the first path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    // check if the node id is in all the paths\n                    if (this.allPathsContainNodeId(paths, tempNodeId)) {\n                        /*\n                         * the node id is in all the paths so we have found\n                         * what we were looking for\n                         */\n                        nextCommonNodeId = tempNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return nextCommonNodeId;\n    };\n\n    /**\n     * Check if all the paths contain the node id\n     * @param paths an array of paths. each path contains an array of node ids\n     * @param nodeId the node id that we will check is in all the paths\n     * @return whether the node id is in all the paths\n     */\n    allPathsContainNodeId(paths, nodeId) {\n        var result = false;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // get the index of the node id in the path\n                var index = path.indexOf(nodeId);\n\n                if (index == -1) {\n                    // the node id is not in the path\n                    result = false;\n                    break;\n                } else {\n                    // the node id is in the path\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Trim the paths up to the given node id so that the paths will contain\n     * the given node id and all the node ids after it. This function will\n     * modify the paths.\n     * @param paths the paths to trim\n     * @param nodeId the node id to trim up to\n     */\n    trimPathsUpToNodeId(paths, nodeId) {\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * trim the path to the end which will make\n                         * the path empty\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * trim the path up to the node id index. this will\n                     * modify the path array.\n                     */\n                    path.splice(0, index);\n                }\n            }\n        }\n    };\n\n\n    /**\n     * Extract the paths up to a given node id. This will be used to\n     * obtain branch paths.\n     * @param paths the paths to extract from\n     * @param nodeId the node id to extract up to\n     * @return paths that go up to but do not include the node id\n     */\n    extractPathsUpToNodeId(paths, nodeId) {\n        var extractedPaths = [];\n\n        if (paths != null) {\n            // loop through the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * extract up to the end of the path\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * get the path up to the node id index. this does\n                     * not modify the path array.\n                     */\n                    var extractedPath = path.slice(0, index);\n\n                    // add the\n                    extractedPaths.push(extractedPath);\n                }\n            }\n        }\n\n        return extractedPaths;\n    };\n\n    /**\n     * Removes duplicate paths\n     * @param paths an array of paths. each path contains an array of node ids\n     * @return an array of unique paths\n     */\n    removeDuplicatePaths(paths) {\n        var uniquePaths = [];\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                var isPathInUniquePaths = false;\n\n                // loop through all the unique paths so far\n                for (var u = 0; u < uniquePaths.length; u++) {\n                    // get a unique path\n                    var uniquePath = uniquePaths[u];\n\n                    // check if the paths are equal\n                    if (this.pathsEqual(path, uniquePath)) {\n                        // the paths are equal\n                        isPathInUniquePaths = true;\n                    }\n                }\n\n                if (!isPathInUniquePaths) {\n                    // the path is not equal to any paths in the unique\n                    // paths array so we will add it to the unique paths array\n                    uniquePaths.push(path);\n                }\n            }\n        }\n\n        return uniquePaths;\n    };\n\n    /**\n     * Check if two paths are equal\n     * @param path1 an array of node ids\n     * @param path2 an array of node ids\n     * @return whether the two paths contain the same node ids\n     * in the same order\n     */\n    pathsEqual(path1, path2) {\n        var result = false;\n\n        if (path1 != null && path2 != null) {\n\n            // check if the paths are the same length\n            if (path1.length === path2.length) {\n                result = true;\n\n                // loop through each element of the first path\n                for (var x = 0; x < path1.length; x++) {\n                    // get the node id from the first path\n                    var path1NodeId = path1[x];\n\n                    // get the node id from the second path\n                    var path2NodeId = path2[x];\n\n                    // check if the node ids are the same\n                    if (path1NodeId !== path2NodeId) {\n                        // the node ids are not the same to the paths are not equal\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id is in any branch\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return whether the node id is in any branch\n     */\n    isNodeIdInABranch(branches, nodeId) {\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branch objects\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch object\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths for this branch object\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // check if the node id is in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    // the node id is in this branch path\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Get the branch paths that a node id is in\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return an array of the branch paths that the node id is in\n     */\n    getBranchPathsByNodeId(branches, nodeId) {\n        var branchPathsIn = [];\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branches\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // get the index of the node id in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    /*\n                                     * the node is in this branch path so we will\n                                     * add the branch path to our array\n                                     */\n                                    branchPathsIn.push(branchPath);\n\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return branchPathsIn;\n    }\n\n    /**\n     * Get the component by node id and component id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\n     */\n    getComponentByNodeIdAndComponentId(nodeId, componentId) {\n        var component = null;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            // loop through all the components\n            for (var c = 0; c < components.length; c++) {\n                var tempComponent = components[c];\n\n                if (tempComponent != null) {\n                    var tempComponentId = tempComponent.id;\n\n                    if (componentId === tempComponentId) {\n                        // we have found the component we want\n                        component = tempComponent;\n                        break;\n                    }\n                }\n            }\n\n        }\n\n        return component;\n    };\n\n    /**\n     * Returns the position of the component in the node by node id and component id, 0-indexed.\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component's position or -1 if nodeId or componentId are null or doesn't exist in the project.\n     */\n    getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n        var componentPosition = -1;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            // loop through all the components\n            for (var c = 0; c < components.length; c++) {\n                var tempComponent = components[c];\n\n                if (tempComponent != null) {\n                    var tempComponentId = tempComponent.id;\n\n                    if (componentId === tempComponentId) {\n                        // we have found the component we want\n                        componentPosition = c;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return componentPosition;\n    };\n\n    /**\n     * Get the components in a node\n     * @param nodeId the node id\n     * @returns an array of components or empty array if nodeId is null or doesn't exist in the project.\n     * if the node exists but doesn't have any components, returns an empty array.\n     */\n    getComponentsByNodeId(nodeId) {\n        var components = [];\n\n        if (nodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n\n                // get the components\n                if (node.components != null) {\n                    components = node.components;\n                }\n            }\n        }\n\n        return components;\n    };\n\n    getNodeContentByNodeId(nodeId) {\n        var nodeContent = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                nodeContent = node.content;\n            }\n        }\n\n        return nodeContent;\n    };\n\n    /**\n     * Replace a component\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param component the new component\n     */\n    replaceComponent(nodeId, componentId, component) {\n\n        if (nodeId != null && componentId != null && component != null) {\n\n            // get all the components for the node\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n\n                        if (tempComponent.id === componentId) {\n                            // the component id matches the one we want so we will replace it\n                            components[c] = component;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Create a new group\n     * @param title the title of the group\n     * @returns the group object\n     */\n    createGroup(title) {\n\n        // get the next available group id\n        var newGroupId = this.getNextAvailableGroupId();\n\n        // create the group object\n        var newGroup = {};\n        newGroup.id = newGroupId;\n        newGroup.type = 'group';\n        newGroup.title = title;\n        newGroup.startId = '';\n        newGroup.ids = [];\n\n        return newGroup;\n    };\n\n    /**\n     * Create a new node\n     * @param title the title of the node\n     * @returns the node object\n     */\n    createNode(title) {\n\n        // get the next available node id\n        var newNodeId = this.getNextAvailableNodeId();\n\n        // create the node object\n        var newNode = {};\n        newNode.id = newNodeId;\n        newNode.title = title;\n        newNode.type = 'node';\n        newNode.constraints = [];\n        newNode.transitionLogic = {};\n        newNode.transitionLogic.transitions = [];\n\n        newNode.showSaveButton = true;\n        newNode.showSubmitButton = false;\n        newNode.components = [];\n\n        return newNode;\n    };\n\n    /**\n     * Create a node inside the group\n     * @param node the new node\n     * @param nodeId the node id of the group to create the node in\n     */\n    createNodeInside(node, nodeId) {\n        // add the node to the project\n        this.addNode(node);\n\n        // add the node to our mapping of node id to node\n        this.setIdToNode(node.id, node);\n\n        // create the transitions for the node\n        this.insertNodeInsideInTransitions(node.id, nodeId);\n\n        // add the node to the group\n        this.insertNodeInsideInGroups(node.id, nodeId);\n    }\n\n    /**\n     * Create a node after the given node id\n     * @param node the new node\n     * @param nodeId the node to add after\n     */\n    createNodeAfter(node, nodeId) {\n\n        // add the node to the project\n        this.addNode(node);\n\n        // add the node to our mapping of node id to node\n        this.setIdToNode(node.id, node);\n\n        // insert the new node id into the array of children ids\n        this.insertNodeAfterInGroups(node.id, nodeId);\n\n        // create the transition to the node\n        this.insertNodeAfterInTransitions(node, nodeId);\n\n        if (this.isGroupNode(node.id)) {\n            /*\n             * we are creating a group node so we will update/create the\n             * transitions that traverse from the previous group to this group\n             */\n\n            var oldToGroupIds = [];\n\n            // get the transitions that come out of the previous group\n            var transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\n\n            if (transitionsFromGroup != null) {\n\n                /*\n                 * loop through all the transitions that come out of the previous group\n                 * and get the node ids that the group transitions to\n                 */\n                for (var t = 0; t < transitionsFromGroup.length; t++) {\n                    var transitionFromGroup = transitionsFromGroup[t];\n\n                    if (transitionFromGroup != null) {\n                        var toNodeId = transitionFromGroup.to;\n\n                        if (toNodeId != null) {\n                            oldToGroupIds.push(toNodeId);\n                        }\n                    }\n                }\n            }\n\n            var fromGroupId = nodeId;\n            var oldToGroupIds = oldToGroupIds;\n            var newToGroupId = node.id;\n\n            /*\n             * make the transitions point to the new group and make the new\n             * group transition to the old group\n             */\n            this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\n        }\n    }\n\n    /**\n     * Insert the node after the given node id in the group's\n     * array of children ids\n     * @param nodeIdToInsert the node id we want to insert\n     * @param nodeIdToInsertAfter the node id we want to insert after\n     */\n    insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\n        var groupNodes = this.getGroupNodes();\n\n        if (groupNodes != null) {\n\n            // loop through the groups\n            for (var g = 0; g < groupNodes.length; g++) {\n                var group = groupNodes[g];\n\n                if (group != null) {\n                    var ids = group.ids;\n\n                    if (ids != null) {\n\n                        // loop through the children ids\n                        for (var i = 0; i < ids.length; i++) {\n                            var id = ids[i];\n\n                            if (nodeIdToInsertAfter === id) {\n                                // we have found the node id we want to insert after\n\n                                // insert the new node id\n                                ids.splice(i + 1, 0, nodeIdToInsert);\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the transitions to handle inserting a node after another node\n     * @param node the node to insert\n     * @param nodeId the node id to insert after\n     */\n    insertNodeAfterInTransitions(node, nodeId) {\n\n        // get the node that will end up before\n        var previousNode = this.getNodeById(nodeId);\n\n        if (previousNode != null) {\n\n            if (previousNode.transitionLogic == null) {\n                previousNode.transitionLogic = {};\n                previousNode.transitionLogic.transitions = [];\n            }\n\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            if (this.isGroupNode(node.id)) {\n                /*\n                 * the node we are inserting is a group so we will update\n                 * the transitions of its children so that they transition\n                 * to the correct node\n                 */\n                this.updateChildrenTransitionsForMovingGroup(node, nodeId);\n            }\n\n            var previousNodeTransitionLogic = previousNode.transitionLogic;\n\n            if (previousNodeTransitionLogic != null) {\n\n                // get the transitions from the before node\n                var transitions = previousNodeTransitionLogic.transitions;\n\n                if (transitions != null) {\n\n                    // make a copy of the transitions\n                    var transitionsJSONString = angular.toJson(transitions);\n                    var transitionsCopy = angular.fromJson(transitionsJSONString);\n\n                    // set the transitions from the before node into the inserted node\n                    node.transitionLogic.transitions = transitionsCopy;\n                }\n            }\n\n            if (node.transitionLogic.transitions.length == 0) {\n                /*\n                 * The node does not have any transitions so we will look for\n                 * a transition on the parent group. If the parent has a\n                 * transition we will use it for the node.\n                 */\n\n                // get the parent group\n                var parentGroupId = this.getParentGroupId(nodeId);\n\n                // get the parent transitions\n                var parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n                if (parentTransitions != null) {\n\n                    // loop through all the parent transitions\n                    for (var p = 0; p < parentTransitions.length; p++) {\n                        var parentTransition = parentTransitions[p];\n\n                        var newTransition = {};\n\n                        if (parentTransition != null) {\n                            var toNodeId = parentTransition.to;\n\n                            if (this.isGroupNode(toNodeId)) {\n                                // the transition is to a group\n\n                                // get the start id of the group\n                                var startId = this.getGroupStartId(toNodeId);\n\n                                if (startId == null || startId == '') {\n                                    // there is no start id so we will just use the group id\n                                    newTransition.to = toNodeId;\n                                } else {\n                                    // there is a start id so we will use it as the to node\n                                    newTransition.to = startId;\n                                }\n                            } else {\n                                // the tranisition is to a step\n                                newTransition.to = toNodeId;\n                            }\n                        }\n\n                        // add the new transition to the node\n                        node.transitionLogic.transitions.push(newTransition);\n                    }\n                }\n            }\n\n            var newNodeId = node.id;\n\n            // TODO handle branching case\n\n            // remove the transitions from the before node\n            previousNode.transitionLogic.transitions = [];\n\n            var transitionObject = {};\n            transitionObject.to = newNodeId;\n\n            // make the before node point to the new node\n            previousNode.transitionLogic.transitions.push(transitionObject);\n        }\n    }\n\n    /**\n     * Insert a node into a group\n     * @param nodeIdToInsert the node id to insert\n     * @param nodeIdToInsertInside the node id of the group we will insert into\n     */\n    insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\n\n        // get the group we will insert into\n        var group = this.getNodeById(nodeIdToInsertInside);\n\n        if (group != null) {\n            var ids = group.ids;\n\n            if (ids != null) {\n\n                // insert the node node id into the beginning of the child ids\n                ids.splice(0, 0, nodeIdToInsert);\n\n                // set the inserted node id as the start id\n                group.startId = nodeIdToInsert;\n            }\n        }\n    }\n\n    /**\n     * Update the transitions to handle inserting a node into a group\n     * @param nodeIdToInsert node id that we will insert\n     * @param nodeIdToInsertInside the node id of the group we are inserting into\n     */\n    insertNodeInsideInTransitions(nodeIdToInsert, nodeIdToInsertInside) {\n\n        // get the node we are inserting\n        var nodeToInsert = this.getNodeById(nodeIdToInsert);\n\n        // get the group we are inserting into\n        var group = this.getNodeById(nodeIdToInsertInside);\n\n        if (this.isGroupNode(nodeIdToInsert)) {\n            /*\n             * the node we are inserting is a group so we will update\n             * the transitions of its children so that they transition\n             * to the correct node\n             */\n            this.updateChildrenTransitionsForMovingGroup(nodeToInsert, null);\n        }\n\n        /*\n         * since we are inserting a node into a group, the node will become\n         * the first node in the group. this means we need to update any nodes\n         * that point to the old start id and make them point to the node\n         * we are inserting.\n         */\n        if (nodeToInsert != null && group != null) {\n\n            // get the start node\n            var startId = group.startId;\n\n            // get transitions that point to the start node\n            var previousNodes = this.getNodesByToNodeId(startId);\n\n            if (previousNodes == null || previousNodes.length == 0) {\n                // there are no transitions to the start node\n\n                // find all the groups that point to this group\n                var previousGroups = this.getGroupNodesByToNodeId(nodeIdToInsertInside);\n\n                // loop through all the groups that point to this group\n                for (var g = 0; g < previousGroups.length; g++) {\n                    var previousGroup = previousGroups[g];\n\n                    if (previousGroup != null) {\n                        // get the nodes that do not have a transition in the previous group\n                        var lastNodesInGroup = this.getLastNodesInGroup(previousGroup.id);\n\n                        for (var n = 0; n < lastNodesInGroup.length; n++) {\n                            // get a node that does not have a transition\n                            var node = lastNodesInGroup[n];\n\n                            // add a transition from the node to the node we are inserting\n                            this.addToTransition(node, nodeIdToInsert);\n                        }\n                    }\n                }\n            } else {\n                // there are transitions to the start node\n\n                for (var p = 0; p < previousNodes.length; p++) {\n                    var previousNode = previousNodes[p];\n\n                    if (previousNode != null) {\n                        // change the transition to point to the node we are inserting\n                        this.updateToTransition(previousNode, startId, nodeIdToInsert);\n                    }\n                }\n            }\n\n            /*\n             * update all the transitions that point to the group and change\n             * them to point to the new start id\n             */\n            var nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\n\n            if (nodesThatTransitionToGroup != null) {\n                for (var n = 0; n < nodesThatTransitionToGroup.length; n++) {\n                    var nodeThatTransitionsToGroup = nodesThatTransitionToGroup[n];\n\n                    if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\n                        this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\n                    }\n                }\n            }\n\n            /*\n             * create a transition from the node we are inserting to the node that\n             * was previously the start node\n             */\n            if (startId != null && startId != '') {\n                // there is a start id\n\n                var startNode = this.getNodeById(startId);\n\n                if (startNode != null) {\n                    // the group has a start node which will become the transition to node\n\n                    if (nodeToInsert.transitionLogic == null) {\n                        nodeToInsert.transitionLogic = {};\n                    }\n\n                    if (nodeToInsert.transitionLogic.transitions == null) {\n                        nodeToInsert.transitionLogic.transitions = [];\n                    }\n\n                    /*\n                     * make the inserted node transition to the previous start node\n                     */\n                    var transitionObject = {};\n                    transitionObject.to = startId;\n                    nodeToInsert.transitionLogic.transitions.push(transitionObject);\n                }\n            }\n\n            //check if the node we inserted has any transitions now\n            var transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\n\n            if (transitions == null || transitions.length == 0) {\n                /*\n                 * the node doesn't have any transitions so we will see if\n                 * the parent group transitions to anything and use that\n                 * transition\n                 */\n\n                // get the transitions from the parent\n                var parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\n\n                if (parentTransitions != null) {\n\n                    // loop through all the parent transitions\n                    for (var t = 0; t < parentTransitions.length; t++) {\n                        var parentTransition = parentTransitions[t];\n\n                        if (parentTransition != null) {\n                            var toNodeId = parentTransition.to;\n\n                            if (this.isGroupNode(toNodeId)) {\n                                // the to node is a group\n\n                                // get the to group\n                                var nextGroup = this.getNodeById(toNodeId);\n\n                                if (nextGroup != null) {\n\n                                    // get the start id of the to group\n                                    var startId = nextGroup.startId;\n\n                                    if (startId == null || startId == '') {\n                                        // there is no start id so we will just transition to the group\n                                        this.addToTransition(nodeToInsert, toNodeId);\n                                    } else {\n                                        // there is a start id so we will transition to that\n                                        this.addToTransition(nodeToInsert, startId);\n                                    }\n                                }\n                            } else {\n                                // the to node is not a group\n\n                                /*\n                                 * we will add a transition from the node we are inserting to\n                                 * to that node\n                                 */\n                                this.addToTransition(nodeToInsert, toNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add a transition to a node\n     * @param node the node we are adding a transition to\n     * @param toNodeId the node id we going to transition to\n     * @param criteria (optional) a criteria object specifying\n     * what needs to be satisfied in order to use this transition\n     */\n    addToTransition(node, toNodeId, criteria) {\n        if (node != null) {\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            var transition = {};\n\n            // set the to node id\n            transition.to = toNodeId;\n\n            if (criteria != null) {\n                // set the criteria\n                transition.criteria = criteria;\n            }\n\n            // add the transition to the node's transitions\n            node.transitionLogic.transitions.push(transition);\n        }\n    }\n\n    /**\n     * Update the to value of aa transition\n     * @param node the node to update\n     * @param oldToNodeId the previous to node id\n     * @param newToNodeId the new to node id\n     */\n    updateToTransition(node, oldToNodeId, newToNodeId) {\n        if (node != null) {\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            var transitions = node.transitionLogic.transitions;\n\n            // loop through all the transitions\n            for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                    var toNodeId = transition.to;\n\n                    if (oldToNodeId === toNodeId) {\n                        // we have found the transition we want to update\n\n                        // update the to node id\n                        transition.to = newToNodeId;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the nodes in a group that do not have transitions\n     * @param groupId the group id\n     * @returns the nodes in the group that do not have transitions\n     */\n    getLastNodesInGroup(groupId) {\n        var lastNodes = [];\n\n        if (groupId != null) {\n            var group = this.getNodeById(groupId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n\n                    // loop through all the child ids\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n\n                        if (childId != null) {\n                            var child = this.getNodeById(childId);\n\n                            if (child != null) {\n                                var transitionLogic = child.transitionLogic;\n\n                                if (transitionLogic != null) {\n\n                                    // get the transitions\n                                    var transitions = transitionLogic.transitions;\n\n                                    if (transitions == null || transitions.length == 0) {\n                                        // this child does not have any transitions\n                                        lastNodes.push(child);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return lastNodes;\n    }\n\n    /**\n     * Get the next available group id\n     * @returns the next available group id\n     */\n    getNextAvailableGroupId() {\n\n        // get all the group ids\n        var groupIds = this.getGroupIds();\n\n        var largestGroupIdNumber = null;\n\n        // loop through all the existing group ids\n        for (var g = 0; g < groupIds.length; g++) {\n            var groupId = groupIds[g];\n\n            // get the number from the group id e.g. the number of 'group2' would be 2\n            var groupIdNumber = groupId.replace('group', '');\n\n            // make sure the number is an actual number\n            if (!isNaN(groupIdNumber)) {\n\n                groupIdNumber = parseInt(groupIdNumber);\n\n                // update the largest group id number if necessary\n                if (largestGroupIdNumber == null) {\n                    largestGroupIdNumber = groupIdNumber;\n                } else if (groupIdNumber > largestGroupIdNumber) {\n                    largestGroupIdNumber = groupIdNumber;\n                }\n            }\n        }\n\n        // create the next available group id\n        var nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\n\n        return nextAvailableGroupId;\n    }\n\n    /**\n     * Get all the group ids\n     * @returns an array with all the group ids\n     */\n    getGroupIds() {\n\n        var groupIds = [];\n\n        var groupNodes = this.groupNodes;\n\n        // loop through all the group nodes\n        for (var g = 0; g < groupNodes.length; g++) {\n            var group = groupNodes[g];\n\n            if (group != null) {\n                var groupId = group.id;\n\n                if (groupId != null) {\n                    // add the group id\n                    groupIds.push(groupId);\n                }\n            }\n        }\n\n        return groupIds;\n    }\n\n    /**\n     * Get the next available node id\n     * @returns the next available node id\n     */\n    getNextAvailableNodeId() {\n\n        // get all the node ids\n        var nodeIds = this.getNodeIds();\n\n        var largestNodeIdNumber = null;\n\n        // loop through all the existing node ids\n        for (var n = 0; n < nodeIds.length; n++) {\n            var nodeId = nodeIds[n];\n\n            // get the number from the node id e.g. the number of 'node2' would be 2\n            var nodeIdNumber = nodeId.replace('node', '');\n\n            // make sure the number is an actual number\n            if (!isNaN(nodeIdNumber)) {\n                nodeIdNumber = parseInt(nodeIdNumber);\n\n                // update the largest node id number if necessary\n                if (largestNodeIdNumber == null) {\n                    largestNodeIdNumber = nodeIdNumber;\n                } else if (nodeIdNumber > largestNodeIdNumber) {\n                    largestNodeIdNumber = nodeIdNumber;\n                }\n            }\n        }\n\n        // create the next available node id\n        var nextAvailableNodeId = 'node' + (largestNodeIdNumber + 1);\n\n        return nextAvailableNodeId;\n    }\n\n    /**\n     * Get all the node ids from steps (not groups)\n     * @returns an array with all the node ids\n     */\n    getNodeIds() {\n\n        var nodeIds = [];\n\n        var nodes = this.applicationNodes;\n\n        // loop through all the nodes\n        for (var n = 0; n < nodes.length; n++) {\n            var node = nodes[n];\n\n            if (node != null) {\n                var nodeId = node.id;\n\n                if (nodeId != null) {\n                    nodeIds.push(nodeId);\n                }\n            }\n        }\n\n        return nodeIds;\n    }\n\n    /**\n     * Move nodes inside a group node\n     * @param nodeIds the node ids to move\n     * @param nodeId the node id of the group we are moving the nodes inside\n     */\n    moveNodesInside(nodeIds, nodeId) {\n\n        // loop thorugh all the nodes we are moving\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are moving\n            var tempNodeId = nodeIds[n];\n            var tempNode = this.getNodeById(tempNodeId);\n\n            var movingNodeIsActive = this.isActive(tempNodeId);\n            var stationaryNodeIsActive = this.isActive(nodeId);\n\n            if (movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from active to active\n                \n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n                \n                // remove the node from the group\n                this.removeNodeIdFromGroups(tempNodeId);\n\n                if (n == 0) {\n                    /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\n                } else {\n                    /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\n                }\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from active to inactive\n                \n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n                \n                // remove the node from the group\n                this.removeNodeIdFromGroups(tempNodeId);\n                \n                // move the node to the inactive array\n                this.moveToInactive(tempNode, nodeId);\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from inactive to active\n                \n                this.moveToActive(tempNode);\n                \n                if (n == 0) {\n                    /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\n                } else {\n                    /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\n                }\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from inactive to inactive\n                \n                // move the node within the inactive nodes\n                this.moveInactiveNode(tempNode, nodeId);\n            }\n\n            /*\n             * remember the node id so we can put the next node (if any)\n             * after this one\n             */\n            nodeId = tempNode.id;\n        }\n    }\n\n    /**\n     * Move nodes after a certain node id\n     * @param nodeIds the node ids to move\n     * @param nodeId the node id we will put the moved nodes after\n     */\n    moveNodesAfter(nodeIds, nodeId) {\n\n        // loop through all the nodes we are moving\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are moving\n            var tempNodeId = nodeIds[n];\n            var node = this.getNodeById(tempNodeId);\n            \n            var movingNodeIsActive = this.isActive(tempNodeId);\n            var stationaryNodeIsActive = this.isActive(nodeId);\n\n            if (movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from active to active\n                \n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the groups\n                this.removeNodeIdFromGroups(tempNodeId);\n                \n                // insert the node into the parent group\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n                // create the transition\n                this.insertNodeAfterInTransitions(node, nodeId);\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from active to inactive\n                \n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the groups\n                this.removeNodeIdFromGroups(tempNodeId);\n                \n                // move the node to the inactive array\n                this.moveToInactive(node, nodeId);\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from inactive to active\n                \n                // move the node to the active nodes array\n                this.moveToActive(node);\n                \n                // insert the node into the parent group\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n                // create the transition\n                this.insertNodeAfterInTransitions(node, nodeId);\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from inactive to inactive\n                \n                // move the node within the inactive nodes\n                this.moveInactiveNode(node, nodeId);\n            }\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = node.id;\n        }\n    }\n\n    /**\n     * Copy nodes and put them after a certain node id\n     * @param nodeIds the node ids to copy\n     * @param nodeId the node id we will put the copied nodes after\n     */\n    copyNodesInside(nodeIds, nodeId) {\n        // loop through all the nodes we are copying\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are copying\n            var nodeIdToCopy = nodeIds[n];\n\n            // create a copy of the node\n            var newNode = this.copyNode(nodeIdToCopy);\n            var newNodeId = newNode.id;\n\n            if (n == 0) {\n                // this is the first node we are copying so we will insert it\n                // into the beginning of the group\n                this.createNodeInside(newNode, nodeId);\n            } else {\n                // this is not the first node we are copying so we will insert\n                // it after the node we previously inserted\n                this.createNodeAfter(newNode, nodeId);\n            }\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = newNodeId;\n            this.parseProject();  // refresh project and update references because a new node have been added.\n        }\n    }\n\n    /**\n     * Copy nodes and put them after a certain node id\n     * @param nodeIds the node ids to copy\n     * @param nodeId the node id we will put the copied nodes after\n     */\n    copyNodesAfter(nodeIds, nodeId) {\n        // loop through all the nodes we are copying\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are copying\n            var nodeIdToCopy = nodeIds[n];\n\n            // create a copy of the node\n            var newNode = this.copyNode(nodeIdToCopy);\n            var newNodeId = newNode.id;\n\n            this.createNodeAfter(newNode, nodeId);\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = newNodeId;\n            this.parseProject();  // refresh project and update references because a new node have been added.\n        }\n    }\n\n    /**\n     * Copy the node with the specified nodeId\n     * @param nodeId the node id to copy\n     * @return copied node\n     */\n    copyNode(nodeId) {\n        var node = this.getNodeById(nodeId);\n\n        var nodeCopy = JSON.parse(JSON.stringify(node));\n        nodeCopy.id = this.getNextAvailableNodeId();\n        nodeCopy.transitionLogic = {};  // clear transition logic\n        nodeCopy.constraints = [];  // clear constraints\n        for (var c = 0; c < nodeCopy.components.length; c++) {\n            var component = nodeCopy.components[c];\n            var componentType = component.type;\n            // get the service for the node type\n            var service = this.$injector.get(componentType + 'Service');\n            // copy the component\n            var componentCopy = service.copyComponent(component);\n            if (component.maxScore != null) {\n                // Also copy the max score if exists in original node\n                componentCopy.maxScore = component.maxScore;\n            }\n            if (component.showPreviousWorkPrompt != null) {\n                // Also copy the showPreviousWorkPrompt if exists in original node\n                componentCopy.showPreviousWorkPrompt = component.showPreviousWorkPrompt;\n            }\n            if (component.showPreviousWorkNodeId != null) {\n                // Also copy the showPreviousWorkNodeId if exists in original node\n                componentCopy.showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n            }\n            if (component.showPreviousWorkComponentId != null) {\n                // Also copy the showPreviousWorkComponentId if exists in original node\n                componentCopy.showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n            }\n\n            nodeCopy.components[c] = componentCopy;\n        }\n        return nodeCopy;\n    }\n\n    /**\n     * Delete a node\n     * @param nodeId the node id\n     */\n    deleteNode(nodeId) {\n\n        if (this.isGroupNode(nodeId)) {\n            // the node is a group node so we will also remove all of its children\n            var group = this.getNodeById(nodeId);\n\n            // TODO check if the child is in another group, if so do not remove\n\n            if (group != null) {\n                var ids = group.ids;\n\n                // loop through all the children\n                for (var i = 0; i < ids.length; i++) {\n                    var id = ids[i];\n\n                    // remove the child\n                    this.removeNodeIdFromTransitions(id);\n                    this.removeNodeIdFromGroups(id);\n                    this.removeNodeIdFromNodes(id);\n\n                    /*\n                     * move the counter back because we have removed a child\n                     * from the parent group's array of child ids so all of\n                     * the child ids were shifted back one and the next child\n                     * we want will be at i--\n                     */\n                    i--;\n                }\n            }\n        }\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        // check if we need to update the start id of the parent group\n        if (parentGroup != null) {\n\n            /*\n             * the node is the start node of the parent group so we need\n             * to update the start id of the parent group to point to\n             * the next node\n             */\n            if (nodeId === parentGroup.startId) {\n\n                var hasSetNewStartId = false;\n\n                // get the node\n                var node = this.getNodeById(nodeId);\n\n                if (node != null) {\n                    var transitionLogic = node.transitionLogic;\n\n                    if (transitionLogic != null) {\n                        var transitions = transitionLogic.transitions;\n\n                        if (transitions != null && transitions.length > 0) {\n                            var transition = transitions[0];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                if (toNodeId != null) {\n\n                                    // check that the to node is in the same group\n                                    if (this.isNodeInGroup(toNodeId, parentGroup.id)) {\n\n                                        // update the parent group start id\n                                        parentGroup.startId = toNodeId;\n                                        hasSetNewStartId = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!hasSetNewStartId) {\n                    parentGroup.startId = '';\n                }\n            }\n        }\n\n        // remove the node\n        this.removeNodeIdFromTransitions(nodeId);\n        this.removeNodeIdFromGroups(nodeId);\n        this.removeNodeIdFromNodes(nodeId);\n\n        if (parentGroup != null) {\n            this.recalculatePositionsInGroup(parentGroup.id);\n        }\n    }\n\n    /**\n     * Update the transitions to handle removing a node\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromTransitions(nodeId) {\n\n        // get the node we are removing\n        var nodeToRemove = this.getNodeById(nodeId);\n\n        // get all the nodes that have a transition to the node we are removing\n        var nodesByToNodeId = this.getNodesByToNodeId(nodeId);\n\n        // get the transitions of the node we are removing\n        var nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\n        var nodeToRemoveTransitions = [];\n\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n            nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n        }\n\n        var parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\n\n        var parentGroup = this.getNodeById(parentIdOfNodeToRemove);\n\n        // update the start id if we are removing the start node of a group\n        if (parentGroup != null) {\n            var parentGroupStartId = parentGroup.startId;\n\n            if (parentGroupStartId != null) {\n                if (parentGroupStartId === nodeId) {\n                    // the node we are removing is the start node\n\n                    if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\n\n                        // loop through all the transitions from the node to choose a new start id\n                        for (var t = 0; t < nodeToRemoveTransitions.length; t++) {\n                            var nodeToRemoveTransition = nodeToRemoveTransitions[t];\n\n                            if (nodeToRemoveTransition != null) {\n                                var toNodeId = nodeToRemoveTransition.to;\n\n                                if (toNodeId != null) {\n                                    /*\n                                     * we need to check that the to node id is in the\n                                     * same group. some transitions point to a node id\n                                     * in the next group which we would not want to use\n                                     * for the start id.\n                                     */\n                                    if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\n\n                                        // set the new start id\n                                        parentGroup.startId = toNodeId;\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        // there are no transitions so we will have an empty start id\n                        parentGroup.startId = '';\n                    }\n                }\n            }\n        }\n\n        // loop through all the nodes that transition to the node we are removing\n        for (var n = 0; n < nodesByToNodeId.length; n++) {\n\n            // get a node that has a transition to the node we are removing\n            var node = nodesByToNodeId[n];\n\n            if (node != null) {\n                var parentIdOfFromNode = this.getParentGroupId(node.id);\n\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    // loop through all the transitions of this node\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n\n                        if (nodeId === transition.to) {\n                            // we have found the transition to the node we are removing\n\n                            // copy the transitions from the node we are removing\n                            var transitionsCopy = angular.toJson(nodeToRemoveTransitions);\n                            transitionsCopy = angular.fromJson(transitionsCopy);\n\n                            /*\n                             * if the parent from group is different than the parent removing group\n                             * remove transitions that are to a node in a different group than\n                             * the parent removing group\n                             */\n\n                            if (parentIdOfFromNode != parentIdOfNodeToRemove) {\n\n                                for (var tc = 0; tc < transitionsCopy.length; tc++) {\n                                    var tempTransition = transitionsCopy[tc];\n\n                                    if (tempTransition != null) {\n                                        var tempToNodeId = tempTransition.to;\n\n                                        if (tempToNodeId != null) {\n                                            var parentIdOfToNode = this.getParentGroupId(tempToNodeId);\n\n                                            if (parentIdOfNodeToRemove != parentIdOfToNode) {\n                                                // remove the transition\n\n                                                transitionsCopy.splice(tc, 1);\n                                                tc--;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n\n                            // remove the transition to the node we are removing\n                            transitions.splice(t, 1);\n\n                            // insert the transitions from the node we are removing\n                            transitions = transitions.slice(0, t).concat(transitionsCopy).concat(transitions.slice(t + 1));\n                            \n                            // check if the node we are moving is a group\n                            if (this.isGroupNode(nodeId)) {\n                                /*\n                                 * we are moving a group so we need to update transitions that\n                                 * go into the group\n                                 */\n                                var groupIdWeAreMoving = nodeId;\n                                var groupThatTransitionsToGroupWeAreMoving = node;\n                                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\n                            }\n                        }\n                    }\n\n                    // set the transitions into the node that transitions to the node we are removing\n                    transitionLogic.transitions = transitions;\n                }\n            }\n        }\n\n        if (nodeToRemoveTransitionLogic != null) {\n            // clear the transitions of the node we are removing\n            nodeToRemoveTransitionLogic.transitions = [];\n        }\n        \n        if (this.isGroupNode(nodeId)) {\n            /*\n             * this is a group node so we will remove all child transitions that\n             * go out of this group\n             */\n            \n            //this.removeTransitionsIntoGroup(nodeId);\n            this.removeTransitionsOutOfGroup(nodeId);\n        }\n    };\n\n    /**\n     * Remove the node id from a group\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromGroups(nodeId) {\n\n        var groups = this.groupNodes;\n\n        if (groups != null) {\n\n            // loop through all the groups\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n\n                    // get the start id of the group\n                    var startId = group.startId;\n\n                    // get the child ids of the group\n                    var ids = group.ids;\n\n                    // loop through all the child ids\n                    for (var i = 0; i < ids.length; i++) {\n                        var id = ids[i];\n\n                        if (nodeId === id) {\n                            // we have found the node id we want to remove\n                            ids.splice(i, 1);\n\n                            if (nodeId === startId) {\n                                /*\n                                 * the node id is also the start id so we will get the\n                                 * next node id and set it as the new start id\n                                 */\n\n                                var hasSetNewStartId = false;\n\n                                // get the node we are removing\n                                var node = this.getNodeById(id);\n\n                                if (node != null) {\n                                    var transitionLogic = node.transitionLogic;\n\n                                    if (transitionLogic != null) {\n                                        var transitions = transitionLogic.transitions;\n\n                                        if (transitions != null && transitions.length > 0) {\n\n                                            // get the first transition\n                                            // TODO handle the case when the node we are removing is a branch point\n                                            var transition = transitions[0];\n\n                                            if (transition != null) {\n                                                // get the node that this node transitions to\n                                                var to = transition.to;\n\n                                                if (to != null) {\n                                                    // set the to node as the start id\n                                                    group.startId = to;\n                                                    hasSetNewStartId = true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n\n                                if (!hasSetNewStartId) {\n                                    /*\n                                     * the node we are removing did not have a transition\n                                     * so there will be no start id\n                                     */\n                                    group.startId = '';\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove the node from the array of nodes\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromNodes(nodeId) {\n\n        // get all the nodes in the project\n        var nodes = this.project.nodes;\n\n        // loop through all the nodes\n        for (var n = 0; n < nodes.length; n++) {\n            var node = nodes[n];\n\n            if (node != null) {\n                if (nodeId === node.id) {\n                    // we have found the node we want to remove\n                    nodes.splice(n, 1);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Remove the node from the inactive nodes array\n     * @param nodeId the node to remove from the inactive nodes array\n     */\n    removeNodeIdFromInactiveNodes(nodeId) {\n        \n        // get the inactive nodes array\n        var inactiveNodes = this.project.inactiveNodes;\n        \n        if (inactiveNodes != null) {\n            \n            // loop through the inactive nodes\n            for (var i = 0; i < inactiveNodes.length; i++) {\n                var inactiveNode = inactiveNodes[i];\n                \n                if (inactiveNode != null) {\n                    var inactiveNodeId = inactiveNode.id;\n                    \n                    if (nodeId === inactiveNodeId) {\n                        /*\n                         * we have found the node we are looking for so we will\n                         * remove it\n                         */\n                        inactiveNodes.splice(i, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a new component\n     * @param nodeId the node id to create the component in\n     * @param componentType the component type\n     */\n    createComponent(nodeId, componentType) {\n\n        if (nodeId != null && componentType != null) {\n            // get the node we will create the component in\n            var node = this.getNodeById(nodeId);\n\n            // get the service for the node type\n            var service = this.$injector.get(componentType + 'Service');\n\n            if (node != null && service != null) {\n\n                // create the new component\n                var component = service.createComponent();\n\n                // add the component to the node\n                this.addComponentToNode(node, component);\n            }\n        }\n    }\n\n    /**\n     * Add the component to the node\n     * @param node the node\n     * @param component the component\n     */\n    addComponentToNode(node, component) {\n\n        if (node != null && component != null) {\n            node.components.push(component);\n        }\n    }\n\n    /**\n     * Move the component up within the node\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    moveComponentUp(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to move\n\n                            /*\n                             * make sure this is not the first component because\n                             * the first component can't be moved up\n                             */\n                            if (c != 0) {\n                                // this is not the first component\n\n                                // remove the component\n                                components.splice(c, 1);\n\n                                // put the component back in at the position one index back\n                                components.splice(c - 1, 0, component);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Move the component down within the node\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    moveComponentDown(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to move\n\n                            /*\n                             * make sure this is not the last component because\n                             * the last component can't be moved down\n                             */\n                            if (c != components.length - 1) {\n                                // this is not the last component\n\n                                // remove the component\n                                components.splice(c, 1);\n\n                                // put the component back in at the position one index ahead\n                                components.splice(c + 1, 0, component);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Delete the component\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    deleteComponent(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to delete\n\n                            // remove the component\n                            components.splice(c, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the max score for the project\n     * @returns the max score for the project or null if none of the components in the project\n     * has max scores.\n     */\n    getMaxScore() {\n\n        var maxScore = null;\n\n        var nodes = this.project.nodes;\n\n        if (nodes != null) {\n\n            // loop through all the nodes\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeMaxScore = this.getMaxScoreForNode(node.id);\n\n                    if (nodeMaxScore != null) {\n                        if (maxScore == null) {\n                            maxScore = nodeMaxScore;\n                        } else {\n                            maxScore += nodeMaxScore;\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxScore;\n    }\n\n    /**\n     * Get the max score for the node\n     * @param nodeId the node id\n     * @returns the max score for the node\n     */\n    getMaxScoreForNode(nodeId) {\n        var maxScore = null;\n\n        // get the node\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            var components = node.components;\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var component = components[c];\n\n                    if (component != null) {\n\n                        // get the max score for the component\n                        var componentMaxScore = component.maxScore;\n\n                        // check if the component has a max score\n                        if (componentMaxScore != null) {\n\n                            // make sure the max score is a valid number\n                            if (!isNaN(componentMaxScore)) {\n\n                                if (maxScore == null) {\n                                    maxScore = componentMaxScore;\n                                } else {\n                                    // accumulate the max score\n                                    maxScore += componentMaxScore;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxScore;\n    }\n\n    /**\n     * Determine if a node id is a direct child of a group\n     * @param nodeId the node id\n     * @param groupId the group id\n     */\n    isNodeInGroup(nodeId, groupId) {\n\n        var result = false;\n\n        var group = this.getNodeById(groupId);\n\n        var childIds = group.ids;\n\n        if (childIds != null) {\n            if (childIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the first leaf node by traversing all the start ids\n     * until a leaf node id is found\n     */\n    getFirstLeafNodeId() {\n\n        var firstLeafNodeId = null;\n\n        // get the start group id\n        var startGroupId = this.project.startGroupId;\n\n        // get the start group node\n        var node = this.getNodeById(startGroupId);\n\n        var done = false;\n\n        // loop until we have found a leaf node id or something went wrong\n        while (!done) {\n\n            if (node == null) {\n                done = true;\n            } else if (this.isGroupNode(node.id)) {\n                // set the first leaf node id to the group id for now\n                firstLeafNodeId = node.id;\n\n                // the current node is a group\n                node = this.getNodeById(node.startId);\n            } else if (this.isApplicationNode(node.id)) {\n                // the current node is a leaf\n                firstLeafNodeId = node.id;\n                done = true;\n            } else {\n                done = true;\n            }\n        }\n\n        return firstLeafNodeId;\n    }\n\n    /**\n     * Replace a node. This is used when we want to revert a node back to a\n     * previous version in the authoring tool.\n     * @param nodeId the node id\n     * @param node the node object\n     */\n    replaceNode(nodeId, node) {\n\n        if (nodeId != null && node != null) {\n\n            // set the id to node mapping\n            this.setIdToNode(nodeId, node);\n\n            // set the id to element mapping\n            this.setIdToElement(nodeId, node);\n\n            // update the nodes array\n            var nodes = this.getNodes();\n\n            if (nodes != null) {\n\n                for (var n = 0; n < nodes.length; n++) {\n                    var tempNode = nodes[n];\n\n                    if (tempNode != null) {\n                        var tempNodeId = tempNode.id;\n\n                        if (nodeId === tempNodeId) {\n                            // we have found the node we want to replace\n                            nodes.splice(n, 1, node);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // update the application nodes array\n            var applicationNodes = this.applicationNodes;\n\n            if (applicationNodes != null) {\n                for (var a = 0; a < applicationNodes.length; a++) {\n                    var tempApplicationNode = applicationNodes[a];\n\n                    if (tempApplicationNode != null) {\n                        var tempApplicationNodeId = tempApplicationNode.id;\n\n                        if (nodeId === tempApplicationNodeId) {\n                            // we have found the node we want to replace\n                            applicationNodes.splice(a, 1, node);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if a node is a planning node\n     * @param nodeId the node id\n     * @returns whether the node is a planning node\n     */\n    isPlanning(nodeId) {\n        var result = false;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                if (node.planning) {\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Check if a node is a planning node instance\n     * @param nodeId the node id\n     * @returns whether the node is a planning node instance\n     */\n    isPlanningInstance(nodeId) {\n        var result = false;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node.planningNodeTemplateId) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the available planning node ids for a node\n     * @param nodeId the node we want available planning nodes for\n     * @returns an array of available planning node ids\n     */\n    getAvailablePlanningNodeIds(nodeId) {\n        var availablePlanningNodeIds = [];\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null && node.availablePlanningNodeIds != null) {\n                availablePlanningNodeIds = node.availablePlanningNodeIds;\n            }\n        }\n\n        return availablePlanningNodeIds;\n    }\n\n    /**\n     * Get the available planning nodes for a given group\n     * @param nodeId the node id of the group\n     * @returns an array of planning node templates\n     */\n    getAvailablePlanningNodes(nodeId) {\n        var availablePlanningNodesSoFar = [];\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null && node.availablePlanningNodes != null) {\n                let availablePlanningNodes = node.availablePlanningNodes;\n\n                // loop through all the nodes and retrieve the actual node\n                for (var a = 0; a < availablePlanningNodes.length; a++) {\n                    var availablePlanningNode = availablePlanningNodes[a];\n\n                    if (availablePlanningNode != null) {\n\n                        // get the node\n                        var availablePlanningNodeActual = this.getNodeById(availablePlanningNode.nodeId);\n\n                        if (availablePlanningNodeActual != null) {\n                            if (availablePlanningNode.max != null) {\n                                availablePlanningNodeActual.max = availablePlanningNode.max;\n                            }\n                            availablePlanningNodesSoFar.push(availablePlanningNodeActual);\n                        }\n                    }\n                }\n            }\n        }\n\n        return availablePlanningNodesSoFar;\n    }\n\n    /**\n     * Create a planning node instance and add it to the project\n     * @param groupId the group id to add the planning node instance to\n     * @param nodeId the node id of the planning node template\n     */\n    createPlanningNodeInstance(groupId, nodeId, nextAvailablePlanningNodeId) {\n\n        var planningNodeInstance = null;\n\n        if (nodeId != null && nextAvailablePlanningNodeId != null) {\n            // get the planning node template\n            var node = this.getNodeById(nodeId);\n\n            // create a planning node instance by copying the planning node template\n            planningNodeInstance = this.copyNode(nodeId);\n\n            // set the template id to point back to the planning template node\n            planningNodeInstance.planningNodeTemplateId = nodeId;\n\n            // set the planning node instance node id\n            planningNodeInstance.id = nextAvailablePlanningNodeId;\n        }\n\n        return planningNodeInstance;\n    }\n\n    /**\n     * Add a planning node instance inside a group node\n     * @param nodeIdToInsertInside the group id to insert into\n     * @param planningNodeInstance the planning node instance to add\n     */\n    addPlanningNodeInstanceInside(nodeIdToInsertInside, planningNodeInstance) {\n        // get the node id\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n        // add an entry in our mapping data structures of node id to object\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n        // add the node to the nodes array in the project\n        this.addNode(planningNodeInstance);\n\n        // update the transitions\n        this.insertNodeInsideInTransitions(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n        // update the child ids of the group\n        this.insertNodeInsideInGroups(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n        // recalculate all the position values in the group\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Add a planning node instance after a node\n     * @param nodeIdToInsertAfter the node to insert after\n     * @param planningNodeInstance the planning node instance to add\n     */\n    addPlanningNodeInstanceAfter(nodeIdToInsertAfter, planningNodeInstance) {\n        // get the node id\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n        // add an entry in our mapping data structures of node id to object\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n        // add the node to the nodes array in the project\n        this.addNode(planningNodeInstance);\n\n        // update the transitions\n        this.insertNodeAfterInTransitions(planningNodeInstance, nodeIdToInsertAfter);\n\n        // update the child ids of the group\n        this.insertNodeAfterInGroups(planningNodeInstanceNodeId, nodeIdToInsertAfter);\n\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n        if (parentGroup != null) {\n            var parentGroupId = parentGroup.id;\n\n            // recalculate all the position values in the group\n            this.recalculatePositionsInGroup(parentGroupId);\n        }\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Move a planning node instance inside a group\n     * @param nodeIdToMove the node to move\n     * @param nodeIdToInsertInside the group to move the node into\n     */\n    movePlanningNodeInstanceInside(nodeIdToMove, nodeIdToInsertInside) {\n\n        // move the node inside the group node\n        this.moveNodesInside([nodeIdToMove], nodeIdToInsertInside);\n\n        // recalculate all the position values in the group\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Move a planning node instance after a node\n     * @param nodeIdToMove the node to move\n     * @param nodeIdToInsertAfter the other node to move the node after\n     */\n    movePlanningNodeInstanceAfter(nodeIdToMove, nodeIdToInsertAfter) {\n\n        // move the node after the other node\n        this.moveNodesAfter([nodeIdToMove], nodeIdToInsertAfter);\n\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n        if (parentGroup != null) {\n            var parentGroupId = parentGroup.id;\n\n            // recalculate all the position values in the group\n            this.recalculatePositionsInGroup(parentGroupId);\n        }\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Recalculate the positions of the children in the group.\n     * The positions are the numbers usually seen before the title\n     * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\n     * is the position\n     * @param groupId recalculate all the children of this group\n     */\n    recalculatePositionsInGroup(groupId) {\n\n        if (groupId != null) {\n            var childIds = this.getChildNodeIdsById(groupId);\n\n            // loop througha all the children\n            for (var c = 0; c < childIds.length; c++) {\n                var childId = childIds[c];\n\n                // calculate the position of the child id\n                var pos = this.getPositionById(childId);\n\n                // set the mapping of node id to position\n                this.setIdToPosition(childId, pos);\n            }\n        }\n    }\n\n    /**\n     * Get the message that describes how to disable the constraint\n     * @param nodeId the node the student is trying to go to\n     * @param constraint the constraint that is preventing the student\n     * from going to the node\n     * @returns the message to display to the student that describes how\n     * to disable the constraint\n     */\n    getConstraintMessage(nodeId, constraint) {\n\n        var message = '';\n\n        if (nodeId != null && constraint != null) {\n\n            // get the node title the student is trying to go to\n            var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n\n            var removalConditional = constraint.removalConditional;\n            var removalCriteria = constraint.removalCriteria;\n\n            if (removalConditional === 'any') {\n                message += 'To visit \"' + nodeTitle + '\" you must perform one of the actions below:<br/>';\n            } else {\n                message += 'To visit \"' + nodeTitle + '\" you must perform all of the actions below:<br/>';\n            }\n\n            if (removalCriteria != null) {\n\n                var criteriaMessages = '';\n\n                // loop through all the criteria\n                for (var x = 0; x < removalCriteria.length; x++) {\n                    var tempRemovalCriteria = removalCriteria[x];\n\n                    if (tempRemovalCriteria != null) {\n\n                        // get the message that describes the criteria that needs to be satisfied\n                        var criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\n\n                        if (criteriaMessage != null && criteriaMessage != '') {\n                            // separate criteria messages with a line break\n                            if (criteriaMessages != '') {\n                                criteriaMessages += '<br/>';\n                            }\n                            criteriaMessages += criteriaMessage;\n                        }\n                    }\n                }\n\n                message += criteriaMessages;\n            }\n        }\n\n        return message;\n    }\n\n    /**\n     * Get the message that describes how to satisfy the criteria\n     * TODO: check if the criteria is satisfied\n     * @param criteria the criteria object that needs to be satisfied\n     * @returns the message to display to the student that describes how to\n     * satisfy the criteria\n     */\n    getCriteriaMessage(criteria) {\n        var message = '';\n\n        if (criteria != null) {\n            var name = criteria.name;\n            var params = criteria.params;\n\n            if (name === 'isCompleted') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Complete \"' + nodeTitle + '\"';\n                }\n            } else if (name === 'isVisited') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Visit \"' + nodeTitle + '\"';\n                }\n            } else if (name === 'choiceChosen') {\n\n            } else if (name === 'branchPathTaken') {\n\n            } else if (name === 'isPlanningActivityCompleted') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Complete \"' + nodeTitle + '\"';\n                }\n            }\n        }\n\n        return message;\n    }\n\n    /**\n     * Get the start id of a group\n     * @param nodeId get the start id of this group\n     * @returns the start id of the group\n     */\n    getGroupStartId(nodeId) {\n\n        var startId = null;\n\n        if (nodeId != null) {\n\n            // get the group\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                // get the start id\n                startId = node.startId;\n            }\n        }\n\n\n        return startId;\n    }\n\n    /**\n     * Get the start id of the node's parent group\n     * @param nodeId we will get the parent of this node and then look\n     * for the start id of the parent\n     * @returns the start id of the parent\n     */\n    getParentGroupStartId(nodeId) {\n        var parentGroupStartId = null;\n\n        if (nodeId != null) {\n            var parentGroup = this.getParentGroup(nodeId);\n\n            if (parentGroup != null) {\n                parentGroupStartId = parentGroup.startId;\n            }\n        }\n\n        return parentGroupStartId;\n    }\n\n    /**\n     * Update the transitions so that the fromGroup points to the newToGroup\n     *\n     * Before\n     * fromGroup -> oldToGroup -> newToGroup\n     *\n     * After\n     * fromGroup -> newToGroup\n     * oldToGroup becomes dangling and has no transitions to or from it\n     */\n    updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\n\n        /*\n         * make the transitions\n         * fromGroup -> newToGroup\n         */\n        if (fromGroupId != null && oldToGroupId != null) {\n            var fromGroup = this.getNodeById(fromGroupId);\n            var oldToGroup = this.getNodeById(oldToGroupId);\n            var newToGroup = null;\n            var newToGroupStartId = null;\n\n            if (newToGroupId != null) {\n                newToGroup = this.getNodeById(newToGroupId);\n            }\n\n            if (newToGroup != null) {\n                newToGroupStartId = newToGroup.startId;\n            }\n\n            if (fromGroup != null && oldToGroup != null) {\n                var childIds = fromGroup.ids;\n\n                // update the children of the from group to point to the new to group\n                if (childIds != null) {\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        var child = this.getNodeById(childId);\n                        var transitions = this.getTransitionsByFromNodeId(childId);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the from group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    if (toNodeId === oldToGroupId) {\n                                        // the transition is to the group\n                                        if (newToGroupId == null && newToGroupStartId == null) {\n                                            // there is no new to group so we will remove the transition\n                                            transitions.splice(t, 1);\n                                            t--;\n                                        } else {\n                                            // make the transition point to the new to group\n                                            transition.to = newToGroupId;\n                                        }\n                                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                                        // the transition is to a node in the group\n                                        if (newToGroupId == null && newToGroupStartId == null) {\n                                            // there is no new to group so we will remove the transition\n                                            transitions.splice(t, 1);\n                                            t--;\n                                        } else if (newToGroupStartId == null || newToGroupStartId == '') {\n                                            // make the transition point to the new to group\n                                            transition.to = newToGroupId;\n                                        } else {\n                                            // make the transition point to the new group start id\n                                            transition.to = newToGroupStartId;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * remove the transitions from the oldToGroup\n         */\n        if (oldToGroupId != null && newToGroupId != null) {\n\n            var oldToGroup = this.getNodeById(oldToGroupId);\n\n            if (oldToGroup != null) {\n                var childIds = oldToGroup.ids;\n\n                // remove the transitions from the old to group that point to the new to group\n                if (childIds != null) {\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        var child = this.getNodeById(childId);\n                        var transitions = this.getTransitionsByFromNodeId(childId);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the old to group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    if (toNodeId === newToGroupId) {\n                                        // the transition is to the group so we will remove it\n                                        transitions.splice(t, 1);\n                                        t--;\n                                    } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\n                                        // the transition is to a node in the group so we will remove it\n                                        transitions.splice(t, 1);\n                                        t--;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the transitions so that the fromGroup points to the newToGroup\n     *\n     * Before\n     * fromGroup -> oldToGroup\n     * newToGroup is dangling and has no transitions to or from it\n     *\n     * After\n     * fromGroup -> newToGroup -> oldToGroup\n     */\n    updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\n\n        var fromGroup = null;\n        var newToGroup = null;\n\n        if (fromGroupId != null) {\n            fromGroup = this.getNodeById(fromGroupId);\n        }\n\n        if (newToGroupId != null) {\n            newToGroup = this.getNodeById(newToGroupId);\n        }\n\n        /*\n         * make the transitions that point to the old group now point\n         * to the new group\n         * fromGroup -> newToGroup\n         */\n        if (fromGroup != null && newToGroup != null) {\n            var childIds = fromGroup.ids;\n            var newToGroupStartId = newToGroup.startId;\n\n            if (childIds != null) {\n\n                // loop through all the nodes in the from group\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n                    var child = this.getNodeById(childId);\n\n                    // get the transitions from the child\n                    var transitions = this.getTransitionsByFromNodeId(childId);\n\n                    if (transitions == null || transitions.length == 0) {\n                        /*\n                         * the child does not have any transitions so we will make it\n                         * point to the new group\n                         */\n                        if (newToGroupStartId == null || newToGroupStartId == '') {\n                            this.addToTransition(child, newToGroupId);\n                        } else {\n                            this.addToTransition(child, newToGroupStartId)\n                        }\n                    } else if (transitions != null) {\n\n                        // loop through all the transitions from the child\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                if (oldToGroupIds != null) {\n\n                                    /*\n                                     * loop through all the old to group ids to find transitions\n                                     * to the old to group\n                                     */\n                                    for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                                        var oldToGroupId = oldToGroupIds[ot];\n\n                                        if (toNodeId === oldToGroupId) {\n                                            /*\n                                             * the transition is to the group so we will update the transition\n                                             * to the new group\n                                             */\n                                            transition.to = newToGroupId;\n                                        } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                                            /*\n                                             * the transition is to a node in the old group so we will update\n                                             * the transition to point to the new group\n                                             */\n                                            if (newToGroupStartId == null || newToGroupStartId == '') {\n                                                transition.to = newToGroupId;\n                                            } else {\n                                                transition.to = newToGroupStartId;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * make the steps that do not have a transition now point to the old\n         * group\n         * newToGroup -> oldToGroup\n         */\n        if (newToGroup != null) {\n            var childIds = newToGroup.ids;\n\n            if (childIds != null) {\n\n                // loop through all the children in the new group\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n                    var child = this.getNodeById(childId);\n\n                    // get the transitions for the child\n                    var transitions = this.getTransitionsByFromNodeId(childId);\n\n                    if (transitions == null || transitions.length == 0) {\n\n                        if (oldToGroupIds != null) {\n\n                            // loop through all the old groups\n                            for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                                var oldToGroupId = oldToGroupIds[ot];\n                                var oldToGroup = this.getNodeById(oldToGroupId);\n\n                                if (oldToGroup != null) {\n\n                                    var oldToGroupStartId = oldToGroup.startId;\n\n                                    var transition = {};\n\n                                    var toNodeId = '';\n\n                                    if (oldToGroupStartId == null) {\n                                        // there is no start node id so we will just point to the group\n                                        toNodeId = oldToGroup;\n                                    } else {\n                                        // there is a start node id so we will point to it\n                                        toNodeId = oldToGroupStartId;\n                                    }\n\n                                    // create the transition from the child to the old group\n                                    this.addToTransition(child, toNodeId);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the child transitions because we are moving a group. We will\n     * update the transitions into and out of the group in the location\n     * we are extracting the group from and also in the location we are\n     * inserting the group into.\n     * @param node the group we are moving\n     * @param nodeId we will put the group after this node id\n     */\n    updateChildrenTransitionsForMovingGroup(node, nodeId) {\n        var transitionsBefore = null;\n\n        // get the group nodes that point to the group we are moving\n        var previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\n\n        // get all the transitions from the group we are moving\n        var transitionsAfter = this.getTransitionsByFromNodeId(node.id);\n\n        var extracted = false;\n\n        /*\n         * extract the group we are moving by updating the transitions of the\n         * from group and the new to group. also remove the transitions from the\n         * group we are moving.\n         */\n\n        // loop through all the groups that point to the group we are moving\n        for (var p = 0; p < previousGroupNodes.length; p++) {\n            var previousGroupNode = previousGroupNodes[p];\n\n            if (transitionsAfter == null || transitionsAfter.length == 0) {\n                // the group we are moving does not have any transitions\n\n                /*\n                 * remove the transitions to the group we are moving and make\n                 * new transitions from the from group to the new to group\n                 */\n                this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\n                extracted = true;\n            } else {\n                // the group we are moving has transitions\n\n                // make the previous group point to the new to group\n                for (var t = 0; t < transitionsAfter.length; t++) {\n                    var transitionAfter = transitionsAfter[t];\n\n                    if (transitionAfter != null) {\n                        var toNodeId = transitionAfter.to;\n\n                        /*\n                         * remove the transitions to the group we are moving and make\n                         * new transitions from the from group to the new to group\n                         */\n                        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\n                        extracted = true;\n                    }\n                }\n            }\n        }\n\n        if (!extracted) {\n            /*\n             * we have not removed the transitions yet because the group\n             * we are moving does not have any groups before it\n             */\n\n            // remove the transitions from the group we are moving\n            for (var t = 0; t < transitionsAfter.length; t++) {\n                var transitionAfter = transitionsAfter[t];\n\n                if (transitionAfter != null) {\n                    var toNodeId = transitionAfter.to;\n\n                    // remove the transitions to the group we are moving\n                    this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\n                    extracted = true;\n                }\n            }\n        }\n\n        var inserted = false;\n\n        /*\n         * create the transitions from the from group to the group we are moving\n         * and the transitions from the group we are moving to the old to group\n         */\n        if (nodeId != null) {\n            // get the transitions from the previous group to the next group\n            var transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\n\n            for (var t = 0; t < transitionsAfter.length; t++) {\n                var transitionAfter = transitionsAfter[t];\n\n                if (transitionAfter != null) {\n                    var toNodeId = transitionAfter.to;\n\n                    /*\n                     * create the transitions that traverse from the from group\n                     * to the group we are moving. also create the transitions\n                     * that traverse from the group we are moving to the old\n                     * to group.\n                     */\n                    this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\n                    inserted = true;\n                }\n            }\n        }\n\n        if (!inserted) {\n            /*\n             * we have not inserted the transitions yet because there were no\n             * previous group transitions\n             */\n\n            if (nodeId == null) {\n                /*\n                 * the previous node id is null which means there was no previous\n                 * group. this means the group we are inserting will become the\n                 * first group. this happens when the group we are moving\n                 * is moved inside the root (group0).\n                 */\n\n                var startGroupId = this.getStartGroupId();\n\n                if (startGroupId != null) {\n\n                    // get the start group for the whole project (group0)\n                    var startGroup = this.getNodeById(startGroupId);\n\n                    if (startGroup != null) {\n\n                        // get the first activity\n                        var firstGroupId = startGroup.startId;\n\n                        /*\n                         * create the transitions that traverse from the group\n                         * we are moving to the previous first activity.\n                         */\n                        this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\n                    }\n                }\n\n            } else {\n                /*\n                 * we have not inserted the group yet because the from group doesn't\n                 * have a group after it\n                 */\n\n                /*\n                 * create the transitions that traverse from the from group\n                 * to the group we are moving.\n                 */\n                this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\n            }\n        }\n    }\n    \n    /**\n     * Check if a component is a connected component\n     * @param nodeId the node id of the component\n     * @param componentId the component that is listening for connected changes\n     * @param connectedComponentId the component that is broadcasting connected changes\n     * @returns whether the componentId is connected to the connectedComponentId\n     */\n    isConnectedComponent(nodeId, componentId, connectedComponentId) {\n        \n        var result = false;\n        \n        // get the component\n        var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n        \n        if (component != null) {\n            \n            var connectedComponents = component.connectedComponents;\n            \n            if (connectedComponents != null) {\n                \n                // loop through all the connected components\n                for (var c = 0; c < connectedComponents.length; c++) {\n                    var connectedComponent = connectedComponents[c];\n                    \n                    if (connectedComponent != null) {\n                        if (connectedComponentId === connectedComponent.id) {\n                            // we have found the connected component id we are looking for\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Get a connected component params\n     * @param componentId the connected component id\n     * @returns the params for the connected component\n     */\n    getConnectedComponentParams(componentContent, componentId) {\n        \n        var connectedComponentParams = null;\n        \n        if (componentContent != null && componentId != null) {\n            \n            // get the connected components\n            var connectedComponents = componentContent.connectedComponents;\n            \n            if (connectedComponents != null) {\n                \n                // loop through all the connected components\n                for (var c = 0; c < connectedComponents.length; c++) {\n                    var connectedComponent = connectedComponents[c];\n                    \n                    if (connectedComponent != null) {\n                        var tempComponentId = connectedComponent.id;\n                        \n                        if (componentId === tempComponentId) {\n                            // we have found the connected component we are looking for\n                            connectedComponentParams = connectedComponent;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return connectedComponentParams;\n    }\n    \n    /**\n     * Get the inactive groups\n     * @returns the inactive groups\n     */\n    getInactiveGroups() {\n        var inactiveGroups = [];\n        \n        if (this.project != null) {\n            \n            if (this.project.inactiveGroups == null) {\n                this.project.inactiveGroups = [];\n            }\n            \n            inactiveGroups = this.project.inactiveGroups;\n        }\n        \n        return inactiveGroups;\n    }\n    \n    /**\n     * Get the inactive nodes\n     * @returns the inactive nodes\n     */\n    getInactiveNodes() {\n        var inactiveNodes = [];\n        \n        if (this.project != null) {\n            \n            if (this.project.inactiveNodes == null) {\n                this.project.inactiveNodes = [];\n            }\n            \n            inactiveNodes = this.project.inactiveNodes;\n        }\n        \n        return inactiveNodes;\n    }\n    \n    /**\n     * Remove the node from the active nodes\n     * @param nodeId the node to remove\n     * @returns the node that we have removed\n     */\n    removeNodeFromActiveNodes(nodeId) {\n        var node = null;\n        \n        if (nodeId != null) {\n            \n            // get the active nodes\n            var activeNodes = this.project.nodes;\n            \n            if (activeNodes != null) {\n                \n                // loop through all the active nodes\n                for (var a = 0; a < activeNodes.length; a++) {\n                    var activeNode = activeNodes[a];\n                    \n                    if (activeNode != null) {\n                        if (nodeId === activeNode.id) {\n                            // we have found the node we want to remove\n                            node = activeNode;\n                            \n                            // remove the node from the array\n                            activeNodes.splice(a, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return node;\n    }\n    \n    /**\n     * Remove the node from the inactive nodes array\n     * @param nodeId the node to remove\n     * @returns the node that was removed\n     */\n    removeNodeFromInactiveNodes(nodeId) {\n        var node = null;\n        \n        if (nodeId != null) {\n            \n            // get all the inactive nodes\n            var inactiveNodes = this.project.inactiveNodes;\n            \n            if (inactiveNodes != null) {\n                \n                // loop through all the inactive nodes\n                for (var i = 0; i < inactiveNodes.length; i++) {\n                    var inactiveNode = inactiveNodes[i];\n                    \n                    if (inactiveNode != null) {\n                        if (nodeId === inactiveNode.id) {\n                            // we have found the node we want to remove\n                            node = inactiveNode;\n                            \n                            // remove the node from the array\n                            inactiveNodes.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return node;\n    }\n    \n    /**\n     * Load the inactive nodes\n     * @param nodes the inactive nodes\n     */\n    loadInactiveNodes(nodes) {\n        \n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n                \n                if (node != null) {\n                    var nodeId = node.id;\n                    \n                    // set the node into the mapping data structures\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Check if the node is active\n     * @param nodeId the node to check\n     * @returns whether the node is in the active array\n     */\n    isActive(nodeId) {\n        \n        var result = true;\n        \n        if (nodeId != null) {\n            \n            if (nodeId === 'inactiveNodes') {\n                // this occurs when the author puts a step into the inactive nodes\n                result = false;\n            } else if (nodeId === 'inactiveGroups') {\n                // this occurs when the author puts a group into the inactive groups\n                result = false;\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n                // TODO: implement this\n            } else {\n                // the node is a step node\n                \n                // get the inactive nodes\n                var inactiveNodes = this.project.inactiveNodes;\n                \n                if (inactiveNodes != null) {\n                    \n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n                        \n                        if (inactiveNode != null) {\n                            if (nodeId === inactiveNode.id) {\n                                // we have found the node in the inactive nodes\n                                result = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Move the node to the active nodes array\n     */\n    moveToActive(node) {\n        if (node != null) {\n            \n            // make sure the node is inactive\n            if (!this.isActive(node.id)) {\n                // the node is inactive so we will move it to the active array\n                \n                // remove the node from inactive nodes array\n                this.removeNodeFromInactiveNodes(node.id);\n                \n                // add the node to the active array\n                this.addNode(node);\n            }\n        }\n    }\n    \n    /**\n     * Move the node to the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    moveToInactive(node, nodeIdToInsertAfter) {\n        if (node != null) {\n            \n            // make sure the node is active\n            if (this.isActive(node.id)) {\n                // the node is active so we will move it to the inactive array\n                \n                // remove the node from the active array\n                this.removeNodeFromActiveNodes(node.id);\n                \n                // add the node to the inactive array\n                this.addInactiveNode(node, nodeIdToInsertAfter);\n            }\n        }\n    }\n    \n    /**\n     * Add the node to the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    addInactiveNode(node, nodeIdToInsertAfter) {\n        if (node != null) {\n            var inactiveNodes = this.project.inactiveNodes;\n            \n            if (inactiveNodes != null) {\n                \n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps') {\n                    // put the node at the beginning of the inactive steps\n                    inactiveNodes.splice(0, 0, node);\n                } else {\n                    // put the node after one of the inactive nodes\n                    \n                    var added = false;\n                    \n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n                        \n                        if (inactiveNode != null) {\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\n                                // we have found the position to place the node\n                                inactiveNodes.splice(i + 1, 0, node);\n                                added = true;\n                            }\n                        }\n                    }\n                    \n                    if (!added) {\n                        /*\n                         * we haven't added the node yet so we will just add it \n                         * to the end of the array\n                         */\n                        inactiveNodes.push(node);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Move an inactive node within the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    moveInactiveNode(node, nodeIdToInsertAfter) {\n        \n        if (node != null) {\n            var inactiveNodes = this.project.inactiveNodes;\n            \n            if (inactiveNodes != null) {\n                \n                // remove the node from inactive nodes\n                \n                // loop through all the inactive nodes\n                for (var i = 0; i < inactiveNodes.length; i++) {\n                    var inactiveNode = inactiveNodes[i];\n                    \n                    if (inactiveNode != null) {\n                        if (node.id === inactiveNode.id) {\n                            // we have found the node we want to remove\n                            inactiveNodes.splice(i, 1);\n                        }\n                    }\n                }\n                \n                // add the node back into the inactive nodes\n                \n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps') {\n                    // put the node at the beginning of the inactive nodes\n                    inactiveNodes.splice(0, 0, node);\n                } else {\n                    // put the node after one of the inactive nodes\n                    \n                    var added = false;\n                    \n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n                        \n                        if (inactiveNode != null) {\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\n                                // we have found the position to place the node\n                                inactiveNodes.splice(i + 1, 0, node);\n                                added = true;\n                            }\n                        }\n                    }\n                    \n                    if (!added) {\n                        /*\n                         * we haven't added the node yet so we will just add it \n                         * to the end of the array\n                         */\n                        inactiveNodes.push(node);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Remove transitions that go into the group\n     * @param nodeId the group id\n     */\n    removeTransitionsIntoGroup(nodeId) {\n        \n        if (nodeId != null) {\n            \n            var group = this.getNodeById(nodeId);\n            \n            if (group != null) {\n                var childIds = group.ids;\n                \n                if (childIds != null) {\n                    \n                    // loop through all the children\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        \n                        if (childId != null) {\n                            this.removeTransitionsThatPointToNodeIdFromOutsideGroup(childId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Remove the transitions that point to the node that does not have\n     * the same parent\n     * @param nodeId remove transitions to this node\n     */\n    removeTransitionsThatPointToNodeIdFromOutsideGroup(nodeId) {\n        \n        if (nodeId != null) {\n            \n            // get the parent of the node\n            var parentGroupId = this.getParentGroupId(nodeId);\n            \n            // get all the nodes that point to the node\n            var nodesThatPointToTargetNode = this.getNodesByToNodeId(nodeId);\n            \n            if (nodesThatPointToTargetNode != null) {\n                \n                // loop through all the nodes that point to the node\n                for (var n = 0; n < nodesThatPointToTargetNode.length; n++) {\n                    var nodeThatPointsToTargetNode = nodesThatPointToTargetNode[n];\n                    \n                    if (nodeThatPointsToTargetNode != null) {\n                        \n                        // get the parent of the node that points to the node target node\n                        var nodeThatPointsToTargetNodeParentGroupId = this.getParentGroupId(nodeThatPointsToTargetNode.id);\n                        \n                        if (parentGroupId != nodeThatPointsToTargetNodeParentGroupId) {\n                            /*\n                             * the parent groups are different so we will remove\n                             * the transition\n                             */\n                            this.removeTransition(nodeThatPointsToTargetNode, nodeId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Remove a transition\n     * @param node remove a transition in this node\n     * @param toNodeId remove the transition that goes to this node id\n     */\n    removeTransition(node, toNodeId) {\n        \n        if (node != null && toNodeId != null) {\n            \n            var transitionLogic = node.transitionLogic;\n            \n            if (transitionLogic != null) {\n                var transitions = transitionLogic.transitions;\n                \n                if (transitions != null) {\n                    \n                    // loop through all the transitions\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n                        \n                        if (transition != null) {\n                            if (toNodeId === transition.to) {\n                                // we have found a transition that goes to the toNodeId\n                                \n                                // remove the transition\n                                transitions.splice(t, 1);\n                                t--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Remove transitions that go out of the group\n     * @param nodeId the group id\n     */\n    removeTransitionsOutOfGroup(nodeId) {\n        if (nodeId != null) {\n            var group = this.getNodeById(nodeId);\n            \n            if (group != null) {\n                var childIds = group.ids;\n                \n                if (childIds != null) {\n                    \n                    // loop through all the child ids\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        \n                        if (childId != null) {\n                            \n                            // get the transitions of the child\n                            var transitions = this.getTransitionsByFromNodeId(childId);\n                            \n                            if (transitions != null) {\n                                \n                                // loop through all the transitions\n                                for (var t = 0; t < transitions.length; t++) {\n                                    var transition = transitions[t];\n                                    \n                                    if (transition != null) {\n                                        \n                                        // get the to node id of the transition\n                                        var toNodeId = transition.to;\n                                        \n                                        if (toNodeId != null) {\n                                            \n                                            // get the parent group id of the toNodeId\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n                                            \n                                            if (nodeId != toNodeIdParentGroupId) {\n                                                /*\n                                                 * the parent group is different which means it is a \n                                                 * transition that goes out of the group\n                                                 */\n                                                 \n                                                // remove the transition\n                                                transitions.splice(t, 1);\n                                                t--;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Update the step transitions that point into the group we are moving\n     * For example\n     * group1 has children node1 and node2 (node2 transitions to node3)\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * group3 has children node5 and node6\n     * if we move group2 after group3 we will need to change the\n     * transition from node2 to node3 and make node2 transition to node5\n     * the result will be\n     * group1 has children node1 and node2 (node2 transitions to node5)\n     * group3 has children node5 and node6\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * note: the (node4 transition to node5) will be removed later \n     * when is called removeTransitionsOutOfGroup\n     * note: when group2 is added in a later function call, we will add\n     * the node6 to node3 transition\n     * @param groupThatTransitionsToGroupWeAreMoving the group object \n     * that transitions to the group we are moving. we may need to update\n     * the transitions of this group's children.\n     * @param groupIdWeAreMoving the group id of the group we are moving\n     */\n    updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\n        \n        if (groupThatTransitionsToGroupWeAreMoving != null && groupIdWeAreMoving != null) {\n            var group = this.getNodeById(groupIdWeAreMoving);\n            \n            if (group != null) {\n                // get all the nodes that have a transition to the node we are removing\n                var nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\n\n                // get the transitions of the node we are removing\n                var nodeToRemoveTransitionLogic = group.transitionLogic;\n                var nodeToRemoveTransitions = [];\n\n                if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n                    nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n                }\n                \n                if (nodeToRemoveTransitions.length > 0) {\n                    \n                    // get the first group that comes after the group we are removing\n                    var firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\n                    var firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\n                    \n                    if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\n                        \n                        // get the group that comes after the group we are moving\n                        var groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\n                        \n                        // get child ids of the group that comes before the group we are moving\n                        var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n                        \n                        if (childIds != null) {\n                            \n                            // loop through all the children\n                            for (var c = 0; c < childIds.length; c++) {\n                                var childId = childIds[c];\n                                \n                                var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n                                \n                                if (transitionsFromChild != null) {\n                                    \n                                    // loop through all the transitions from the child\n                                    for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                                        var transitionFromChild = transitionsFromChild[tfc];\n                                        \n                                        if (transitionFromChild != null) {\n                                            var toNodeId = transitionFromChild.to;\n                                            \n                                            // get the parent group id of the toNodeId\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n                                            \n                                            if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                                                // the transition is to a child in the group we are moving\n                                                \n                                                if (groupNode.startId == null) {\n                                                    // change the transition to point to the after group\n                                                    transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\n                                                } else {\n                                                    // change the transition to point to the start id of the after group\n                                                    transitionFromChild.to = groupNode.startId;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nProjectService.$inject = [\n    '$http',\n    '$injector',\n    '$rootScope',\n    'ConfigService'\n];\n\nexport default ProjectService;\n"]}