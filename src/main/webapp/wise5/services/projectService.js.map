{"version":3,"sources":["projectService.es6"],"names":["ProjectService","$http","$injector","$q","$rootScope","ConfigService","project","transitions","applicationNodes","inactiveNodes","groupNodes","idToNode","idToElement","metadata","activeConstraints","rootNode","idToPosition","idToOrder","nodeCount","componentServices","filters","parseProject","style","name","getProjectMetadata","title","projectTitle","nodes","planningNodes","nodeId","childIds","node","getNodeById","ids","id","result","getNodes","n","length","transition","existingTransitions","getTransitions","replaced","t","existingTransition","splice","push","existingNodes","existingNode","existingNodeId","$broadcast","groupId","group","groupChildNodeIds","indexOf","groupNode","type","applicationNode","nodeType","content","constraints","setIdToNode","setIdToElement","addNode","addGroupNode","addApplicationNode","addNodeToGroupNode","c","constraint","p","planningNode","clearProjectFields","loadNodes","loadPlanningNodes","loadInactiveNodes","constraintId","active","getRootNode","setNodeOrder","branches","getBranches","branchNodeIds","pos","setIdToPosition","isNodeIdInABranch","getPositionById","b","getBranchNodePositionById","isGroupNode","i","child","getMode","planningIds","availablePlanningNodes","a","path","getPathToNode","undefined","order","getIdByOrder","integerToAlpha","int","alphabet","branch","branchPaths","branchPath","nodeIndex","startPoint","branchStartPoint","startPointPos","branchPathPos","num","position","Object","entries","value","element","contentString","JSON","stringify","replaceAssetPaths","parse","contentBaseURL","getConfigParam","replace","RegExp","matchedString","delimiter","matchedStringWithoutQuotes","substr","injectClickToSnipImageIntoContentString","imgMatcher","matchGroup1","newString","getNodePositionById","nodeIcon","defaultName","color","fontSet","fontName","imgSrc","imgAlt","icons","default","icon","$","extend","getGroupNodes","g","isNodeDirectChildOfGroup","parentGroupId","parentGroup","getParentGroup","val","depth","parent","getNodeDepth","groupIds","descendents","getDescendentsOfGroup","childId","childDescendents","concat","projectStartId","getStartNodeId","groups","getGroups","groupStartId","startId","startNodeId","startGroupId","allConstraints","isNodeAffectedByConstraint","targetId","action","isNodeIdAfter","targetNode","isNodeDescendentOfGroup","nodeIdBefore","nodeIdAfter","isApplicationNode","pathsToEnd","getAllPaths","pathToEnd","index","parentGroupIndex","getTransitionsByFromNodeId","toNodeId","to","navigationMode","componentId","component","getComponentByNodeIdAndComponentId","componentType","componentService","get","getPossibleTransitionCriteria","fromNodeId","transitionLogic","getTransitionLogicByFromNodeId","nodesByToNodeId","nodeIds","getNodesByToNodeId","groupsThatPointToNodeId","hasTransitionTo","transitionsResults","projectURL","Date","getTime","then","projectJSON","data","setProject","commitMessage","cleanupBeforeSave","projectId","getProjectId","saveProjectURL","projectJSONString","angular","toJson","httpParams","method","url","headers","params","param","commitHistory","resolve","reject","notifyProjectEndURL","notifyProjectBeginURL","otherAuthors","inactiveNode","checked","copyProjectURL","registerNewProjectURL","e","Error","commitProjectURL","wiseBaseURL","getWISEBaseURL","theme","themeSettings","pathsSoFar","allPaths","consolidatePaths","pathSoFar","includeGroups","addedCurrentNodeId","getParentGroupId","parentGroupTransitions","parentGroupTransition","allPathsFromToNode","tempPath","unshift","transitionResult","firstNodeId","firstParentGroupId","lastNodeId","pop","paths","consolidatedPath","arePathsEmpty","currentPath","getNonEmptyPathIndex","getFirstNodeIdInPathAtIndex","areFirstNodeIdsInPathsTheSame","removeNodeIdFromPaths","pathsThatContainNodeId","getPathsThatContainNodeId","removeNodeIdFromPath","consumedPath","consumePathsUntilNodeId","consumedNodeIds","x","tempNodeId","pathsToConsume","pathThatContainsNodeId","tempNodeIdIndex","nodeIdIndex","tempConsumedNodeIds","pathIndex","findBranches","previousNodeId","branchMetaObject","createBranchMetaObject","nextCommonNodeId","findNextCommonNodeId","branchEndPoint","extractPathsUpToNodeId","removeDuplicatePaths","trimPathsUpToNodeId","subPaths","allPathsContainNodeId","extractedPaths","extractedPath","slice","uniquePaths","isPathInUniquePaths","u","uniquePath","pathsEqual","path1","path2","path1NodeId","path2NodeId","bp","branchPathsIn","components","getComponentsByNodeId","tempComponent","tempComponentId","componentPosition","nodeContent","newGroupId","getNextAvailableGroupId","newGroup","newNodeId","getNextAvailableNodeId","newNode","showSaveButton","showSubmitButton","insertNodeInsideInTransitions","insertNodeInsideInGroups","insertNodeAfterInGroups","insertNodeAfterInTransitions","oldToGroupIds","transitionsFromGroup","transitionFromGroup","fromGroupId","newToGroupId","updateTransitionsForInsertingGroup","nodeIdToInsert","nodeIdToInsertAfter","previousNode","updateChildrenTransitionsForMovingGroup","previousNodeTransitionLogic","transitionsJSONString","transitionsCopy","fromJson","parentTransitions","parentTransition","newTransition","getGroupStartId","transitionObject","nodeIdToInsertInside","nodeToInsert","previousNodes","previousGroups","getGroupNodesByToNodeId","previousGroup","lastNodesInGroup","getLastNodesInGroup","addToTransition","updateToTransition","nodesThatTransitionToGroup","nodeThatTransitionsToGroup","startNode","nextGroup","criteria","oldToNodeId","newToNodeId","lastNodes","getGroupIds","largestGroupIdNumber","groupIdNumber","isNaN","parseInt","nextAvailableGroupId","getNodeIds","largestNodeIdNumber","nodeIdNumber","inactiveNodeIds","getInactiveNodeIds","inactiveNodeId","nextAvailableNodeId","tempNode","movingNodeIsActive","isActive","stationaryNodeIsActive","removeNodeIdFromTransitions","removeNodeIdFromGroups","moveToInactive","moveToActive","moveInactiveNode","nodeIdToCopy","copyNode","createNodeInside","createNodeAfter","nodeCopy","service","componentCopy","copyComponent","maxScore","showPreviousWorkPrompt","showPreviousWorkNodeId","showPreviousWorkComponentId","removeNodeIdFromNodes","hasSetNewStartId","isNodeInGroup","recalculatePositionsInGroup","nodeToRemove","nodeToRemoveTransitionLogic","nodeToRemoveTransitions","parentIdOfNodeToRemove","parentGroupStartId","nodeToRemoveTransition","parentIdOfFromNode","tc","tempTransition","tempToNodeId","parentIdOfToNode","groupIdWeAreMoving","groupThatTransitionsToGroupWeAreMoving","updateChildrenTransitionsIntoGroupWeAreMoving","removeTransitionsOutOfGroup","createComponent","addComponentToNode","nodeMaxScore","getMaxScoreForNode","componentMaxScore","firstLeafNodeId","done","tempApplicationNode","tempApplicationNodeId","planning","planningNodeTemplateId","availablePlanningNodeIds","availablePlanningNodesSoFar","availablePlanningNode","availablePlanningNodeActual","max","nextAvailablePlanningNodeId","planningNodeInstance","planningNodeInstanceNodeId","nodeIdToMove","moveNodesInside","moveNodesAfter","getChildNodeIdsById","message","nodeTitle","getNodePositionAndTitleByNodeId","removalConditional","removalCriteria","criteriaMessages","tempRemovalCriteria","criteriaMessage","getCriteriaMessage","oldToGroupId","fromGroup","oldToGroup","newToGroup","newToGroupStartId","ot","oldToGroupStartId","transitionsBefore","previousGroupNodes","transitionsAfter","extracted","previousGroupNode","updateTransitionsForExtractingGroup","transitionAfter","inserted","getStartGroupId","startGroup","firstGroupId","connectedComponentId","connectedComponents","connectedComponent","componentContent","connectedComponentParams","inactiveGroups","activeNodes","activeNode","removeNodeFromInactiveNodes","removeNodeFromActiveNodes","addInactiveNode","added","removeTransitionsThatPointToNodeIdFromOutsideGroup","nodesThatPointToTargetNode","nodeThatPointsToTargetNode","nodeThatPointsToTargetNodeParentGroupId","removeTransition","toNodeIdParentGroupId","firstNodeToRemoveTransition","firstNodeToRemoveTransitionToNodeId","transitionsFromChild","tfc","transitionFromChild","nodeIdAndComponentIds","getNodeContentByNodeId","nodeIdAndComponentId","annotation","displayAnnotation","isGlobal","isPopup","score","annotationGroup","globalAnnotationSettings","globalAnnotationGroups","globalAnnotationGroup","enableCriteria","enableCriteriaScoreArray","s","enableCriteriaScore","previousScore","currentScore","notificationResult","notificationSettings","notifications","notification","scoreSequence","previousScoreMatch","currentScoreMatch","toString","match","componentHasWork","getComponentService","componentServiceName","$inject"],"mappings":"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","file":"projectService.js","sourcesContent":["'use strict';\n\nclass ProjectService {\n\n    constructor($http, $injector, $q, $rootScope, ConfigService) {\n        this.$http = $http;\n        this.$injector = $injector;\n        this.$q = $q;\n        this.$rootScope = $rootScope;\n        this.ConfigService = ConfigService;\n        this.project = null;\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.inactiveNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.metadata = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n        this.componentServices = {};\n\n        // filtering options for navigation displays\n        this.filters = [\n            {'name': 'all', 'label': 'All'}\n            //{'name': 'todo', 'label': 'Todo'},\n            //{'name': 'completed', 'label': 'Completed'}\n        ];\n    };\n\n    setProject(project) {\n        this.project = project;\n        this.parseProject();\n    };\n\n    /**\n     * Initialize the data structures used to hold project information\n     */\n    clearProjectFields() {\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.inactiveNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.metadata = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n    };\n\n    getStyle() {\n        var style = '';\n        var project = this.project;\n        if (project != null) {\n            style = project.style;\n        }\n        return style;\n    };\n\n    getFilters() {\n        return this.filters;\n    };\n\n    /**\n     * Returns the name/title of the current project\n     */\n    getProjectTitle() {\n        var name = this.getProjectMetadata().title;\n        return name ? name : 'A WISE Project (No name)';\n    };\n\n    /**\n     * Set the project title\n     */\n    setProjectTitle(projectTitle) {\n        var metadata = this.getProjectMetadata();\n\n        if (metadata != null) {\n            metadata.title = projectTitle;\n        }\n    }\n\n    getProjectMetadata() {\n        return this.metadata ? this.metadata : {};\n    };\n\n    getNodes() {\n        var nodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            nodes = project.nodes;\n        }\n\n        return nodes;\n    };\n\n    getPlanningNodes() {\n        var planningNodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            planningNodes = project.planningNodes;\n        }\n\n        return planningNodes;\n    };\n\n    getChildNodeIdsById(nodeId) {\n        var childIds = [];\n        var node = this.getNodeById(nodeId);\n\n        if (node.ids) {\n            childIds = node.ids;\n        }\n\n        return childIds;\n    };\n\n    getGroupNodes() {\n        return this.groupNodes;\n    };\n\n    isNode(id) {\n        var result = false;\n        var nodes = this.getNodes();\n\n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n\n                    if (nodeId === id) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    // adds or update transition if exists\n    addTransition(transition) {\n\n        var existingTransitions = this.getTransitions();\n        var replaced = false;\n        for (var t = 0; t < existingTransitions.length; t++) {\n            var existingTransition = existingTransitions[t];\n            if (existingTransition.id === transition.id) {\n                existingTransitions.splice(t, 1, transition);\n                replaced = true;\n            }\n        }\n        if (!replaced) {\n            existingTransitions.push(transition);\n        }\n    };\n\n    addNode(node) {\n        var existingNodes = this.project.nodes;\n\n        var replaced = false;\n        if (node != null && existingNodes != null) {\n            for (var n = 0; n < existingNodes.length; n++) {\n                var existingNode = existingNodes[n];\n                var existingNodeId = existingNode.id;\n                if (existingNodeId === node.id) {\n                    existingNodes.splice(n, 1, node);\n                    replaced = true;\n                }\n            }\n        }\n        if (!replaced) {\n            existingNodes.push(node);\n        }\n    };\n\n    addApplicationNode(node) {\n\n        var applicationNodes = this.applicationNodes;\n\n        if (node != null && applicationNodes != null) {\n            applicationNodes.push(node);\n        }\n    };\n\n    addGroupNode(node) {\n\n        var groupNodes = this.groupNodes;\n\n        if (node != null && groupNodes != null) {\n            groupNodes.push(node);\n        }\n\n        this.$rootScope.$broadcast('groupsChanged');\n    };\n\n    addNodeToGroupNode(groupId, nodeId) {\n        if (groupId != null && nodeId != null) {\n            var group = this.getNodeById(groupId);\n            if (group != null) {\n                var groupChildNodeIds = group.ids;\n                if (groupChildNodeIds != null) {\n                    if (groupChildNodeIds.indexOf(nodeId) === -1) {\n                        groupChildNodeIds.push(nodeId);\n                    }\n                }\n            }\n        }\n    };\n\n    isGroupNode(id) {\n        var result = false;\n\n        var groupNode = this.getNodeById(id);\n\n        if (groupNode != null) {\n            var type = groupNode.type;\n\n            if (type === 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isApplicationNode(id) {\n        var result = false;\n\n        var applicationNode = this.getNodeById(id);\n\n        if (applicationNode != null) {\n            var type = applicationNode.type;\n\n            if (type !== 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getGroups() {\n        return this.groupNodes;\n    };\n\n    loadNodes(nodes) {\n        if (nodes != null) {\n            for (var n = 0 ; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n                    var nodeType = node.type;\n                    var content = node.content;\n                    var constraints = node.constraints;\n\n                    if (content != null) {\n                        //node.content = this.injectAssetPaths(content);\n                    }\n\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n\n                    this.addNode(node);\n\n                    if (nodeType === 'group') {\n                        this.addGroupNode(node);\n                    } else {\n                        this.addApplicationNode(node);\n                    }\n\n                    var groupId = node.groupId;\n\n                    if (groupId != null) {\n                        this.addNodeToGroupNode(groupId, nodeId);\n                    }\n\n                    if (constraints != null) {\n                        for (var c = 0; c < constraints.length; c++) {\n                            var constraint = constraints[c];\n\n                            this.activeConstraints.push(constraint);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Load the planning template nodes\n     * @param planning template nodes\n     */\n    loadPlanningNodes(planningNodes) {\n        if (planningNodes != null) {\n\n            // loop through all the planning template nodes\n            for (var p = 0; p < planningNodes.length; p++) {\n                var planningNode = planningNodes[p];\n\n                if (planningNode != null) {\n                    var nodeId = planningNode.id;\n\n                    this.setIdToNode(nodeId, planningNode);\n                    this.setIdToElement(nodeId, planningNode);\n\n                    // TODO: may need to add more function calls here to add the planning\n                }\n            }\n        }\n    }\n\n    parseProject() {\n        var project = this.project;\n        if (project != null) {\n\n            // clear and initialize our project data structures\n            this.clearProjectFields();\n\n            if (project.metadata) {\n                this.metadata = project.metadata;\n            }\n\n            var nodes = project.nodes;\n            this.loadNodes(nodes);\n\n            // load the planning node templates\n            var planningNodes = project.planningNodes;\n            this.loadPlanningNodes(planningNodes);\n\n            // load the inactive nodes\n            var inactiveNodes = project.inactiveNodes;\n            this.loadInactiveNodes(inactiveNodes);\n\n            var constraints = project.constraints;\n\n            if (constraints != null) {\n                for (var c = 0; c < constraints.length; c++) {\n                    var constraint = constraints[c];\n\n                    if (constraint != null) {\n                        var constraintId = constraint.id;\n                        constraint.active = true;\n\n                        this.setIdToElement(constraintId, constraint);\n                    }\n                }\n            }\n\n            // set root node\n            this.rootNode = this.getRootNode(nodes[0].id);\n\n            // set project order\n            this.setNodeOrder(this.rootNode, this.nodeCount);\n            //this.nodeCount = 0;\n\n            var n = nodes.length;\n            var branches = this.getBranches();\n            var branchNodeIds = [];\n\n            // set node positions\n            var id, pos;\n\n            while (n--) {\n                id = nodes[n].id;\n                if (id === this.rootNode.id) {\n                    this.setIdToPosition(id, '0');\n                } else if (this.isNodeIdInABranch(branches, id)) {\n                    // node is in a branch, so process later\n                    branchNodeIds.push(id);\n                } else {\n                    pos = this.getPositionById(id);\n                    this.setIdToPosition(id, pos);\n                }\n            }\n\n            // set branch node positions\n            var b = branchNodeIds.length;\n            while (b--) {\n                id = branchNodeIds[b];\n                pos = this.getBranchNodePositionById(id);\n                this.setIdToPosition(id, pos);\n            }\n        }\n    };\n\n    setNodeOrder(node) {\n        this.idToOrder[node.id] = {'order': this.nodeCount};\n        this.nodeCount++;\n        if (this.isGroupNode(node.id)) {\n            let childIds = node.ids;\n            for (let i = 0; i < childIds.length; i++) {\n                let child = this.getNodeById(childIds[i]);\n                this.setNodeOrder(child);\n            }\n\n            if (this.ConfigService.getMode() === 'classroomMonitor') {\n                // we're viewing the classroom monitor, so include planning nodes in the project structure\n                let planningIds = node.availablePlanningNodes;\n                if (planningIds) {\n                    for (let a = 0; a < planningIds.length; a++) {\n                        let child = this.getNodeById(planningIds[a].nodeId);\n                        this.setNodeOrder(child);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getPositionById(id) {\n        for (var i = 0; i < this.rootNode.ids.length; i++) {\n            var node = this.getNodeById(this.rootNode.ids[i]);\n            var path = this.getPathToNode(node, i+1, id);\n            if (path != undefined && path != null) {\n                return path;\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Returns the order of the given node id in the project. Returns null if no node with id exists.\n     * @param id String node id\n     * @return Number order of the given node id in the project\n     */\n    getOrderById(id) {\n        if (this.idToOrder[id]) {\n            return this.idToOrder[id].order;\n        }\n\n        return null;\n    };\n    /**\n     * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n     * @param order Number\n     * @return Number node id of the given order in the project\n     */\n    getIdByOrder(order) {\n        var nodeId = null;\n\n        for (var id in this.idToOrder) {\n            if (this.idToOrder[id].order === order) {\n                if (this.isGroupNode(id) && order > 1) {\n                    nodeId = this.getIdByOrder(order-1);\n                } else {\n                    nodeId = id;\n                }\n                break;\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getBranchNodePositionById(id) {\n        var branches = this.getBranches();\n        var b = branches.length;\n\n        // TODO: should we localize this? should we support more than 26?\n        var integerToAlpha = function(int) {\n            var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n            if (int > -1 && int < 26) {\n                return alphabet[int];\n            } else {\n                return int;\n            }\n        };\n\n        while (b--) {\n            var branch = branches[b];\n            var branchPaths = branch.branchPaths;\n            for (var p = 0; p < branchPaths.length; p++) {\n                var branchPath = branchPaths[p];\n                var nodeIndex = branchPath.indexOf(id);\n                if (nodeIndex > -1) {\n                    var startPoint = branch.branchStartPoint;\n                    var startPointPos = this.idToPosition[startPoint];\n                    var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n                    return branchPathPos + (nodeIndex+1);\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n     * @param node a node to start searching down\n     * @param path the position of the given node\n     * @param id the node id to search for\n     * @return string path of the given node id in the project\n     */\n    getPathToNode(node, path, id) {\n        if (node.id === id) {\n            return path + '';\n        } else if (node.type === 'group') {\n            var num = 0;\n            var branches = this.getBranches();\n            for (var i = 0; i < node.ids.length; i++) {\n                var nodeId = node.ids[i];\n                if (this.isNodeIdInABranch(branches, nodeId)) {\n                    this.getBranchNodePositionById(nodeId);\n                } else {\n                    ++num;\n                    var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n                    if (pos) {\n                        return pos;\n                    }\n                }\n            }\n        }\n    };\n\n    setIdToPosition(id, pos) {\n        if (id != null) {\n            this.idToPosition[id] = pos;\n        }\n    };\n\n    getNodePositionById(id) {\n        let position = null;\n\n        if (id != null) {\n            position = this.idToPosition[id] ? this.idToPosition[id] : null;\n        }\n\n        return position;\n    };\n\n    getNodeIdByOrder(order) {\n        let id = null;\n\n        if (order != null) {\n            for (let [nodeId, value] of Object.entries(this.idToOrder)) {\n                if (value.order === order) {\n                    id = nodeId;\n                    break;\n                }\n            }\n        }\n\n        return id;\n    }\n\n    getNodeOrderById(id) {\n        let order = null;\n\n        if (id != null) {\n            order = this.idToOrder[id] ? this.idToOrder[id].order : null;\n        }\n\n        return order;\n    };\n\n    setIdToNode(id, element) {\n        if (id != null) {\n            this.idToNode[id] = element;\n        }\n    };\n\n    setIdToElement(id, element) {\n        if (id != null) {\n            this.idToElement[id] = element;\n        }\n    };\n\n    /**\n     * Replace relative asset paths with absolute paths\n     * e.g.\n     * assets/myimage.jpg\n     * will be replaced with\n     * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n     * @param content a string or JSON object\n     * @return the same type of object that was passed in as the content\n     * but with relative asset paths replaced with absolute paths\n     */\n    injectAssetPaths(content) {\n\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.replaceAssetPaths(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.replaceAssetPaths(content);\n            }\n        }\n\n        return content;\n    };\n\n    /**\n     * Replace the relative asset paths with absolute paths\n     * @param contentString the content string\n     * @return the content string with relative asset paths replaced\n     * with absolute asset paths\n     */\n    replaceAssetPaths(contentString) {\n\n        if (contentString != null) {\n\n            // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n            var contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n            // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n            // the string we're looking for can't start with '/ and \"/.\n            // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n            contentString = contentString.replace(\n                new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html|js)(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\n                (matchedString) => {\n                    // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n                    var delimiter = '';\n                    var matchedStringWithoutQuotes = '';\n\n                    if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\n                        // the string has escaped quotes for example \\\"hello.png\\\"\n\n                        // get everything between the escaped quotes\n                        matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\n\n                        // get the delimiter which will be \\' or \\\"\n                        delimiter = matchedString.substr(0,2);\n                    } else {\n                        // the string does not have escaped qoutes for example \"hello.png\"\n\n                        // get everything between the quotes\n                        matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\n\n                        // get the delimiter which will be ' or \"\n                        delimiter = matchedString.substr(0,1);\n                    }\n\n                    //var matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\n                    // make a new string with the contentBaseURL + assets/ prepended to the path\n                    return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\n                }\n            );\n        }\n\n        return contentString;\n    };\n\n    /**\n     * Inject the ng-click attribute that will call the snipImage function\n     * @param content the content\n     * @returns the modified content\n     */\n    injectClickToSnipImage(content) {\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.injectClickToSnipImageIntoContentString(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.injectClickToSnipImageIntoContentString(content);\n            }\n        }\n\n        return content;\n    }\n\n    /**\n     * Inject the ng-click attribute that will call the snipImage function\n     * @param contentString the content in string format\n     * @returns the modified content string\n     */\n    injectClickToSnipImageIntoContentString(contentString) {\n\n        if (contentString != null) {\n\n            // regex to match image elements\n            var imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\n\n            // replace all instances that match\n            contentString = contentString.replace(imgMatcher,\n                (matchedString, matchGroup1) => {\n\n                    /*\n                     * insert the ng-click attribute\n                     * Before: <img src=\"abc.png\"/>\n                     * After: <img ng-click=\"vleController.snipImage($event)\" src=\"abc.png\" />\n                     */\n                    var newString = matchedString.replace('img', 'img ng-click=\\\\\\\"$emit(\\'snipImage\\', $event)\\\\\\\"');\n\n                    return newString;\n                }\n            );\n        }\n\n        return contentString;\n    }\n\n    /**\n     * Returns the node specified by the nodeId\n     * Return null if nodeId param is null or the specified node does not exist in the project.\n     */\n    getNodeById(nodeId) {\n        var element = null;\n\n        if (nodeId != null && this.idToNode[nodeId]) {\n            element = this.idToNode[nodeId];\n        }\n\n        return element;\n    };\n\n    /**\n     * Returns the title of the node with the nodeId\n     * Return null if nodeId param is null or the specified node does not exist in the project.\n     */\n    getNodeTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            title = node.title;\n        }\n\n        return title;\n    };\n\n    /**\n     * Get the node position and title\n     * @param nodeId the node id\n     * @returns the node position and title, e.g. \"1.1 Introduction\"\n     */\n    getNodePositionAndTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n\n            var position = this.getNodePositionById(nodeId);\n\n            if (position != null) {\n                title = position + ': ' + node.title;\n            } else {\n                title = node.title;\n            }\n        }\n\n        return title;\n    };\n\n    getNodeIconByNodeId(nodeId) {\n        var node = this.getNodeById(nodeId);\n        var nodeIcon = null;\n\n        if (node != null) {\n            var nodeType = node.type;\n\n            // set defaults (TODO: get from configService?)\n            var defaultName = (nodeType === 'group') ? 'explore' : 'school';\n            nodeIcon = {\n                color: 'rgba(0,0,0,0.54)',\n                type: 'font',\n                fontSet: 'material-icons',\n                fontName: defaultName,\n                imgSrc: '',\n                imgAlt: 'node icon'\n            };\n\n            // TODO: check for different statuses\n            var icons = node.icons;\n            if (!!icons && !!icons.default) {\n                var icon = icons.default;\n                nodeIcon = $.extend(true, nodeIcon, icon);\n            }\n\n            // check for empty image source\n            if (!nodeIcon.imgSrc) {\n                // revert to font icon\n                nodeIcon.type = 'font';\n            }\n        }\n\n        return nodeIcon;\n    };\n\n    getParentGroup(nodeId) {\n        var result = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var groupNodes = this.getGroupNodes();\n\n                for (var g = 0; g < groupNodes.length; g++) {\n                    var groupNode = groupNodes[g];\n\n                    if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n                        result = groupNode;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the parent group id\n     * @param nodeId the parent group id\n     * @returns the parent group id\n     */\n    getParentGroupId(nodeId) {\n\n        var parentGroupId = null;\n\n        if (nodeId != null) {\n            var parentGroup = this.getParentGroup(nodeId);\n\n            if (parentGroup != null) {\n                parentGroupId = parentGroup.id;\n            }\n        }\n\n        return parentGroupId;\n    }\n\n    getNodeDepth(nodeId, val) {\n        var result = null;\n\n        if (nodeId != null) {\n            var depth = (typeof val === \"number\") ? val : 0;\n            var parent = this.getParentGroup(nodeId);\n            if (parent) {\n                depth = this.getNodeDepth(parent.id, depth + 1);\n            }\n            result = depth;\n        }\n\n        return result;\n    };\n\n    getRootNode(nodeId) {\n        var result = null;\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        if (parentGroup == null) {\n            result = this.getNodeById(nodeId);\n        } else {\n            result = this.getRootNode(parentGroup.id);\n        }\n\n        return result;\n    };\n\n    isNodeDirectChildOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var nodeId = node.id;\n            var groupIds = group.ids;\n\n            if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isNodeDescendentOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var descendents = this.getDescendentsOfGroup(group);\n            var nodeId = node.id;\n\n            if (descendents.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getDescendentsOfGroup(group) {\n        var descendents = [];\n\n        if (group != null) {\n            var childIds = group.ids;\n\n            if (childIds != null) {\n                descendents = childIds;\n\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n\n                    var node = this.getNodeById(childId);\n\n                    if (node != null) {\n                        var childDescendents = this.getDescendentsOfGroup(node);\n\n                        descendents = descendents.concat(childDescendents);\n                    }\n                }\n            }\n        }\n\n        return descendents;\n    };\n\n    isStartNode(node) {\n        var result = false;\n\n        if (node != null) {\n            var nodeId = node.id;\n\n            var projectStartId = this.getStartNodeId();\n\n            if (nodeId === projectStartId) {\n                result = true;\n            }\n\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    var groupStartId = group.startId;\n\n                    if (nodeId === groupStartId) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns the Project's start node id, or null if it's not defined in the project\n     */\n    getStartNodeId() {\n        var startNodeId = null;\n        var project = this.project;\n        if (project != null) {\n            startNodeId = project.startNodeId;\n        }\n        return startNodeId;\n    };\n\n    /**\n     * Set the start node id\n     * @param nodeId the new start node id\n     */\n    setStartNodeId(nodeId) {\n\n        if (nodeId != null) {\n            var project = this.project;\n            if (project != null) {\n                project.startNodeId = nodeId;\n            }\n        }\n    }\n\n    /**\n     * Get the start group id\n     * @return the start group id\n     */\n    getStartGroupId() {\n        var startGroupId = null;\n\n        var project = this.project;\n        if (project != null) {\n            startGroupId = project.startGroupId;\n        }\n\n        return startGroupId;\n    }\n\n    /**\n     * Check if the given node id is the start node id\n     * @return whether the node id is the start node id\n     */\n    isStartNodeId(nodeId) {\n\n        var result = false;\n\n        var project = this.project;\n\n        if (project != null) {\n            var startNodeId = project.startNodeId;\n\n            if (nodeId === startNodeId) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    getConstraintsForNode(node) {\n        var constraints = [];\n\n        var allConstraints = this.activeConstraints;\n\n        for (var c = 0; c < allConstraints.length; c++) {\n            var constraint = allConstraints[c];\n\n            if (this.isNodeAffectedByConstraint(node, constraint)) {\n                constraints.push(constraint);\n            }\n        }\n\n        return constraints;\n    };\n\n    /**\n     * Check if a node is affected by the constraint\n     * @param node check if the node is affected\n     * @param constraint the constraint that might affect the node\n     * @returns whether the node is affected by the constraint\n     */\n    isNodeAffectedByConstraint(node, constraint) {\n        var result = false;\n\n        if (node != null && constraint != null) {\n            var nodeId = node.id;\n            var targetId = constraint.targetId;\n            var action = constraint.action;\n\n            if (action === 'makeAllNodesAfterThisNotVisible') {\n                if (this.isNodeIdAfter(targetId, node.id)) {\n                    result = true;\n                }\n            } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n                if (this.isNodeIdAfter(targetId, node.id)) {\n                    result = true;\n                }\n            } else {\n                var targetNode = this.getNodeById(targetId);\n\n                if (targetNode != null) {\n                    var nodeType = targetNode.type;\n\n                    if (nodeType === 'node') {\n                        // the target is an application\n\n                        if (nodeId === targetId) {\n                            result = true;\n                        }\n                    } else if (nodeType === 'group') {\n                        // the target is a group\n\n                        if (nodeId === targetId) {\n                            result = true;\n                        }\n                        \n                        if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id comes after another node id in the project\n     * @param nodeIdBefore the node id before\n     * @param nodeIdAfter the node id after\n     */\n    isNodeIdAfter(nodeIdBefore, nodeIdAfter) {\n        var result = false;\n\n        if (nodeIdBefore != null && nodeIdAfter != null) {\n\n            if (this.isApplicationNode(nodeIdBefore)) {\n                // the node id before is a step\n\n                // get all the paths from the beforeNodeId to the end of the project\n                var pathsToEnd = this.getAllPaths([], nodeIdBefore, true);\n\n                if (pathsToEnd != null) {\n\n                    // loop through all the paths\n                    for (var p = 0; p < pathsToEnd.length; p++) {\n\n                        var pathToEnd = pathsToEnd[p];\n\n                        if (pathToEnd != null) {\n\n                            /*\n                             * remove the first node id and its parent id because\n                             * we will check the remaining node ids in the array\n                             * for the nodeIdAfter\n                             */\n\n                            // get the index of the node id before\n                            var index = pathToEnd.indexOf(nodeIdBefore);\n\n                            if (index != -1) {\n                                // remove the node id before\n                                pathToEnd.splice(index, 1);\n                            }\n\n                            // get the parent group of the node id before\n                            var parentGroup = this.getParentGroup(nodeIdBefore);\n\n                            if (parentGroup != null) {\n                                // remove the parent group of the node id before\n                                var parentGroupId = parentGroup.id;\n                                var parentGroupIndex = pathToEnd.indexOf(parentGroupId);\n                                if (parentGroupIndex != -1) {\n                                    pathToEnd.splice(parentGroupIndex, 1);\n                                }\n                            }\n\n                            if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                                // we have found the nodeIdAfter in the path to the end of the project\n                                result = true;\n                            }\n                        }\n                    }\n                }\n            } else {\n                // the node id before is an activity\n\n                // get the group\n                var group = this.getNodeById(nodeIdBefore);\n\n                if (group != null) {\n\n                    // get the transitions from the group\n                    var transitions = this.getTransitionsByFromNodeId(nodeIdBefore);\n\n                    if (transitions != null) {\n\n                        // loop through all the transitions\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                // get the paths between to toNodeId and the end of the project\n                                var pathsToEnd = this.getAllPaths([], toNodeId, true);\n\n                                // loop through all the paths\n                                for (var p = 0; p < pathsToEnd.length; p++) {\n\n                                    // get a path\n                                    var pathToEnd = pathsToEnd[p];\n\n                                    if (pathToEnd != null) {\n                                        if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                                            // we have found the nodeIdAfter in the path to the end of the project\n                                            result = true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    getNavigationMode() {\n        var navigationMode = null;\n        var project = this.project;\n        if (project != null) {\n            navigationMode = project.navigationMode;\n        }\n        return navigationMode;\n    };\n\n    getTransitions() {\n        var transitions = null;\n        var project = this.project;\n        if (project != null) {\n            transitions = project.transitions;\n        }\n        return transitions;\n    };\n\n    /**\n     * Returns all possible transition criteria for the specified node and component.\n     */\n    getPossibleTransitionCriteria(nodeId, componentId) {\n        let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n        if (component != null) {\n            let componentType = component.type;\n            let componentService = this.$injector.get(componentType + 'Service');\n            if (componentService.getPossibleTransitionCriteria) {\n                return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\n            } else {\n                return [];\n            }\n        } else {\n            return [];\n        }\n    };\n\n    /**\n     * Get the transition logic for a node\n     * @param fromNodeId the from node id\n     * @returns the transition logic object\n     */\n    getTransitionLogicByFromNodeId(fromNodeId) {\n        var transitionLogic = null;\n\n        if (fromNodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                // get the transition logic\n                transitionLogic = node.transitionLogic;\n            }\n        }\n\n        return transitionLogic;\n    };\n\n    /**\n     * Get the transitions for a node\n     * @param fromNodeId the node to get transitions from\n     * @returns an array of transitions\n     */\n    getTransitionsByFromNodeId(fromNodeId) {\n\n        var transitions = null;\n\n        if (fromNodeId != null) {\n            // get the transition logic\n            var transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\n\n            if (transitionLogic != null) {\n                // get the transitions\n                transitions = transitionLogic.transitions;\n            }\n        }\n\n        return transitions;\n    }\n\n    /**\n     * Get nodes that have a transition to the given node id\n     * @param toNodeId the node id\n     * @returns an array of node objects that transition to the\n     * given node id\n     */\n    getNodesByToNodeId(toNodeId) {\n        var nodesByToNodeId = [];\n\n        if (toNodeId != null) {\n\n            // get all the nodes\n            var nodes = this.project.nodes;\n\n            // loop through all the nodes\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        // loop through all the transitions for the node\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                if (toNodeId === transition.to) {\n                                    // this node has a transition to the node id\n                                    nodesByToNodeId.push(node);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return nodesByToNodeId;\n    };\n\n    /**\n     * Get node ids of all the nodes that have a to transition to the given node id\n     * @param toNodeId\n     * @returns all the node ids that have a transition to the given node id\n     */\n    getNodeIdsByToNodeId(toNodeId) {\n        var nodeIds = [];\n\n        // get all the nodes that transition to the toNodeId\n        var nodes = this.getNodesByToNodeId(toNodeId);\n\n        if (nodes != null) {\n\n            // loop through all the nodes to get the node ids\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    nodeIds.push(node.id);\n                }\n            }\n        }\n\n        return nodeIds;\n    }\n\n    /**\n     * Get the group nodes that point to a given node id\n     * @param toNodeId\n     */\n    getGroupNodesByToNodeId(toNodeId) {\n        var groupsThatPointToNodeId = [];\n\n        if (toNodeId != null) {\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    if (this.hasTransitionTo(group, toNodeId)) {\n                        groupsThatPointToNodeId.push(group);\n                    }\n                }\n            }\n        }\n\n        return groupsThatPointToNodeId;\n    }\n\n    /**\n     * Check if a node has a transition to a node id\n     * @param node check if this node has a transition to the node id\n     * @param toNodeId we will look for a transition to this node id\n     * @returns whether the node has a transition to the node id\n     */\n    hasTransitionTo(node, toNodeId) {\n        var result = false;\n\n        if (node != null && toNodeId != null) {\n            var transitionLogic = node.transitionLogic;\n\n            if (transitionLogic != null) {\n                var transitions = transitionLogic.transitions;\n\n                if (transitions != null) {\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n\n                        if (toNodeId === transition.to) {\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the transitions that traverse from the fromNodeId and to the toNodeId\n     * @param fromNodeId the from node id\n     * @param toNodeId the to node id\n     * @returns an array of transitions that traverse from the fromNodeId and\n     * to the toNodeId\n     */\n    getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n        var transitionsResults = [];\n\n        if (fromNodeId != null && toNodeId != null) {\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var to = transition.to;\n\n                                if (toNodeId === to) {\n                                    transitionsResults.push(transition);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    /**\n     * Retrieves the project JSON from Config.projectURL and returns it.\n     * If Config.projectURL is undefined, returns null.\n     */\n    retrieveProject() {\n        var projectURL = this.ConfigService.getConfigParam('projectURL');\n\n        if (projectURL == null) {\n            return null;\n        } else {\n            /*\n             * add a unique GET parameter value so that it always retrieves the\n             * latest version of the project file from the server and never\n             * retrieves the project from cache.\n             */\n            projectURL += '?noCache=' + (new Date()).getTime();\n        }\n\n        return this.$http.get(projectURL).then((result) => {\n            var projectJSON = result.data;\n            this.setProject(projectJSON);\n            return projectJSON;\n        });\n    };\n\n    /**\n     * Saves the project to Config.saveProjectURL and returns commit history promise.\n     * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\n     */\n    saveProject(commitMessage = \"\") {\n\n        // perform any cleanup before saving the project\n        this.cleanupBeforeSave();\n\n        var projectId = this.ConfigService.getProjectId();\n        var saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\n        if (projectId == null || saveProjectURL == null) {\n            return null;\n        }\n\n        // Get the project from this service\n        var projectJSONString = angular.toJson(this.project, 4);\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = saveProjectURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.projectId = projectId;\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSONString;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var commitHistory = result.data;\n            return commitHistory;\n        });\n    };\n\n    /**\n     * Get the current authors for this project\n     * @param projectId\n     */\n    getCurrentAuthors(projectId = null) {\n        return this.$q((resolve, reject) => {\n            if (projectId == null) {\n                if (this.project != null) {\n                    projectId = this.ConfigService.getProjectId();\n                } else {\n                    // we're not editing any projects, so there are no authors\n                    resolve([]);\n                }\n            }\n            let notifyProjectEndURL = this.ConfigService.getConfigParam('getCurrentAuthorsURL') + projectId;\n            let httpParams = {};\n            httpParams.method = 'GET';\n            httpParams.url = notifyProjectEndURL;\n\n            this.$http(httpParams).then((result) => {\n                resolve(result.data);\n            })\n        });\n    };\n\n    /**\n     * Notifies others that the specified project is being authored\n     * @param projectId id of the project\n     */\n    notifyAuthorProjectBegin(projectId = null) {\n        if (projectId == null) {\n            if (this.project != null) {\n                projectId = this.project.id;\n            } else {\n                return;\n            }\n        }\n        let notifyProjectBeginURL = this.ConfigService.getConfigParam('notifyProjectBeginURL') + projectId;\n        let httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = notifyProjectBeginURL;\n\n        return this.$http(httpParams).then((result) => {\n            let otherAuthors = result.data;\n            return otherAuthors;\n        });\n    }\n\n    /**\n     * Notifies others that the specified project is being authored\n     * @param projectId id of the project\n     */\n    notifyAuthorProjectEnd(projectId = null) {\n        return this.$q((resolve, reject) => {\n            if (projectId == null) {\n                if (this.project != null) {\n                    projectId = this.ConfigService.getProjectId();\n                } else {\n                    resolve();\n                }\n            }\n            let notifyProjectEndURL = this.ConfigService.getConfigParam('notifyProjectEndURL') + projectId;\n            let httpParams = {};\n            httpParams.method = 'POST';\n            httpParams.url = notifyProjectEndURL;\n\n            this.$http(httpParams).then(() => {\n                resolve();\n            })\n        });\n    }\n\n    /**\n     * Perform any necessary cleanup before we save the project.\n     * For example we need to remove the checked field in the inactive node\n     * objects.\n     */\n    cleanupBeforeSave() {\n        var inactiveNodes = this.project.inactiveNodes;\n\n        if (inactiveNodes != null) {\n\n            // loop through all the inactive nodes\n            for (var i = 0; i < inactiveNodes.length; i++) {\n                var inactiveNode = inactiveNodes[i];\n\n                if (inactiveNode != null) {\n                    // remove the checked field\n                    delete inactiveNode.checked;\n                }\n            }\n        }\n    }\n\n    /**\n     * Copies the project with the specified id and returns a new project id if the project is\n     * successfully copied\n     */\n    copyProject(projectId) {\n        var copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\n\n        if (copyProjectURL == null) {\n            return null;\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = copyProjectURL + \"/\" + projectId;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var projectId = result.data;\n            return projectId;\n        });\n    };\n\n    /**\n     * Registers a new project having the projectJSON content with the server.\n     * Returns a new project Id if the project is successfully registered.\n     * Returns null if Config.registerNewProjectURL is undefined.\n     * Throws an error if projectJSONString is invalid JSON string\n     */\n    registerNewProject(projectJSONString, commitMessage) {\n        var registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\n\n        if (registerNewProjectURL == null) {\n            return null;\n        }\n\n        try {\n            // Try parsing the JSON string and throw an error if there's an issue parsing it.\n            JSON.parse(projectJSONString);\n        } catch (e) {\n            throw new Error(\"Invalid projectJSONString.\");\n        }\n\n        if (!commitMessage) {\n            commitMessage = \"\";\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = registerNewProjectURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSONString;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then((result) => {\n            var projectId = result.data;\n            return projectId;\n        });\n    };\n\n    /**\n     * Retrieves and returns the project's commit history.\n     */\n    getCommitHistory() {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'GET'\n        }).then((result) => {\n            return result.data;\n        });\n    };\n\n    /**\n     * Returns the theme path for the current project\n     */\n    getThemePath() {\n        let wiseBaseURL = this.ConfigService.getWISEBaseURL();\n        let project = this.project;\n        if (project && project.theme) {\n            // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n            return wiseBaseURL + '/wise5/themes/' + project.theme;\n        } else {\n            // TODO: get default theme name from ConfigService\n            return wiseBaseURL + '/wise5/themes/default';\n        }\n    };\n\n    /**\n     * Returns the theme settings for the current project\n     */\n    getThemeSettings() {\n        let themeSettings = {};\n        let project = this.project;\n\n        if (project && project.themeSettings) {\n            if (project.theme) {\n                // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n                themeSettings = project.themeSettings[project.theme];\n            } else {\n                // TODO: get default theme name from ConfigService\n                themeSettings = project.themeSettings[\"default\"];\n            }\n        }\n\n        return themeSettings ? themeSettings : {};\n    };\n\n    /**\n     * Flatten the project to obtain a list of node ids\n     */\n    getFlattenedProjectAsNodeIds() {\n        var nodeIds = [];\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the possible paths through the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // consolidate all the paths to create a single list of node ids\n        nodeIds = this.consolidatePaths(allPaths);\n        //nodeIds = this.consolidatePaths(allPaths.reverse());\n\n        return nodeIds;\n    };\n\n    /**\n     * Get all the possible paths through the project. This function\n     * recursively calls itself to traverse the project depth first.\n     * @param pathSoFar the node ids in the path so far. the node ids\n     * in this array are referenced to make sure we don't loop back\n     * on the path.\n     * @param nodeId the node id we want to get the paths from\n     * @param includeGroups whether to include the group node ids in the paths\n     * @return an array of paths. each path is an array of node ids.\n     */\n    getAllPaths(pathSoFar, nodeId, includeGroups) {\n        var allPaths = [];\n\n        if (nodeId != null) {\n            if (this.isApplicationNode(nodeId)) {\n                // the node is an application node\n\n                var path = [];\n\n                // get all the transitions from this node\n                var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n                if (transitions != null) {\n\n                    if (includeGroups) {\n                        // get the parent group\n                        var parentGroup = this.getParentGroup(nodeId);\n                        if (parentGroup != null) {\n\n                            // get the parent group id\n                            var parentGroupId = parentGroup.id;\n\n                            if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\n                                // add the parent group id\n                                pathSoFar.push(parentGroup.id);\n                            }\n                        }\n                    }\n\n                    /*\n                     * add the node id to the path so far so we can later check\n                     * which nodes are already in the path to prevent looping\n                     * back in the path\n                     */\n                    pathSoFar.push(nodeId);\n\n                    if (transitions.length === 0) {\n                        /*\n                         * there are no transitions from the node id so we will\n                         * look for a transition in the parent group\n                         */\n\n                        var addedCurrentNodeId = false;\n\n                        var parentGroupId = this.getParentGroupId(nodeId);\n                        var parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n                        if (parentGroupTransitions != null) {\n                            for (var p = 0; p < parentGroupTransitions.length; p++) {\n                                var parentGroupTransition = parentGroupTransitions[p];\n\n                                if (parentGroupTransition != null) {\n\n                                    var toNodeId = parentGroupTransition.to;\n\n                                    if (pathSoFar.indexOf(toNodeId) == -1) {\n                                        /*\n                                         * recursively get the paths by getting all\n                                         * the paths for the to node\n                                         */\n                                        var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n\n                                            addedCurrentNodeId = true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (!addedCurrentNodeId) {\n                            /*\n                             * if the parent group doesn't have any transitions we will\n                             * need to add the current node id to the path\n                             */\n\n                            // add the node id to the path\n                            path.push(nodeId);\n\n                            // add the path to the all paths array\n                            allPaths.push(path);\n                        }\n                    } else {\n                        // there are transitions from this node id\n\n                        // loop through all the transitions from this node id\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transitionResult = [];\n\n                            // get a transition\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                // get the to node id\n                                var toNodeId = transition.to;\n\n                                if (pathSoFar.indexOf(toNodeId) == -1) {\n                                    // we have not found the to node in the path yet so we can traverse it\n\n                                    /*\n                                     * recursively get the paths by getting all\n                                     * the paths from the to node\n                                     */\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                    if (allPathsFromToNode != null) {\n                                        // loop through all the paths from the to node\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            if (includeGroups) {\n                                                // we need to add the group id to the path\n\n                                                if (tempPath.length > 0) {\n\n                                                    // get the first node id in the path\n                                                    var firstNodeId = tempPath[0];\n\n                                                    // get the parent id of the first node\n                                                    var firstParentGroupId = this.getParentGroupId(firstNodeId);\n\n                                                    // get the parent id of the current node\n                                                    var parentGroupId = this.getParentGroupId(nodeId);\n\n                                                    if (parentGroupId != firstParentGroupId) {\n                                                        /*\n                                                         * the parent ids are different which means this is a boundary\n                                                         * between two groups. for example if the project looked like\n                                                         * group1>node1>node2>group2>node3>node4\n                                                         * and the current node was node2 then the first node in the\n                                                         * path would be node3 which means we would need to place\n                                                         * group2 on the bath before node3\n                                                         */\n                                                        tempPath.unshift(firstParentGroupId);\n                                                    }\n                                                }\n                                            }\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n                                        }\n                                    }\n                                } else {\n                                    /*\n                                     * the node is already in the path so far which means\n                                     * the transition is looping back to a previous node.\n                                     * we do not want to take this transition because\n                                     * it will lead to an infinite loop. we will just\n                                     * add the current node id to the path and not take\n                                     * the transition which essentially ends the path.\n                                     */\n                                    // add the node id to the path\n                                    path.push(nodeId);\n\n                                    // add the path to the all paths array\n                                    allPaths.push(path);\n                                }\n                            }\n                        }\n                    }\n\n                    if (pathSoFar.length > 0) {\n                        // get the last node id\n                        var lastNodeId = pathSoFar[pathSoFar.length - 1];\n\n                        // check if the last node id is a group id\n                        if (this.isGroupNode(lastNodeId)) {\n                            /*\n                             * the last node id is a group id so we will remove it\n                             * since we are moving back up the path as we traverse\n                             * the nodes depth first\n                             */\n                            pathSoFar.pop();\n                        }\n                    }\n\n                    /*\n                     * remove the latest node id (this will be a step node id)\n                     * since we are moving back up the path as we traverse the\n                     * nodes depth first\n                     */\n                    pathSoFar.pop();\n                }\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n\n                /*\n                 * add the node id to the path so far so we can later check\n                 * which nodes are already in the path to prevent looping\n                 * back in the path\n                 */\n                pathSoFar.push(nodeId);\n\n                // get the group node\n                var groupNode = this.getNodeById(nodeId);\n\n                if (groupNode != null) {\n                    var startId = groupNode.startId;\n\n                    if (startId == null || startId == \"\") {\n                        // there is no start id so we will take the transition from the group\n                        // TODO? there is no start id so we will loop through all the child nodes\n\n                        // get the transitions from the group\n                        var transitions = this.getTransitionsByFromNodeId(groupNode.id);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    // get the paths from the to node to the end of the project\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                                    if (allPathsFromToNode != null) {\n                                        // loop through all the paths from the to node\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                            // get a path\n                                            var tempPath = allPathsFromToNode[a];\n\n                                            // prepend the current node id to the path\n                                            tempPath.unshift(nodeId);\n\n                                            // add the path to our collection of paths\n                                            allPaths.push(tempPath);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        // there is a start id so we will traverse it\n\n                        // get the paths from the start id to the end of the project\n                        var allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\n\n                        if (allPathsFromToNode != null) {\n                            // loop through all the paths from the to node\n                            for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                                // get a path\n                                var tempPath = allPathsFromToNode[a];\n\n                                // prepend the current node id to the path\n                                tempPath.unshift(nodeId);\n\n                                // add the path to our collection of paths\n                                allPaths.push(tempPath);\n                            }\n                        }\n                    }\n                }\n\n                /*\n                 * remove the latest node id since we are moving back\n                 * up the path as we traverse the nodes depth first\n                 */\n                pathSoFar.pop();\n            }\n        }\n\n        return allPaths;\n    };\n\n    /**\n     * Consolidate all the paths into a linear list of node ids\n     * @param paths an array of paths. each path is an array of node ids.\n     * @return an array of node ids that have been properly ordered\n     */\n    consolidatePaths(paths) {\n        var consolidatedPath = [];\n\n        if (paths != null) {\n\n            /*\n             * continue until all the paths are empty. as we consolidate\n             * node ids, we will remove them from the paths. once all the\n             * paths are empty we will be done consolidating the paths.\n             */\n            while(!this.arePathsEmpty(paths)) {\n\n                // start with the first path\n                var currentPath = this.getNonEmptyPathIndex(paths);\n\n                // get the first node id in the current path\n                var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n\n                if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                    // the first node ids in all the paths are the same\n\n                    // remove the node id from all the paths\n                    this.removeNodeIdFromPaths(nodeId, paths);\n\n                    // add the node id to our consolidated path\n                    consolidatedPath.push(nodeId);\n                } else {\n                    // not all the top node ids are the same which means we have branched\n\n                    // get all the paths that contain the node id\n                    var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n                    if (pathsThatContainNodeId != null) {\n                        if (pathsThatContainNodeId.length === 1) {\n                            // only the current path we are on has the node id\n\n                            // remove the node id from the path\n                            this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n                            // add the node id to our consolidated path\n                            consolidatedPath.push(nodeId);\n                        } else {\n                            // there are multiple paths that have this node id\n\n                            // consume all the node ids up to the given node id\n                            var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n                            // remove the node id from the paths\n                            this.removeNodeIdFromPaths(nodeId, paths);\n\n                            // add the node id to the end of the consumed path\n                            consumedPath.push(nodeId);\n\n                            // add the consumed path to our consolidated path\n                            consolidatedPath = consolidatedPath.concat(consumedPath);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        return consolidatedPath;\n    };\n\n    /**\n     * Consume the node ids in the paths until we get to the given node id\n     * @param paths the paths to consume\n     * @param nodeId the node id to stop consuming at\n     * @return an array of node ids that we have consumed\n     */\n    consumePathsUntilNodeId(paths, nodeId) {\n        var consumedNodeIds = [];\n\n        if (paths != null && nodeId != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id to stop consuming at\n                if (path != null && path.indexOf(nodeId) != -1) {\n                    /*\n                     * the path does contain the node id to stop consuming at\n                     * so we will consume the node ids in this path until\n                     * we get to the given node id to stop consuming at\n                     */\n\n                    // loop through the node ids in the path\n                    for (var x = 0; x < path.length; x++) {\n\n                        // get a node id\n                        var tempNodeId = path[x];\n\n                        if (nodeId === tempNodeId) {\n                            /*\n                             * the node id is the same as the one we need to\n                             * stop consuming at so we will stop looking\n                             * at this path\n                             */\n                            break;\n                        } else {\n                            /*\n                             * the node id is not the one that we need to stop consuming at\n                             * so we will consume it\n                             */\n\n                            // get all the paths that contain the node id\n                            var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n                            if (pathsThatContainNodeId.length === 1) {\n                                // there is only one path with this node id\n\n                                // remove the node id from the path\n                                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            } else {\n                                // there are multiple paths with this node id\n\n                                // tempNodeId must come before nodeId\n\n                                var pathsToConsume = [];\n\n                                // loop through all the paths that contain the node id\n                                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\n\n                                    // get a path that contains the node id\n                                    var pathThatContainsNodeId = pathsThatContainNodeId[g];\n\n                                    // get the index of the node id we want to remove\n                                    var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                                    // get the index of the node id we want to stop consuming at\n                                    var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                                    /*\n                                     * check if the node id we want to remove comes before\n                                     * the node id we want to stop consuming at. we need to\n                                     * do this to prevent an infinite loop. an example of\n                                     * when this can happen is if there are two paths\n                                     *\n                                     * path1 = 1, 2, 3, 4, 5\n                                     * path2 = 1, 2, 4, 3, 5\n                                     *\n                                     * as we consume path1 we will need to consume 3. in order to\n                                     * consume 3, we must consume consume up to 3 in path2.\n                                     * in order to consume up to 3 in path2 we must consume 4.\n                                     * in order to consume 4, we must consume everything before\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                                     * this means we need to consume 3 which brings us back up\n                                     * to the top of this paragraph creating an infinite loop.\n                                     *\n                                     * this check below will prevent infinite loops by only\n                                     * adding paths that have the tempNodeId come before the\n                                     * nodeId to stop consuming at.\n                                     */\n                                    if (tempNodeIdIndex < nodeIdIndex) {\n                                        pathsToConsume.push(pathThatContainsNodeId);\n                                    }\n                                }\n\n                                /*\n                                 * take the paths that contain the given node id and consume\n                                 * the paths until the given node id\n                                 */\n                                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                                // remove the node id from the paths that contain it\n                                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                                // add the temp consumed node ids to our consumed node ids array\n                                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n\n        }\n\n        return consumedNodeIds;\n    };\n\n    /**\n     * Get the path at the given index and get the first node id in\n     * the path\n     * @param paths an array of paths. each path is an array of node ids\n     * @param index the index of the path we want\n     * @return the first node in the given path\n     */\n    getFirstNodeIdInPathAtIndex(paths, index) {\n        var nodeId = null;\n\n        if (paths != null && index != null) {\n            // get the path at the given index\n            var path = paths[index];\n\n            if (path != null && path.length > 0) {\n                // get the first node id in the path\n                nodeId = path[0];\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Remove the node ifrom the paths\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     */\n    removeNodeIdFromPaths(nodeId, paths) {\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Remove the node id from the path\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     * @param pathIndex the path to remove from\n     */\n    removeNodeIdFromPath(nodeId, paths, pathIndex) {\n\n        if (nodeId != null && paths != null && pathIndex != null) {\n\n            // get the path at the given index\n            var path = paths[pathIndex];\n\n            if (path != null) {\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a ndoe id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Check if the first node ids in the paths are the same\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths have the same first node id\n     */\n    areFirstNodeIdsInPathsTheSame(paths) {\n        var result = true;\n\n        var nodeId = null;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // get the first node id in the path\n                var tempNodeId = path[0];\n\n                if (nodeId == null) {\n                    /*\n                     * this is the first path we have looked at so we will\n                     * remember the node id\n                     */\n                    nodeId = tempNodeId;\n                } else if (nodeId != tempNodeId) {\n                    /*\n                     * the node id does not match the first node id from a\n                     * previous path so the paths do not all have the same\n                     * first node id\n                     */\n                    result = false;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if all the paths are empty\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths are empty\n     */\n    arePathsEmpty(paths) {\n        var result = true;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the length of the path\n                    if (path.length !== 0) {\n                        // the path is not empty\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the paths that contain the node id\n     * @param nodeId the node id we are looking for\n     * @param paths an array of paths. each path is an array of node ids\n     * @return an array of paths that contain the given node id\n     */\n    getPathsThatContainNodeId(nodeId, paths) {\n        var pathsThatContainNodeId = [];\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id\n                if (path.indexOf(nodeId) != -1) {\n                    /*\n                     * add the path to the array of paths that contain\n                     * the node id\n                     */\n                    pathsThatContainNodeId.push(path);\n                }\n            }\n        }\n\n        return pathsThatContainNodeId;\n    };\n\n    /**\n     * Get a non empty path index. It will loop through the paths and\n     * return the index of the first non empty path.\n     * @param paths an array of paths. each path is an array of node ids\n     * @return the index of the path that is not empty\n     */\n    getNonEmptyPathIndex(paths) {\n        var index = null;\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // check the length of the path\n                if (path.length !== 0) {\n                    // the path is not empty so we will return this index\n                    index = p;\n                    break;\n                }\n            }\n        }\n\n        return index;\n    };\n\n    /**\n     * Get the branches in the project\n     */\n    getBranches() {\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the paths in the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // find the branches in the project from the paths\n        var branches = this.findBranches(allPaths);\n\n        return branches;\n    };\n\n    /**\n     * Find the branches in the project\n     * @param paths all the possible paths through the project\n     * @return an array of branch objects. each branch object contains\n     * the branch start point, the branch paths, and the branch\n     * end point\n     */\n    findBranches(paths) {\n        var branches = [];\n\n        var previousNodeId = null;\n\n        /*\n         * continue until all the paths are empty. we will remove\n         * node ids from the paths as we traverse the paths to find\n         * the branches\n         */\n        while (!this.arePathsEmpty(paths)) {\n\n            // get the first node id in the first path\n            var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n            if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                // the first node ids in all the paths are the same\n\n                // remove the node id from all the paths\n                this.removeNodeIdFromPaths(nodeId, paths);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nodeId;\n            } else {\n                // not all the top node ids are the same which means we have branched\n\n                // create a branch object\n                var branchMetaObject = this.createBranchMetaObject(previousNodeId);\n                branchMetaObject.branchStartPoint = previousNodeId;\n\n                // find the branch end point\n                var nextCommonNodeId = this.findNextCommonNodeId(paths);\n                branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n                // get the branch paths\n                var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n                branchPaths = this.removeDuplicatePaths(branchPaths);\n                branchMetaObject.branchPaths = branchPaths;\n\n                // add the branch object to our array\n                branches.push(branchMetaObject);\n\n                // trim the paths so that they start at the branch end point\n                this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nextCommonNodeId;\n            }\n        }\n\n        return branches;\n    };\n\n    /**\n     * Create a branch meta object that will contain the branch start\n     * point, branch paths, and branch end point\n     * @return an object that contains a branch start point, branch paths,\n     * and a branch end point\n     */\n    createBranchMetaObject() {\n        var branchMetaObject = {};\n\n        branchMetaObject.branchStartPoint = null;\n        branchMetaObject.branchPaths = [];\n        branchMetaObject.branchEndPoint = null;\n\n        return branchMetaObject;\n    };\n\n    /**\n     * Find the next common node id in all the paths\n     * @param paths the paths to find the common node id in\n     * @return a node id that is in all the paths or null\n     * if there is no node id that is in all the paths\n     */\n    findNextCommonNodeId(paths) {\n        var nextCommonNodeId = null;\n        var subPaths = [];\n\n        if (paths != null) {\n            if (paths.length > 0) {\n                // get the first path\n                var path = paths[0];\n\n                // loop through all the node ids in the first path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    // check if the node id is in all the paths\n                    if (this.allPathsContainNodeId(paths, tempNodeId)) {\n                        /*\n                         * the node id is in all the paths so we have found\n                         * what we were looking for\n                         */\n                        nextCommonNodeId = tempNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return nextCommonNodeId;\n    };\n\n    /**\n     * Check if all the paths contain the node id\n     * @param paths an array of paths. each path contains an array of node ids\n     * @param nodeId the node id that we will check is in all the paths\n     * @return whether the node id is in all the paths\n     */\n    allPathsContainNodeId(paths, nodeId) {\n        var result = false;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // get the index of the node id in the path\n                var index = path.indexOf(nodeId);\n\n                if (index == -1) {\n                    // the node id is not in the path\n                    result = false;\n                    break;\n                } else {\n                    // the node id is in the path\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Trim the paths up to the given node id so that the paths will contain\n     * the given node id and all the node ids after it. This function will\n     * modify the paths.\n     * @param paths the paths to trim\n     * @param nodeId the node id to trim up to\n     */\n    trimPathsUpToNodeId(paths, nodeId) {\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * trim the path to the end which will make\n                         * the path empty\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * trim the path up to the node id index. this will\n                     * modify the path array.\n                     */\n                    path.splice(0, index);\n                }\n            }\n        }\n    };\n\n\n    /**\n     * Extract the paths up to a given node id. This will be used to\n     * obtain branch paths.\n     * @param paths the paths to extract from\n     * @param nodeId the node id to extract up to\n     * @return paths that go up to but do not include the node id\n     */\n    extractPathsUpToNodeId(paths, nodeId) {\n        var extractedPaths = [];\n\n        if (paths != null) {\n            // loop through the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * extract up to the end of the path\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * get the path up to the node id index. this does\n                     * not modify the path array.\n                     */\n                    var extractedPath = path.slice(0, index);\n\n                    // add the\n                    extractedPaths.push(extractedPath);\n                }\n            }\n        }\n\n        return extractedPaths;\n    };\n\n    /**\n     * Removes duplicate paths\n     * @param paths an array of paths. each path contains an array of node ids\n     * @return an array of unique paths\n     */\n    removeDuplicatePaths(paths) {\n        var uniquePaths = [];\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                var isPathInUniquePaths = false;\n\n                // loop through all the unique paths so far\n                for (var u = 0; u < uniquePaths.length; u++) {\n                    // get a unique path\n                    var uniquePath = uniquePaths[u];\n\n                    // check if the paths are equal\n                    if (this.pathsEqual(path, uniquePath)) {\n                        // the paths are equal\n                        isPathInUniquePaths = true;\n                    }\n                }\n\n                if (!isPathInUniquePaths) {\n                    // the path is not equal to any paths in the unique\n                    // paths array so we will add it to the unique paths array\n                    uniquePaths.push(path);\n                }\n            }\n        }\n\n        return uniquePaths;\n    };\n\n    /**\n     * Check if two paths are equal\n     * @param path1 an array of node ids\n     * @param path2 an array of node ids\n     * @return whether the two paths contain the same node ids\n     * in the same order\n     */\n    pathsEqual(path1, path2) {\n        var result = false;\n\n        if (path1 != null && path2 != null) {\n\n            // check if the paths are the same length\n            if (path1.length === path2.length) {\n                result = true;\n\n                // loop through each element of the first path\n                for (var x = 0; x < path1.length; x++) {\n                    // get the node id from the first path\n                    var path1NodeId = path1[x];\n\n                    // get the node id from the second path\n                    var path2NodeId = path2[x];\n\n                    // check if the node ids are the same\n                    if (path1NodeId !== path2NodeId) {\n                        // the node ids are not the same to the paths are not equal\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id is in any branch\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return whether the node id is in any branch\n     */\n    isNodeIdInABranch(branches, nodeId) {\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branch objects\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch object\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths for this branch object\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // check if the node id is in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    // the node id is in this branch path\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Get the branch paths that a node id is in\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return an array of the branch paths that the node id is in\n     */\n    getBranchPathsByNodeId(branches, nodeId) {\n        var branchPathsIn = [];\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branches\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // get the index of the node id in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    /*\n                                     * the node is in this branch path so we will\n                                     * add the branch path to our array\n                                     */\n                                    branchPathsIn.push(branchPath);\n\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return branchPathsIn;\n    }\n\n    /**\n     * Get the component by node id and component id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\n     */\n    getComponentByNodeIdAndComponentId(nodeId, componentId) {\n        var component = null;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            // loop through all the components\n            for (var c = 0; c < components.length; c++) {\n                var tempComponent = components[c];\n\n                if (tempComponent != null) {\n                    var tempComponentId = tempComponent.id;\n\n                    if (componentId === tempComponentId) {\n                        // we have found the component we want\n                        component = tempComponent;\n                        break;\n                    }\n                }\n            }\n\n        }\n\n        return component;\n    };\n\n    /**\n     * Returns the position of the component in the node by node id and component id, 0-indexed.\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component's position or -1 if nodeId or componentId are null or doesn't exist in the project.\n     */\n    getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n        var componentPosition = -1;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            // loop through all the components\n            for (var c = 0; c < components.length; c++) {\n                var tempComponent = components[c];\n\n                if (tempComponent != null) {\n                    var tempComponentId = tempComponent.id;\n\n                    if (componentId === tempComponentId) {\n                        // we have found the component we want\n                        componentPosition = c;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return componentPosition;\n    };\n\n    /**\n     * Get the components in a node\n     * @param nodeId the node id\n     * @returns an array of components or empty array if nodeId is null or doesn't exist in the project.\n     * if the node exists but doesn't have any components, returns an empty array.\n     */\n    getComponentsByNodeId(nodeId) {\n        var components = [];\n\n        if (nodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n\n                // get the components\n                if (node.components != null) {\n                    components = node.components;\n                }\n            }\n        }\n\n        return components;\n    };\n\n    getNodeContentByNodeId(nodeId) {\n        var nodeContent = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                nodeContent = node;\n            }\n        }\n\n        return nodeContent;\n    };\n\n    /**\n     * Replace a component\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param component the new component\n     */\n    replaceComponent(nodeId, componentId, component) {\n\n        if (nodeId != null && componentId != null && component != null) {\n\n            // get all the components for the node\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n\n                        if (tempComponent.id === componentId) {\n                            // the component id matches the one we want so we will replace it\n                            components[c] = component;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Create a new group\n     * @param title the title of the group\n     * @returns the group object\n     */\n    createGroup(title) {\n\n        // get the next available group id\n        var newGroupId = this.getNextAvailableGroupId();\n\n        // create the group object\n        var newGroup = {};\n        newGroup.id = newGroupId;\n        newGroup.type = 'group';\n        newGroup.title = title;\n        newGroup.startId = '';\n        newGroup.ids = [];\n\n        return newGroup;\n    };\n\n    /**\n     * Create a new node\n     * @param title the title of the node\n     * @returns the node object\n     */\n    createNode(title) {\n\n        // get the next available node id\n        var newNodeId = this.getNextAvailableNodeId();\n\n        // create the node object\n        var newNode = {};\n        newNode.id = newNodeId;\n        newNode.title = title;\n        newNode.type = 'node';\n        newNode.constraints = [];\n        newNode.transitionLogic = {};\n        newNode.transitionLogic.transitions = [];\n\n        newNode.showSaveButton = true;\n        newNode.showSubmitButton = false;\n        newNode.components = [];\n\n        return newNode;\n    };\n\n    /**\n     * Create a node inside the group\n     * @param node the new node\n     * @param nodeId the node id of the group to create the node in\n     */\n    createNodeInside(node, nodeId) {\n        // add the node to the project\n        this.addNode(node);\n\n        // add the node to our mapping of node id to node\n        this.setIdToNode(node.id, node);\n\n        // create the transitions for the node\n        this.insertNodeInsideInTransitions(node.id, nodeId);\n\n        // add the node to the group\n        this.insertNodeInsideInGroups(node.id, nodeId);\n    }\n\n    /**\n     * Create a node after the given node id\n     * @param node the new node\n     * @param nodeId the node to add after\n     */\n    createNodeAfter(node, nodeId) {\n\n        // add the node to the project\n        this.addNode(node);\n\n        // add the node to our mapping of node id to node\n        this.setIdToNode(node.id, node);\n\n        // insert the new node id into the array of children ids\n        this.insertNodeAfterInGroups(node.id, nodeId);\n\n        // create the transition to the node\n        this.insertNodeAfterInTransitions(node, nodeId);\n\n        if (this.isGroupNode(node.id)) {\n            /*\n             * we are creating a group node so we will update/create the\n             * transitions that traverse from the previous group to this group\n             */\n\n            var oldToGroupIds = [];\n\n            // get the transitions that come out of the previous group\n            var transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\n\n            if (transitionsFromGroup != null) {\n\n                /*\n                 * loop through all the transitions that come out of the previous group\n                 * and get the node ids that the group transitions to\n                 */\n                for (var t = 0; t < transitionsFromGroup.length; t++) {\n                    var transitionFromGroup = transitionsFromGroup[t];\n\n                    if (transitionFromGroup != null) {\n                        var toNodeId = transitionFromGroup.to;\n\n                        if (toNodeId != null) {\n                            oldToGroupIds.push(toNodeId);\n                        }\n                    }\n                }\n            }\n\n            var fromGroupId = nodeId;\n            var oldToGroupIds = oldToGroupIds;\n            var newToGroupId = node.id;\n\n            /*\n             * make the transitions point to the new group and make the new\n             * group transition to the old group\n             */\n            this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\n        }\n    }\n\n    /**\n     * Insert the node after the given node id in the group's\n     * array of children ids\n     * @param nodeIdToInsert the node id we want to insert\n     * @param nodeIdToInsertAfter the node id we want to insert after\n     */\n    insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\n        var groupNodes = this.getGroupNodes();\n\n        if (groupNodes != null) {\n\n            // loop through the groups\n            for (var g = 0; g < groupNodes.length; g++) {\n                var group = groupNodes[g];\n\n                if (group != null) {\n                    var ids = group.ids;\n\n                    if (ids != null) {\n\n                        // loop through the children ids\n                        for (var i = 0; i < ids.length; i++) {\n                            var id = ids[i];\n\n                            if (nodeIdToInsertAfter === id) {\n                                // we have found the node id we want to insert after\n\n                                // insert the new node id\n                                ids.splice(i + 1, 0, nodeIdToInsert);\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the transitions to handle inserting a node after another node\n     * @param node the node to insert\n     * @param nodeId the node id to insert after\n     */\n    insertNodeAfterInTransitions(node, nodeId) {\n\n        // get the node that will end up before\n        var previousNode = this.getNodeById(nodeId);\n\n        if (previousNode != null) {\n\n            if (previousNode.transitionLogic == null) {\n                previousNode.transitionLogic = {};\n                previousNode.transitionLogic.transitions = [];\n            }\n\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            if (this.isGroupNode(node.id)) {\n                /*\n                 * the node we are inserting is a group so we will update\n                 * the transitions of its children so that they transition\n                 * to the correct node\n                 */\n                this.updateChildrenTransitionsForMovingGroup(node, nodeId);\n            }\n\n            var previousNodeTransitionLogic = previousNode.transitionLogic;\n\n            if (previousNodeTransitionLogic != null) {\n\n                // get the transitions from the before node\n                var transitions = previousNodeTransitionLogic.transitions;\n\n                if (transitions != null) {\n\n                    // make a copy of the transitions\n                    var transitionsJSONString = angular.toJson(transitions);\n                    var transitionsCopy = angular.fromJson(transitionsJSONString);\n\n                    // set the transitions from the before node into the inserted node\n                    node.transitionLogic.transitions = transitionsCopy;\n                }\n            }\n\n            if (node.transitionLogic.transitions.length == 0) {\n                /*\n                 * The node does not have any transitions so we will look for\n                 * a transition on the parent group. If the parent has a\n                 * transition we will use it for the node.\n                 */\n\n                // get the parent group\n                var parentGroupId = this.getParentGroupId(nodeId);\n\n                // get the parent transitions\n                var parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n                if (parentTransitions != null) {\n\n                    // loop through all the parent transitions\n                    for (var p = 0; p < parentTransitions.length; p++) {\n                        var parentTransition = parentTransitions[p];\n\n                        var newTransition = {};\n\n                        if (parentTransition != null) {\n                            var toNodeId = parentTransition.to;\n\n                            if (this.isGroupNode(toNodeId)) {\n                                // the transition is to a group\n\n                                // get the start id of the group\n                                var startId = this.getGroupStartId(toNodeId);\n\n                                if (startId == null || startId == '') {\n                                    // there is no start id so we will just use the group id\n                                    newTransition.to = toNodeId;\n                                } else {\n                                    // there is a start id so we will use it as the to node\n                                    newTransition.to = startId;\n                                }\n                            } else {\n                                // the tranisition is to a step\n                                newTransition.to = toNodeId;\n                            }\n                        }\n\n                        // add the new transition to the node\n                        node.transitionLogic.transitions.push(newTransition);\n                    }\n                }\n            }\n\n            var newNodeId = node.id;\n\n            // TODO handle branching case\n\n            // remove the transitions from the before node\n            previousNode.transitionLogic.transitions = [];\n\n            var transitionObject = {};\n            transitionObject.to = newNodeId;\n\n            // make the before node point to the new node\n            previousNode.transitionLogic.transitions.push(transitionObject);\n        }\n    }\n\n    /**\n     * Insert a node into a group\n     * @param nodeIdToInsert the node id to insert\n     * @param nodeIdToInsertInside the node id of the group we will insert into\n     */\n    insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\n\n        // get the group we will insert into\n        var group = this.getNodeById(nodeIdToInsertInside);\n\n        if (group != null) {\n            var ids = group.ids;\n\n            if (ids != null) {\n\n                // insert the node node id into the beginning of the child ids\n                ids.splice(0, 0, nodeIdToInsert);\n\n                // set the inserted node id as the start id\n                group.startId = nodeIdToInsert;\n            }\n        }\n    }\n\n    /**\n     * Update the transitions to handle inserting a node into a group\n     * @param nodeIdToInsert node id that we will insert\n     * @param nodeIdToInsertInside the node id of the group we are inserting into\n     */\n    insertNodeInsideInTransitions(nodeIdToInsert, nodeIdToInsertInside) {\n\n        // get the node we are inserting\n        var nodeToInsert = this.getNodeById(nodeIdToInsert);\n\n        // get the group we are inserting into\n        var group = this.getNodeById(nodeIdToInsertInside);\n\n        if (this.isGroupNode(nodeIdToInsert)) {\n            /*\n             * the node we are inserting is a group so we will update\n             * the transitions of its children so that they transition\n             * to the correct node\n             */\n            this.updateChildrenTransitionsForMovingGroup(nodeToInsert, null);\n        }\n\n        /*\n         * since we are inserting a node into a group, the node will become\n         * the first node in the group. this means we need to update any nodes\n         * that point to the old start id and make them point to the node\n         * we are inserting.\n         */\n        if (nodeToInsert != null && group != null) {\n\n            // get the start node\n            var startId = group.startId;\n\n            // get transitions that point to the start node\n            var previousNodes = this.getNodesByToNodeId(startId);\n\n            if (previousNodes == null || previousNodes.length == 0) {\n                // there are no transitions to the start node\n\n                // find all the groups that point to this group\n                var previousGroups = this.getGroupNodesByToNodeId(nodeIdToInsertInside);\n\n                // loop through all the groups that point to this group\n                for (var g = 0; g < previousGroups.length; g++) {\n                    var previousGroup = previousGroups[g];\n\n                    if (previousGroup != null) {\n                        // get the nodes that do not have a transition in the previous group\n                        var lastNodesInGroup = this.getLastNodesInGroup(previousGroup.id);\n\n                        for (var n = 0; n < lastNodesInGroup.length; n++) {\n                            // get a node that does not have a transition\n                            var node = lastNodesInGroup[n];\n\n                            // add a transition from the node to the node we are inserting\n                            this.addToTransition(node, nodeIdToInsert);\n                        }\n                    }\n                }\n            } else {\n                // there are transitions to the start node\n\n                for (var p = 0; p < previousNodes.length; p++) {\n                    var previousNode = previousNodes[p];\n\n                    if (previousNode != null) {\n                        // change the transition to point to the node we are inserting\n                        this.updateToTransition(previousNode, startId, nodeIdToInsert);\n                    }\n                }\n            }\n\n            /*\n             * update all the transitions that point to the group and change\n             * them to point to the new start id\n             */\n            var nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\n\n            if (nodesThatTransitionToGroup != null) {\n                for (var n = 0; n < nodesThatTransitionToGroup.length; n++) {\n                    var nodeThatTransitionsToGroup = nodesThatTransitionToGroup[n];\n\n                    if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\n                        this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\n                    }\n                }\n            }\n\n            /*\n             * create a transition from the node we are inserting to the node that\n             * was previously the start node\n             */\n            if (startId != null && startId != '') {\n                // there is a start id\n\n                var startNode = this.getNodeById(startId);\n\n                if (startNode != null) {\n                    // the group has a start node which will become the transition to node\n\n                    if (nodeToInsert.transitionLogic == null) {\n                        nodeToInsert.transitionLogic = {};\n                    }\n\n                    if (nodeToInsert.transitionLogic.transitions == null) {\n                        nodeToInsert.transitionLogic.transitions = [];\n                    }\n\n                    /*\n                     * make the inserted node transition to the previous start node\n                     */\n                    var transitionObject = {};\n                    transitionObject.to = startId;\n                    nodeToInsert.transitionLogic.transitions.push(transitionObject);\n                }\n            }\n\n            //check if the node we inserted has any transitions now\n            var transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\n\n            if (transitions == null || transitions.length == 0) {\n                /*\n                 * the node doesn't have any transitions so we will see if\n                 * the parent group transitions to anything and use that\n                 * transition\n                 */\n\n                // get the transitions from the parent\n                var parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\n\n                if (parentTransitions != null) {\n\n                    // loop through all the parent transitions\n                    for (var t = 0; t < parentTransitions.length; t++) {\n                        var parentTransition = parentTransitions[t];\n\n                        if (parentTransition != null) {\n                            var toNodeId = parentTransition.to;\n\n                            if (this.isGroupNode(toNodeId)) {\n                                // the to node is a group\n\n                                // get the to group\n                                var nextGroup = this.getNodeById(toNodeId);\n\n                                if (nextGroup != null) {\n\n                                    // get the start id of the to group\n                                    var startId = nextGroup.startId;\n\n                                    if (startId == null || startId == '') {\n                                        // there is no start id so we will just transition to the group\n                                        this.addToTransition(nodeToInsert, toNodeId);\n                                    } else {\n                                        // there is a start id so we will transition to that\n                                        this.addToTransition(nodeToInsert, startId);\n                                    }\n                                }\n                            } else {\n                                // the to node is not a group\n\n                                /*\n                                 * we will add a transition from the node we are inserting to\n                                 * to that node\n                                 */\n                                this.addToTransition(nodeToInsert, toNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add a transition to a node\n     * @param node the node we are adding a transition to\n     * @param toNodeId the node id we going to transition to\n     * @param criteria (optional) a criteria object specifying\n     * what needs to be satisfied in order to use this transition\n     */\n    addToTransition(node, toNodeId, criteria) {\n        if (node != null) {\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            var transition = {};\n\n            // set the to node id\n            transition.to = toNodeId;\n\n            if (criteria != null) {\n                // set the criteria\n                transition.criteria = criteria;\n            }\n\n            // add the transition to the node's transitions\n            node.transitionLogic.transitions.push(transition);\n        }\n    }\n\n    /**\n     * Update the to value of aa transition\n     * @param node the node to update\n     * @param oldToNodeId the previous to node id\n     * @param newToNodeId the new to node id\n     */\n    updateToTransition(node, oldToNodeId, newToNodeId) {\n        if (node != null) {\n            if (node.transitionLogic == null) {\n                node.transitionLogic = {};\n            }\n\n            if (node.transitionLogic.transitions == null) {\n                node.transitionLogic.transitions = [];\n            }\n\n            var transitions = node.transitionLogic.transitions;\n\n            // loop through all the transitions\n            for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                    var toNodeId = transition.to;\n\n                    if (oldToNodeId === toNodeId) {\n                        // we have found the transition we want to update\n\n                        // update the to node id\n                        transition.to = newToNodeId;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the nodes in a group that do not have transitions\n     * @param groupId the group id\n     * @returns the nodes in the group that do not have transitions\n     */\n    getLastNodesInGroup(groupId) {\n        var lastNodes = [];\n\n        if (groupId != null) {\n            var group = this.getNodeById(groupId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n\n                    // loop through all the child ids\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n\n                        if (childId != null) {\n                            var child = this.getNodeById(childId);\n\n                            if (child != null) {\n                                var transitionLogic = child.transitionLogic;\n\n                                if (transitionLogic != null) {\n\n                                    // get the transitions\n                                    var transitions = transitionLogic.transitions;\n\n                                    if (transitions == null || transitions.length == 0) {\n                                        // this child does not have any transitions\n                                        lastNodes.push(child);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return lastNodes;\n    }\n\n    /**\n     * Get the next available group id\n     * @returns the next available group id\n     */\n    getNextAvailableGroupId() {\n\n        // get all the group ids\n        var groupIds = this.getGroupIds();\n\n        var largestGroupIdNumber = null;\n\n        // loop through all the existing group ids\n        for (var g = 0; g < groupIds.length; g++) {\n            var groupId = groupIds[g];\n\n            // get the number from the group id e.g. the number of 'group2' would be 2\n            var groupIdNumber = groupId.replace('group', '');\n\n            // make sure the number is an actual number\n            if (!isNaN(groupIdNumber)) {\n\n                groupIdNumber = parseInt(groupIdNumber);\n\n                // update the largest group id number if necessary\n                if (largestGroupIdNumber == null) {\n                    largestGroupIdNumber = groupIdNumber;\n                } else if (groupIdNumber > largestGroupIdNumber) {\n                    largestGroupIdNumber = groupIdNumber;\n                }\n            }\n        }\n\n        // create the next available group id\n        var nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\n\n        return nextAvailableGroupId;\n    }\n\n    /**\n     * Get all the group ids\n     * @returns an array with all the group ids\n     */\n    getGroupIds() {\n\n        var groupIds = [];\n\n        var groupNodes = this.groupNodes;\n\n        // loop through all the group nodes\n        for (var g = 0; g < groupNodes.length; g++) {\n            var group = groupNodes[g];\n\n            if (group != null) {\n                var groupId = group.id;\n\n                if (groupId != null) {\n                    // add the group id\n                    groupIds.push(groupId);\n                }\n            }\n        }\n\n        return groupIds;\n    }\n\n    /**\n     * Get the next available node id\n     * @returns the next available node id\n     */\n    getNextAvailableNodeId() {\n\n        // get all the node ids\n        var nodeIds = this.getNodeIds();\n\n        var largestNodeIdNumber = null;\n\n        // loop through all the existing node ids\n        for (var n = 0; n < nodeIds.length; n++) {\n            var nodeId = nodeIds[n];\n\n            // get the number from the node id e.g. the number of 'node2' would be 2\n            var nodeIdNumber = nodeId.replace('node', '');\n\n            // make sure the number is an actual number\n            if (!isNaN(nodeIdNumber)) {\n                nodeIdNumber = parseInt(nodeIdNumber);\n\n                // update the largest node id number if necessary\n                if (largestNodeIdNumber == null) {\n                    largestNodeIdNumber = nodeIdNumber;\n                } else if (nodeIdNumber > largestNodeIdNumber) {\n                    largestNodeIdNumber = nodeIdNumber;\n                }\n            }\n        }\n        \n        // get all the inactive node ids\n        var inactiveNodeIds = this.getInactiveNodeIds();\n        \n        for (var i = 0; i < inactiveNodeIds.length; i++) {\n            var inactiveNodeId = inactiveNodeIds[i];\n            \n            // get the number from the node id e.g. the number of 'node2' would be 2\n            var nodeIdNumber = inactiveNodeId.replace('node', '');\n\n            // make sure the number is an actual number\n            if (!isNaN(nodeIdNumber)) {\n                nodeIdNumber = parseInt(nodeIdNumber);\n\n                // update the largest node id number if necessary\n                if (largestNodeIdNumber == null) {\n                    largestNodeIdNumber = nodeIdNumber;\n                } else if (nodeIdNumber > largestNodeIdNumber) {\n                    largestNodeIdNumber = nodeIdNumber;\n                }\n            }\n        }\n\n        // create the next available node id\n        var nextAvailableNodeId = 'node' + (largestNodeIdNumber + 1);\n\n        return nextAvailableNodeId;\n    }\n\n    /**\n     * Get all the node ids from steps (not groups)\n     * @returns an array with all the node ids\n     */\n    getNodeIds() {\n\n        var nodeIds = [];\n\n        var nodes = this.applicationNodes;\n\n        // loop through all the nodes\n        for (var n = 0; n < nodes.length; n++) {\n            var node = nodes[n];\n\n            if (node != null) {\n                var nodeId = node.id;\n\n                if (nodeId != null) {\n                    nodeIds.push(nodeId);\n                }\n            }\n        }\n\n        return nodeIds;\n    }\n    \n    /**\n     * Get all the node ids from inactive steps\n     * @returns an array with all the inactive node ids\n     */\n    getInactiveNodeIds() {\n        \n        var nodeIds = [];\n        \n        var inactiveNodes = this.inactiveNodes;\n        \n        if (inactiveNodes != null) {\n            \n            // loop through all the inactive nodes\n            for (var n = 0; n < inactiveNodes.length; n++) {\n                var inactiveNode = inactiveNodes[n];\n                \n                if (inactiveNode != null) {\n                    var nodeId = inactiveNode.id;\n                    \n                    if (nodeId != null) {\n                        nodeIds.push(nodeId);\n                    }\n                }\n            }\n        }\n        \n        return nodeIds;\n    }\n\n    /**\n     * Move nodes inside a group node\n     * @param nodeIds the node ids to move\n     * @param nodeId the node id of the group we are moving the nodes inside\n     */\n    moveNodesInside(nodeIds, nodeId) {\n\n        // loop thorugh all the nodes we are moving\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are moving\n            var tempNodeId = nodeIds[n];\n            var tempNode = this.getNodeById(tempNodeId);\n\n            var movingNodeIsActive = this.isActive(tempNodeId);\n            var stationaryNodeIsActive = this.isActive(nodeId);\n\n            if (movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from active to active\n\n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the group\n                this.removeNodeIdFromGroups(tempNodeId);\n\n                if (n == 0) {\n                    /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\n                } else {\n                    /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\n                }\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from active to inactive\n\n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the group\n                this.removeNodeIdFromGroups(tempNodeId);\n\n                // move the node to the inactive array\n                this.moveToInactive(tempNode, nodeId);\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from inactive to active\n\n                this.moveToActive(tempNode);\n\n                if (n == 0) {\n                    /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\n                } else {\n                    /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\n                }\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from inactive to inactive\n\n                // move the node within the inactive nodes\n                this.moveInactiveNode(tempNode, nodeId);\n            }\n\n            /*\n             * remember the node id so we can put the next node (if any)\n             * after this one\n             */\n            nodeId = tempNode.id;\n        }\n    }\n\n    /**\n     * Move nodes after a certain node id\n     * @param nodeIds the node ids to move\n     * @param nodeId the node id we will put the moved nodes after\n     */\n    moveNodesAfter(nodeIds, nodeId) {\n\n        // loop through all the nodes we are moving\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are moving\n            var tempNodeId = nodeIds[n];\n            var node = this.getNodeById(tempNodeId);\n\n            var movingNodeIsActive = this.isActive(tempNodeId);\n            var stationaryNodeIsActive = this.isActive(nodeId);\n\n            if (movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from active to active\n\n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the groups\n                this.removeNodeIdFromGroups(tempNodeId);\n\n                // insert the node into the parent group\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n                // create the transition\n                this.insertNodeAfterInTransitions(node, nodeId);\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from active to inactive\n\n                // remove the transitions\n                this.removeNodeIdFromTransitions(tempNodeId);\n\n                // remove the node from the groups\n                this.removeNodeIdFromGroups(tempNodeId);\n\n                // move the node to the inactive array\n                this.moveToInactive(node, nodeId);\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n                // we are moving from inactive to active\n\n                // move the node to the active nodes array\n                this.moveToActive(node);\n\n                // insert the node into the parent group\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n                // create the transition\n                this.insertNodeAfterInTransitions(node, nodeId);\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n                // we are moving from inactive to inactive\n\n                // move the node within the inactive nodes\n                this.moveInactiveNode(node, nodeId);\n            }\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = node.id;\n        }\n    }\n\n    /**\n     * Copy nodes and put them after a certain node id\n     * @param nodeIds the node ids to copy\n     * @param nodeId the node id we will put the copied nodes after\n     */\n    copyNodesInside(nodeIds, nodeId) {\n        // loop through all the nodes we are copying\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are copying\n            var nodeIdToCopy = nodeIds[n];\n\n            // create a copy of the node\n            var newNode = this.copyNode(nodeIdToCopy);\n            var newNodeId = newNode.id;\n\n            if (n == 0) {\n                // this is the first node we are copying so we will insert it\n                // into the beginning of the group\n                this.createNodeInside(newNode, nodeId);\n            } else {\n                // this is not the first node we are copying so we will insert\n                // it after the node we previously inserted\n                this.createNodeAfter(newNode, nodeId);\n            }\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = newNodeId;\n            this.parseProject();  // refresh project and update references because a new node have been added.\n        }\n    }\n\n    /**\n     * Copy nodes and put them after a certain node id\n     * @param nodeIds the node ids to copy\n     * @param nodeId the node id we will put the copied nodes after\n     */\n    copyNodesAfter(nodeIds, nodeId) {\n        // loop through all the nodes we are copying\n        for (var n = 0; n < nodeIds.length; n++) {\n\n            // get the node we are copying\n            var nodeIdToCopy = nodeIds[n];\n\n            // create a copy of the node\n            var newNode = this.copyNode(nodeIdToCopy);\n            var newNodeId = newNode.id;\n\n            this.createNodeAfter(newNode, nodeId);\n\n            // remember the node id so we can put the next node (if any) after this one\n            nodeId = newNodeId;\n            this.parseProject();  // refresh project and update references because a new node have been added.\n        }\n    }\n\n    /**\n     * Copy the node with the specified nodeId\n     * @param nodeId the node id to copy\n     * @return copied node\n     */\n    copyNode(nodeId) {\n        var node = this.getNodeById(nodeId);\n\n        var nodeCopy = JSON.parse(JSON.stringify(node));\n        nodeCopy.id = this.getNextAvailableNodeId();\n        nodeCopy.transitionLogic = {};  // clear transition logic\n        nodeCopy.constraints = [];  // clear constraints\n        for (var c = 0; c < nodeCopy.components.length; c++) {\n            var component = nodeCopy.components[c];\n            var componentType = component.type;\n            // get the service for the node type\n            var service = this.$injector.get(componentType + 'Service');\n            // copy the component\n            var componentCopy = service.copyComponent(component);\n            if (component.maxScore != null) {\n                // Also copy the max score if exists in original node\n                componentCopy.maxScore = component.maxScore;\n            }\n            if (component.showPreviousWorkPrompt != null) {\n                // Also copy the showPreviousWorkPrompt if exists in original node\n                componentCopy.showPreviousWorkPrompt = component.showPreviousWorkPrompt;\n            }\n            if (component.showPreviousWorkNodeId != null) {\n                // Also copy the showPreviousWorkNodeId if exists in original node\n                componentCopy.showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n            }\n            if (component.showPreviousWorkComponentId != null) {\n                // Also copy the showPreviousWorkComponentId if exists in original node\n                componentCopy.showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n            }\n\n            nodeCopy.components[c] = componentCopy;\n        }\n        return nodeCopy;\n    }\n\n    /**\n     * Delete a node\n     * @param nodeId the node id\n     */\n    deleteNode(nodeId) {\n\n        if (this.isGroupNode(nodeId)) {\n            // the node is a group node so we will also remove all of its children\n            var group = this.getNodeById(nodeId);\n\n            // TODO check if the child is in another group, if so do not remove\n\n            if (group != null) {\n                var ids = group.ids;\n\n                // loop through all the children\n                for (var i = 0; i < ids.length; i++) {\n                    var id = ids[i];\n\n                    // remove the child\n                    this.removeNodeIdFromTransitions(id);\n                    this.removeNodeIdFromGroups(id);\n                    this.removeNodeIdFromNodes(id);\n\n                    /*\n                     * move the counter back because we have removed a child\n                     * from the parent group's array of child ids so all of\n                     * the child ids were shifted back one and the next child\n                     * we want will be at i--\n                     */\n                    i--;\n                }\n            }\n        }\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        // check if we need to update the start id of the parent group\n        if (parentGroup != null) {\n\n            /*\n             * the node is the start node of the parent group so we need\n             * to update the start id of the parent group to point to\n             * the next node\n             */\n            if (nodeId === parentGroup.startId) {\n\n                var hasSetNewStartId = false;\n\n                // get the node\n                var node = this.getNodeById(nodeId);\n\n                if (node != null) {\n                    var transitionLogic = node.transitionLogic;\n\n                    if (transitionLogic != null) {\n                        var transitions = transitionLogic.transitions;\n\n                        if (transitions != null && transitions.length > 0) {\n                            var transition = transitions[0];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                if (toNodeId != null) {\n\n                                    // check that the to node is in the same group\n                                    if (this.isNodeInGroup(toNodeId, parentGroup.id)) {\n\n                                        // update the parent group start id\n                                        parentGroup.startId = toNodeId;\n                                        hasSetNewStartId = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (!hasSetNewStartId) {\n                    parentGroup.startId = '';\n                }\n            }\n        }\n\n        // remove the node\n        this.removeNodeIdFromTransitions(nodeId);\n        this.removeNodeIdFromGroups(nodeId);\n        this.removeNodeIdFromNodes(nodeId);\n\n        if (parentGroup != null) {\n            this.recalculatePositionsInGroup(parentGroup.id);\n        }\n    }\n\n    /**\n     * Update the transitions to handle removing a node\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromTransitions(nodeId) {\n\n        // get the node we are removing\n        var nodeToRemove = this.getNodeById(nodeId);\n\n        // get all the nodes that have a transition to the node we are removing\n        var nodesByToNodeId = this.getNodesByToNodeId(nodeId);\n\n        // get the transitions of the node we are removing\n        var nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\n        var nodeToRemoveTransitions = [];\n\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n            nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n        }\n\n        var parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\n\n        var parentGroup = this.getNodeById(parentIdOfNodeToRemove);\n\n        // update the start id if we are removing the start node of a group\n        if (parentGroup != null) {\n            var parentGroupStartId = parentGroup.startId;\n\n            if (parentGroupStartId != null) {\n                if (parentGroupStartId === nodeId) {\n                    // the node we are removing is the start node\n\n                    if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\n\n                        // loop through all the transitions from the node to choose a new start id\n                        for (var t = 0; t < nodeToRemoveTransitions.length; t++) {\n                            var nodeToRemoveTransition = nodeToRemoveTransitions[t];\n\n                            if (nodeToRemoveTransition != null) {\n                                var toNodeId = nodeToRemoveTransition.to;\n\n                                if (toNodeId != null) {\n                                    /*\n                                     * we need to check that the to node id is in the\n                                     * same group. some transitions point to a node id\n                                     * in the next group which we would not want to use\n                                     * for the start id.\n                                     */\n                                    if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\n\n                                        // set the new start id\n                                        parentGroup.startId = toNodeId;\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        // there are no transitions so we will have an empty start id\n                        parentGroup.startId = '';\n                    }\n                }\n            }\n        }\n\n        // loop through all the nodes that transition to the node we are removing\n        for (var n = 0; n < nodesByToNodeId.length; n++) {\n\n            // get a node that has a transition to the node we are removing\n            var node = nodesByToNodeId[n];\n\n            if (node != null) {\n                var parentIdOfFromNode = this.getParentGroupId(node.id);\n\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    // loop through all the transitions of this node\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n\n                        if (nodeId === transition.to) {\n                            // we have found the transition to the node we are removing\n\n                            // copy the transitions from the node we are removing\n                            var transitionsCopy = angular.toJson(nodeToRemoveTransitions);\n                            transitionsCopy = angular.fromJson(transitionsCopy);\n\n                            /*\n                             * if the parent from group is different than the parent removing group\n                             * remove transitions that are to a node in a different group than\n                             * the parent removing group\n                             */\n\n                            if (parentIdOfFromNode != parentIdOfNodeToRemove) {\n\n                                for (var tc = 0; tc < transitionsCopy.length; tc++) {\n                                    var tempTransition = transitionsCopy[tc];\n\n                                }\n                                if (tempTransition != null) {\n                                    var tempToNodeId = tempTransition.to;\n\n                                    if (tempToNodeId != null) {\n                                        var parentIdOfToNode = this.getParentGroupId(tempToNodeId);\n\n                                        if (parentIdOfNodeToRemove != parentIdOfToNode) {\n                                            // remove the transition\n\n                                            transitionsCopy.splice(tc, 1);\n                                            tc--;\n                                        }\n                                    }\n                                }\n                            }\n\n                            // remove the transition to the node we are removing\n                            transitions.splice(t, 1);\n\n                            // insert the transitions from the node we are removing\n                            transitions = transitions.concat(transitionsCopy);\n\n                            // check if the node we are moving is a group\n                            if (this.isGroupNode(nodeId)) {\n                                /*\n                                 * we are moving a group so we need to update transitions that\n                                 * go into the group\n                                 */\n                                var groupIdWeAreMoving = nodeId;\n                                var groupThatTransitionsToGroupWeAreMoving = node;\n                                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\n                            }\n                        }\n                    }\n\n                    // set the transitions into the node that transitions to the node we are removing\n                    transitionLogic.transitions = transitions;\n                }\n            }\n        }\n\n        if (nodeToRemoveTransitionLogic != null) {\n            // clear the transitions of the node we are removing\n            nodeToRemoveTransitionLogic.transitions = [];\n        }\n\n        if (this.isGroupNode(nodeId)) {\n            /*\n             * this is a group node so we will remove all child transitions that\n             * go out of this group\n             */\n\n            //this.removeTransitionsIntoGroup(nodeId);\n            this.removeTransitionsOutOfGroup(nodeId);\n        }\n    };\n\n    /**\n     * Remove the node id from a group\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromGroups(nodeId) {\n\n        var groups = this.groupNodes;\n\n        if (groups != null) {\n\n            // loop through all the groups\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n\n                    // get the start id of the group\n                    var startId = group.startId;\n\n                    // get the child ids of the group\n                    var ids = group.ids;\n\n                    // loop through all the child ids\n                    for (var i = 0; i < ids.length; i++) {\n                        var id = ids[i];\n\n                        if (nodeId === id) {\n                            // we have found the node id we want to remove\n                            ids.splice(i, 1);\n\n                            if (nodeId === startId) {\n                                /*\n                                 * the node id is also the start id so we will get the\n                                 * next node id and set it as the new start id\n                                 */\n\n                                var hasSetNewStartId = false;\n\n                                // get the node we are removing\n                                var node = this.getNodeById(id);\n\n                                if (node != null) {\n                                    var transitionLogic = node.transitionLogic;\n\n                                    if (transitionLogic != null) {\n                                        var transitions = transitionLogic.transitions;\n\n                                        if (transitions != null && transitions.length > 0) {\n\n                                            // get the first transition\n                                            // TODO handle the case when the node we are removing is a branch point\n                                            var transition = transitions[0];\n\n                                            if (transition != null) {\n                                                // get the node that this node transitions to\n                                                var to = transition.to;\n\n                                                if (to != null) {\n                                                    // set the to node as the start id\n                                                    group.startId = to;\n                                                    hasSetNewStartId = true;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n\n                                if (!hasSetNewStartId) {\n                                    /*\n                                     * the node we are removing did not have a transition\n                                     * so there will be no start id\n                                     */\n                                    group.startId = '';\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove the node from the array of nodes\n     * @param nodeId the node id to remove\n     */\n    removeNodeIdFromNodes(nodeId) {\n\n        // get all the nodes in the project\n        var nodes = this.project.nodes;\n\n        // loop through all the nodes\n        for (var n = 0; n < nodes.length; n++) {\n            var node = nodes[n];\n\n            if (node != null) {\n                if (nodeId === node.id) {\n                    // we have found the node we want to remove\n                    nodes.splice(n, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove the node from the inactive nodes array\n     * @param nodeId the node to remove from the inactive nodes array\n     */\n    removeNodeIdFromInactiveNodes(nodeId) {\n\n        // get the inactive nodes array\n        var inactiveNodes = this.project.inactiveNodes;\n\n        if (inactiveNodes != null) {\n\n            // loop through the inactive nodes\n            for (var i = 0; i < inactiveNodes.length; i++) {\n                var inactiveNode = inactiveNodes[i];\n\n                if (inactiveNode != null) {\n                    var inactiveNodeId = inactiveNode.id;\n\n                    if (nodeId === inactiveNodeId) {\n                        /*\n                         * we have found the node we are looking for so we will\n                         * remove it\n                         */\n                        inactiveNodes.splice(i, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a new component\n     * @param nodeId the node id to create the component in\n     * @param componentType the component type\n     */\n    createComponent(nodeId, componentType) {\n\n        if (nodeId != null && componentType != null) {\n            // get the node we will create the component in\n            var node = this.getNodeById(nodeId);\n\n            // get the service for the node type\n            var service = this.$injector.get(componentType + 'Service');\n\n            if (node != null && service != null) {\n\n                // create the new component\n                var component = service.createComponent();\n\n                // add the component to the node\n                this.addComponentToNode(node, component);\n            }\n        }\n    }\n\n    /**\n     * Add the component to the node\n     * @param node the node\n     * @param component the component\n     */\n    addComponentToNode(node, component) {\n\n        if (node != null && component != null) {\n            node.components.push(component);\n        }\n    }\n\n    /**\n     * Move the component up within the node\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    moveComponentUp(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to move\n\n                            /*\n                             * make sure this is not the first component because\n                             * the first component can't be moved up\n                             */\n                            if (c != 0) {\n                                // this is not the first component\n\n                                // remove the component\n                                components.splice(c, 1);\n\n                                // put the component back in at the position one index back\n                                components.splice(c - 1, 0, component);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Move the component down within the node\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    moveComponentDown(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to move\n\n                            /*\n                             * make sure this is not the last component because\n                             * the last component can't be moved down\n                             */\n                            if (c != components.length - 1) {\n                                // this is not the last component\n\n                                // remove the component\n                                components.splice(c, 1);\n\n                                // put the component back in at the position one index ahead\n                                components.splice(c + 1, 0, component);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Delete the component\n     * @param nodeId the node id\n     * @param componentId the component id\n     */\n    deleteComponent(nodeId, componentId) {\n        if (nodeId != null && componentId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var components = node.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component.id === componentId) {\n                            // we have found the component we want to delete\n\n                            // remove the component\n                            components.splice(c, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the max score for the project\n     * @returns the max score for the project or null if none of the components in the project\n     * has max scores.\n     */\n    getMaxScore() {\n\n        var maxScore = null;\n\n        var nodes = this.project.nodes;\n\n        if (nodes != null) {\n\n            // loop through all the nodes\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeMaxScore = this.getMaxScoreForNode(node.id);\n\n                    if (nodeMaxScore != null) {\n                        if (maxScore == null) {\n                            maxScore = nodeMaxScore;\n                        } else {\n                            maxScore += nodeMaxScore;\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxScore;\n    }\n\n    /**\n     * Get the max score for the node\n     * @param nodeId the node id\n     * @returns the max score for the node\n     */\n    getMaxScoreForNode(nodeId) {\n        var maxScore = null;\n\n        // get the node\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            var components = node.components;\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var component = components[c];\n\n                    if (component != null) {\n\n                        // get the max score for the component\n                        var componentMaxScore = component.maxScore;\n\n                        // check if the component has a max score\n                        if (componentMaxScore != null) {\n\n                            // make sure the max score is a valid number\n                            if (!isNaN(componentMaxScore)) {\n\n                                if (maxScore == null) {\n                                    maxScore = componentMaxScore;\n                                } else {\n                                    // accumulate the max score\n                                    maxScore += componentMaxScore;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxScore;\n    }\n\n    /**\n     * Get the max score for a component\n     * @param nodeId get the max score from a component in this node\n     * @param componentId get the max score from this component\n     */\n    getMaxScoreForComponent(nodeId, componentId) {\n        var maxScore = null;\n\n        var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n        if (component != null) {\n            maxScore = component.maxScore;\n        }\n\n        return maxScore;\n    }\n\n    /**\n     * Determine if a node id is a direct child of a group\n     * @param nodeId the node id\n     * @param groupId the group id\n     */\n    isNodeInGroup(nodeId, groupId) {\n\n        var result = false;\n\n        var group = this.getNodeById(groupId);\n\n        var childIds = group.ids;\n\n        if (childIds != null) {\n            if (childIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the first leaf node by traversing all the start ids\n     * until a leaf node id is found\n     */\n    getFirstLeafNodeId() {\n\n        var firstLeafNodeId = null;\n\n        // get the start group id\n        var startGroupId = this.project.startGroupId;\n\n        // get the start group node\n        var node = this.getNodeById(startGroupId);\n\n        var done = false;\n\n        // loop until we have found a leaf node id or something went wrong\n        while (!done) {\n\n            if (node == null) {\n                done = true;\n            } else if (this.isGroupNode(node.id)) {\n                // set the first leaf node id to the group id for now\n                firstLeafNodeId = node.id;\n\n                // the current node is a group\n                node = this.getNodeById(node.startId);\n            } else if (this.isApplicationNode(node.id)) {\n                // the current node is a leaf\n                firstLeafNodeId = node.id;\n                done = true;\n            } else {\n                done = true;\n            }\n        }\n\n        return firstLeafNodeId;\n    }\n\n    /**\n     * Replace a node. This is used when we want to revert a node back to a\n     * previous version in the authoring tool.\n     * @param nodeId the node id\n     * @param node the node object\n     */\n    replaceNode(nodeId, node) {\n\n        if (nodeId != null && node != null) {\n\n            // set the id to node mapping\n            this.setIdToNode(nodeId, node);\n\n            // set the id to element mapping\n            this.setIdToElement(nodeId, node);\n\n            // update the nodes array\n            var nodes = this.getNodes();\n\n            if (nodes != null) {\n\n                for (var n = 0; n < nodes.length; n++) {\n                    var tempNode = nodes[n];\n\n                    if (tempNode != null) {\n                        var tempNodeId = tempNode.id;\n\n                        if (nodeId === tempNodeId) {\n                            // we have found the node we want to replace\n                            nodes.splice(n, 1, node);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // update the application nodes array\n            var applicationNodes = this.applicationNodes;\n\n            if (applicationNodes != null) {\n                for (var a = 0; a < applicationNodes.length; a++) {\n                    var tempApplicationNode = applicationNodes[a];\n\n                    if (tempApplicationNode != null) {\n                        var tempApplicationNodeId = tempApplicationNode.id;\n\n                        if (nodeId === tempApplicationNodeId) {\n                            // we have found the node we want to replace\n                            applicationNodes.splice(a, 1, node);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if a node is a planning node\n     * @param nodeId the node id\n     * @returns whether the node is a planning node\n     */\n    isPlanning(nodeId) {\n        var result = false;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                if (node.planning) {\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Check if a node is a planning node instance\n     * @param nodeId the node id\n     * @returns whether the node is a planning node instance\n     */\n    isPlanningInstance(nodeId) {\n        var result = false;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node.planningNodeTemplateId) {\n                result = true;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the available planning node ids for a node\n     * @param nodeId the node we want available planning nodes for\n     * @returns an array of available planning node ids\n     */\n    getAvailablePlanningNodeIds(nodeId) {\n        var availablePlanningNodeIds = [];\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null && node.availablePlanningNodeIds != null) {\n                availablePlanningNodeIds = node.availablePlanningNodeIds;\n            }\n        }\n\n        return availablePlanningNodeIds;\n    }\n\n    /**\n     * Get the available planning nodes for a given group\n     * @param nodeId the node id of the group\n     * @returns an array of planning node templates\n     */\n    getAvailablePlanningNodes(nodeId) {\n        var availablePlanningNodesSoFar = [];\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null && node.availablePlanningNodes != null) {\n                let availablePlanningNodes = node.availablePlanningNodes;\n\n                // loop through all the nodes and retrieve the actual node\n                for (var a = 0; a < availablePlanningNodes.length; a++) {\n                    var availablePlanningNode = availablePlanningNodes[a];\n\n                    if (availablePlanningNode != null) {\n\n                        // get the node\n                        var availablePlanningNodeActual = this.getNodeById(availablePlanningNode.nodeId);\n\n                        if (availablePlanningNodeActual != null) {\n                            if (availablePlanningNode.max != null) {\n                                availablePlanningNodeActual.max = availablePlanningNode.max;\n                            }\n                            availablePlanningNodesSoFar.push(availablePlanningNodeActual);\n                        }\n                    }\n                }\n            }\n        }\n\n        return availablePlanningNodesSoFar;\n    }\n\n    /**\n     * Create a planning node instance and add it to the project\n     * @param groupId the group id to add the planning node instance to\n     * @param nodeId the node id of the planning node template\n     */\n    createPlanningNodeInstance(groupId, nodeId, nextAvailablePlanningNodeId) {\n\n        var planningNodeInstance = null;\n\n        if (nodeId != null && nextAvailablePlanningNodeId != null) {\n            // get the planning node template\n            var node = this.getNodeById(nodeId);\n\n            // create a planning node instance by copying the planning node template\n            planningNodeInstance = this.copyNode(nodeId);\n\n            // set the template id to point back to the planning template node\n            planningNodeInstance.planningNodeTemplateId = nodeId;\n\n            // set the planning node instance node id\n            planningNodeInstance.id = nextAvailablePlanningNodeId;\n        }\n\n        return planningNodeInstance;\n    }\n\n    /**\n     * Add a planning node instance inside a group node\n     * @param nodeIdToInsertInside the group id to insert into\n     * @param planningNodeInstance the planning node instance to add\n     */\n    addPlanningNodeInstanceInside(nodeIdToInsertInside, planningNodeInstance) {\n        // get the node id\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n        // add an entry in our mapping data structures of node id to object\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n        // add the node to the nodes array in the project\n        this.addNode(planningNodeInstance);\n\n        // update the transitions\n        this.insertNodeInsideInTransitions(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n        // update the child ids of the group\n        this.insertNodeInsideInGroups(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n        // recalculate all the position values in the group\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Add a planning node instance after a node\n     * @param nodeIdToInsertAfter the node to insert after\n     * @param planningNodeInstance the planning node instance to add\n     */\n    addPlanningNodeInstanceAfter(nodeIdToInsertAfter, planningNodeInstance) {\n        // get the node id\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n        // add an entry in our mapping data structures of node id to object\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n        // add the node to the nodes array in the project\n        this.addNode(planningNodeInstance);\n\n        // update the transitions\n        this.insertNodeAfterInTransitions(planningNodeInstance, nodeIdToInsertAfter);\n\n        // update the child ids of the group\n        this.insertNodeAfterInGroups(planningNodeInstanceNodeId, nodeIdToInsertAfter);\n\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n        if (parentGroup != null) {\n            var parentGroupId = parentGroup.id;\n\n            // recalculate all the position values in the group\n            this.recalculatePositionsInGroup(parentGroupId);\n        }\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Move a planning node instance inside a group\n     * @param nodeIdToMove the node to move\n     * @param nodeIdToInsertInside the group to move the node into\n     */\n    movePlanningNodeInstanceInside(nodeIdToMove, nodeIdToInsertInside) {\n\n        // move the node inside the group node\n        this.moveNodesInside([nodeIdToMove], nodeIdToInsertInside);\n\n        // recalculate all the position values in the group\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Move a planning node instance after a node\n     * @param nodeIdToMove the node to move\n     * @param nodeIdToInsertAfter the other node to move the node after\n     */\n    movePlanningNodeInstanceAfter(nodeIdToMove, nodeIdToInsertAfter) {\n\n        // move the node after the other node\n        this.moveNodesAfter([nodeIdToMove], nodeIdToInsertAfter);\n\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n        if (parentGroup != null) {\n            var parentGroupId = parentGroup.id;\n\n            // recalculate all the position values in the group\n            this.recalculatePositionsInGroup(parentGroupId);\n        }\n\n        /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n        this.setNodeOrder(this.rootNode, 0);\n    }\n\n    /**\n     * Recalculate the positions of the children in the group.\n     * The positions are the numbers usually seen before the title\n     * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\n     * is the position\n     * @param groupId recalculate all the children of this group\n     */\n    recalculatePositionsInGroup(groupId) {\n\n        if (groupId != null) {\n            let childIds = this.getChildNodeIdsById(groupId);\n\n            // loop through all the children\n            for (let c = 0; c < childIds.length; c++) {\n                let childId = childIds[c];\n\n                // calculate the position of the child id\n                let pos = this.getPositionById(childId);\n\n                // set the mapping of node id to position\n                this.setIdToPosition(childId, pos);\n            }\n        }\n    }\n\n    /**\n     * Get the message that describes how to disable the constraint\n     * @param nodeId the node the student is trying to go to\n     * @param constraint the constraint that is preventing the student\n     * from going to the node\n     * @returns the message to display to the student that describes how\n     * to disable the constraint\n     */\n    getConstraintMessage(nodeId, constraint) {\n\n        var message = '';\n\n        if (nodeId != null && constraint != null) {\n\n            // get the node title the student is trying to go to\n            var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n\n            var removalConditional = constraint.removalConditional;\n            var removalCriteria = constraint.removalCriteria;\n\n            if (removalConditional === 'any') {\n                message += 'To visit \"' + nodeTitle + '\" you must perform one of the actions below:<br/>';\n            } else {\n                message += 'To visit \"' + nodeTitle + '\" you must perform all of the actions below:<br/>';\n            }\n\n            if (removalCriteria != null) {\n\n                var criteriaMessages = '';\n\n                // loop through all the criteria\n                for (var x = 0; x < removalCriteria.length; x++) {\n                    var tempRemovalCriteria = removalCriteria[x];\n\n                    if (tempRemovalCriteria != null) {\n\n                        // get the message that describes the criteria that needs to be satisfied\n                        var criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\n\n                        if (criteriaMessage != null && criteriaMessage != '') {\n                            // separate criteria messages with a line break\n                            if (criteriaMessages != '') {\n                                criteriaMessages += '<br/>';\n                            }\n                            criteriaMessages += criteriaMessage;\n                        }\n                    }\n                }\n\n                message += criteriaMessages;\n            }\n        }\n\n        return message;\n    }\n\n    /**\n     * Get the message that describes how to satisfy the criteria\n     * TODO: check if the criteria is satisfied\n     * @param criteria the criteria object that needs to be satisfied\n     * @returns the message to display to the student that describes how to\n     * satisfy the criteria\n     */\n    getCriteriaMessage(criteria) {\n        var message = '';\n\n        if (criteria != null) {\n            var name = criteria.name;\n            var params = criteria.params;\n\n            if (name === 'isCompleted') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Complete \"' + nodeTitle + '\"';\n                }\n            } else if (name === 'isVisited') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Visit \"' + nodeTitle + '\"';\n                }\n            } else if (name === 'choiceChosen') {\n\n            } else if (name === 'branchPathTaken') {\n\n            } else if (name === 'isPlanningActivityCompleted') {\n                var nodeId = params.nodeId;\n                if (nodeId != null) {\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n                    message += 'Complete \"' + nodeTitle + '\"';\n                }\n            }\n        }\n\n        return message;\n    }\n\n    /**\n     * Get the start id of a group\n     * @param nodeId get the start id of this group\n     * @returns the start id of the group\n     */\n    getGroupStartId(nodeId) {\n\n        var startId = null;\n\n        if (nodeId != null) {\n\n            // get the group\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                // get the start id\n                startId = node.startId;\n            }\n        }\n\n\n        return startId;\n    }\n\n    /**\n     * Get the start id of the node's parent group\n     * @param nodeId we will get the parent of this node and then look\n     * for the start id of the parent\n     * @returns the start id of the parent\n     */\n    getParentGroupStartId(nodeId) {\n        var parentGroupStartId = null;\n\n        if (nodeId != null) {\n            var parentGroup = this.getParentGroup(nodeId);\n\n            if (parentGroup != null) {\n                parentGroupStartId = parentGroup.startId;\n            }\n        }\n\n        return parentGroupStartId;\n    }\n\n    /**\n     * Update the transitions so that the fromGroup points to the newToGroup\n     *\n     * Before\n     * fromGroup -> oldToGroup -> newToGroup\n     *\n     * After\n     * fromGroup -> newToGroup\n     * oldToGroup becomes dangling and has no transitions to or from it\n     */\n    updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\n\n        /*\n         * make the transitions\n         * fromGroup -> newToGroup\n         */\n        if (fromGroupId != null && oldToGroupId != null) {\n            var fromGroup = this.getNodeById(fromGroupId);\n            var oldToGroup = this.getNodeById(oldToGroupId);\n            var newToGroup = null;\n            var newToGroupStartId = null;\n\n            if (newToGroupId != null) {\n                newToGroup = this.getNodeById(newToGroupId);\n            }\n\n            if (newToGroup != null) {\n                newToGroupStartId = newToGroup.startId;\n            }\n\n            if (fromGroup != null && oldToGroup != null) {\n                var childIds = fromGroup.ids;\n\n                // update the children of the from group to point to the new to group\n                if (childIds != null) {\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        var child = this.getNodeById(childId);\n                        var transitions = this.getTransitionsByFromNodeId(childId);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the from group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    if (toNodeId === oldToGroupId) {\n                                        // the transition is to the group\n                                        if (newToGroupId == null && newToGroupStartId == null) {\n                                            // there is no new to group so we will remove the transition\n                                            transitions.splice(t, 1);\n                                            t--;\n                                        } else {\n                                            // make the transition point to the new to group\n                                            transition.to = newToGroupId;\n                                        }\n                                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                                        // the transition is to a node in the group\n                                        if (newToGroupId == null && newToGroupStartId == null) {\n                                            // there is no new to group so we will remove the transition\n                                            transitions.splice(t, 1);\n                                            t--;\n                                        } else if (newToGroupStartId == null || newToGroupStartId == '') {\n                                            // make the transition point to the new to group\n                                            transition.to = newToGroupId;\n                                        } else {\n                                            // make the transition point to the new group start id\n                                            transition.to = newToGroupStartId;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * remove the transitions from the oldToGroup\n         */\n        if (oldToGroupId != null && newToGroupId != null) {\n\n            var oldToGroup = this.getNodeById(oldToGroupId);\n\n            if (oldToGroup != null) {\n                var childIds = oldToGroup.ids;\n\n                // remove the transitions from the old to group that point to the new to group\n                if (childIds != null) {\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n                        var child = this.getNodeById(childId);\n                        var transitions = this.getTransitionsByFromNodeId(childId);\n\n                        if (transitions != null) {\n\n                            // loop through all the transitions from the old to group\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    var toNodeId = transition.to;\n\n                                    if (toNodeId === newToGroupId) {\n                                        // the transition is to the group so we will remove it\n                                        transitions.splice(t, 1);\n                                        t--;\n                                    } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\n                                        // the transition is to a node in the group so we will remove it\n                                        transitions.splice(t, 1);\n                                        t--;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the transitions so that the fromGroup points to the newToGroup\n     *\n     * Before\n     * fromGroup -> oldToGroup\n     * newToGroup is dangling and has no transitions to or from it\n     *\n     * After\n     * fromGroup -> newToGroup -> oldToGroup\n     */\n    updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\n\n        var fromGroup = null;\n        var newToGroup = null;\n\n        if (fromGroupId != null) {\n            fromGroup = this.getNodeById(fromGroupId);\n        }\n\n        if (newToGroupId != null) {\n            newToGroup = this.getNodeById(newToGroupId);\n        }\n\n        /*\n         * make the transitions that point to the old group now point\n         * to the new group\n         * fromGroup -> newToGroup\n         */\n        if (fromGroup != null && newToGroup != null) {\n            var childIds = fromGroup.ids;\n            var newToGroupStartId = newToGroup.startId;\n\n            if (childIds != null) {\n\n                // loop through all the nodes in the from group\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n                    var child = this.getNodeById(childId);\n\n                    // get the transitions from the child\n                    var transitions = this.getTransitionsByFromNodeId(childId);\n\n                    if (transitions == null || transitions.length == 0) {\n                        /*\n                         * the child does not have any transitions so we will make it\n                         * point to the new group\n                         */\n                        if (newToGroupStartId == null || newToGroupStartId == '') {\n                            this.addToTransition(child, newToGroupId);\n                        } else {\n                            this.addToTransition(child, newToGroupStartId)\n                        }\n                    } else if (transitions != null) {\n\n                        // loop through all the transitions from the child\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var toNodeId = transition.to;\n\n                                if (oldToGroupIds != null) {\n\n                                    /*\n                                     * loop through all the old to group ids to find transitions\n                                     * to the old to group\n                                     */\n                                    for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                                        var oldToGroupId = oldToGroupIds[ot];\n\n                                        if (toNodeId === oldToGroupId) {\n                                            /*\n                                             * the transition is to the group so we will update the transition\n                                             * to the new group\n                                             */\n                                            transition.to = newToGroupId;\n                                        } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                                            /*\n                                             * the transition is to a node in the old group so we will update\n                                             * the transition to point to the new group\n                                             */\n                                            if (newToGroupStartId == null || newToGroupStartId == '') {\n                                                transition.to = newToGroupId;\n                                            } else {\n                                                transition.to = newToGroupStartId;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * make the steps that do not have a transition now point to the old\n         * group\n         * newToGroup -> oldToGroup\n         */\n        if (newToGroup != null) {\n            var childIds = newToGroup.ids;\n\n            if (childIds != null) {\n\n                // loop through all the children in the new group\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n                    var child = this.getNodeById(childId);\n\n                    // get the transitions for the child\n                    var transitions = this.getTransitionsByFromNodeId(childId);\n\n                    if (transitions == null || transitions.length == 0) {\n\n                        if (oldToGroupIds != null) {\n\n                            // loop through all the old groups\n                            for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                                var oldToGroupId = oldToGroupIds[ot];\n                                var oldToGroup = this.getNodeById(oldToGroupId);\n\n                                if (oldToGroup != null) {\n\n                                    var oldToGroupStartId = oldToGroup.startId;\n\n                                    var transition = {};\n\n                                    var toNodeId = '';\n\n                                    if (oldToGroupStartId == null) {\n                                        // there is no start node id so we will just point to the group\n                                        toNodeId = oldToGroup;\n                                    } else {\n                                        // there is a start node id so we will point to it\n                                        toNodeId = oldToGroupStartId;\n                                    }\n\n                                    // create the transition from the child to the old group\n                                    this.addToTransition(child, toNodeId);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Update the child transitions because we are moving a group. We will\n     * update the transitions into and out of the group in the location\n     * we are extracting the group from and also in the location we are\n     * inserting the group into.\n     * @param node the group we are moving\n     * @param nodeId we will put the group after this node id\n     */\n    updateChildrenTransitionsForMovingGroup(node, nodeId) {\n        var transitionsBefore = null;\n\n        // get the group nodes that point to the group we are moving\n        var previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\n\n        // get all the transitions from the group we are moving\n        var transitionsAfter = this.getTransitionsByFromNodeId(node.id);\n\n        var extracted = false;\n\n        /*\n         * extract the group we are moving by updating the transitions of the\n         * from group and the new to group. also remove the transitions from the\n         * group we are moving.\n         */\n\n        // loop through all the groups that point to the group we are moving\n        for (var p = 0; p < previousGroupNodes.length; p++) {\n            var previousGroupNode = previousGroupNodes[p];\n\n            if (transitionsAfter == null || transitionsAfter.length == 0) {\n                // the group we are moving does not have any transitions\n\n                /*\n                 * remove the transitions to the group we are moving and make\n                 * new transitions from the from group to the new to group\n                 */\n                this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\n                extracted = true;\n            } else {\n                // the group we are moving has transitions\n\n                // make the previous group point to the new to group\n                for (var t = 0; t < transitionsAfter.length; t++) {\n                    var transitionAfter = transitionsAfter[t];\n\n                    if (transitionAfter != null) {\n                        var toNodeId = transitionAfter.to;\n\n                        /*\n                         * remove the transitions to the group we are moving and make\n                         * new transitions from the from group to the new to group\n                         */\n                        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\n                        extracted = true;\n                    }\n                }\n            }\n        }\n\n        if (!extracted) {\n            /*\n             * we have not removed the transitions yet because the group\n             * we are moving does not have any groups before it\n             */\n\n            // remove the transitions from the group we are moving\n            for (var t = 0; t < transitionsAfter.length; t++) {\n                var transitionAfter = transitionsAfter[t];\n\n                if (transitionAfter != null) {\n                    var toNodeId = transitionAfter.to;\n\n                    // remove the transitions to the group we are moving\n                    this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\n                    extracted = true;\n                }\n            }\n        }\n\n        var inserted = false;\n\n        /*\n         * create the transitions from the from group to the group we are moving\n         * and the transitions from the group we are moving to the old to group\n         */\n        if (nodeId != null) {\n            // get the transitions from the previous group to the next group\n            var transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\n\n            for (var t = 0; t < transitionsAfter.length; t++) {\n                var transitionAfter = transitionsAfter[t];\n\n                if (transitionAfter != null) {\n                    var toNodeId = transitionAfter.to;\n\n                    /*\n                     * create the transitions that traverse from the from group\n                     * to the group we are moving. also create the transitions\n                     * that traverse from the group we are moving to the old\n                     * to group.\n                     */\n                    this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\n                    inserted = true;\n                }\n            }\n        }\n\n        if (!inserted) {\n            /*\n             * we have not inserted the transitions yet because there were no\n             * previous group transitions\n             */\n\n            if (nodeId == null) {\n                /*\n                 * the previous node id is null which means there was no previous\n                 * group. this means the group we are inserting will become the\n                 * first group. this happens when the group we are moving\n                 * is moved inside the root (group0).\n                 */\n\n                var startGroupId = this.getStartGroupId();\n\n                if (startGroupId != null) {\n\n                    // get the start group for the whole project (group0)\n                    var startGroup = this.getNodeById(startGroupId);\n\n                    if (startGroup != null) {\n\n                        // get the first activity\n                        var firstGroupId = startGroup.startId;\n\n                        /*\n                         * create the transitions that traverse from the group\n                         * we are moving to the previous first activity.\n                         */\n                        this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\n                    }\n                }\n\n            } else {\n                /*\n                 * we have not inserted the group yet because the from group doesn't\n                 * have a group after it\n                 */\n\n                /*\n                 * create the transitions that traverse from the from group\n                 * to the group we are moving.\n                 */\n                this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\n            }\n        }\n    }\n\n    /**\n     * Check if a component is a connected component\n     * @param nodeId the node id of the component\n     * @param componentId the component that is listening for connected changes\n     * @param connectedComponentId the component that is broadcasting connected changes\n     * @returns whether the componentId is connected to the connectedComponentId\n     */\n    isConnectedComponent(nodeId, componentId, connectedComponentId) {\n\n        var result = false;\n\n        // get the component\n        var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n        if (component != null) {\n\n            var connectedComponents = component.connectedComponents;\n\n            if (connectedComponents != null) {\n\n                // loop through all the connected components\n                for (var c = 0; c < connectedComponents.length; c++) {\n                    var connectedComponent = connectedComponents[c];\n\n                    if (connectedComponent != null) {\n                        if (connectedComponentId === connectedComponent.id) {\n                            // we have found the connected component id we are looking for\n                            result = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get a connected component params\n     * @param componentId the connected component id\n     * @returns the params for the connected component\n     */\n    getConnectedComponentParams(componentContent, componentId) {\n\n        var connectedComponentParams = null;\n\n        if (componentContent != null && componentId != null) {\n\n            // get the connected components\n            var connectedComponents = componentContent.connectedComponents;\n\n            if (connectedComponents != null) {\n\n                // loop through all the connected components\n                for (var c = 0; c < connectedComponents.length; c++) {\n                    var connectedComponent = connectedComponents[c];\n\n                    if (connectedComponent != null) {\n                        var tempComponentId = connectedComponent.id;\n\n                        if (componentId === tempComponentId) {\n                            // we have found the connected component we are looking for\n                            connectedComponentParams = connectedComponent;\n                        }\n                    }\n                }\n            }\n        }\n\n        return connectedComponentParams;\n    }\n\n    /**\n     * Get the inactive groups\n     * @returns the inactive groups\n     */\n    getInactiveGroups() {\n        var inactiveGroups = [];\n\n        if (this.project != null) {\n\n            if (this.project.inactiveGroups == null) {\n                this.project.inactiveGroups = [];\n            }\n\n            inactiveGroups = this.project.inactiveGroups;\n        }\n\n        return inactiveGroups;\n    }\n\n    /**\n     * Get the inactive nodes\n     * @returns the inactive nodes\n     */\n    getInactiveNodes() {\n        var inactiveNodes = [];\n\n        if (this.project != null) {\n\n            if (this.project.inactiveNodes == null) {\n                this.project.inactiveNodes = [];\n            }\n\n            inactiveNodes = this.project.inactiveNodes;\n        }\n\n        return inactiveNodes;\n    }\n\n    /**\n     * Remove the node from the active nodes\n     * @param nodeId the node to remove\n     * @returns the node that we have removed\n     */\n    removeNodeFromActiveNodes(nodeId) {\n        var node = null;\n\n        if (nodeId != null) {\n\n            // get the active nodes\n            var activeNodes = this.project.nodes;\n\n            if (activeNodes != null) {\n\n                // loop through all the active nodes\n                for (var a = 0; a < activeNodes.length; a++) {\n                    var activeNode = activeNodes[a];\n\n                    if (activeNode != null) {\n                        if (nodeId === activeNode.id) {\n                            // we have found the node we want to remove\n                            node = activeNode;\n\n                            // remove the node from the array\n                            activeNodes.splice(a, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Remove the node from the inactive nodes array\n     * @param nodeId the node to remove\n     * @returns the node that was removed\n     */\n    removeNodeFromInactiveNodes(nodeId) {\n        var node = null;\n\n        if (nodeId != null) {\n\n            // get all the inactive nodes\n            var inactiveNodes = this.project.inactiveNodes;\n\n            if (inactiveNodes != null) {\n\n                // loop through all the inactive nodes\n                for (var i = 0; i < inactiveNodes.length; i++) {\n                    var inactiveNode = inactiveNodes[i];\n\n                    if (inactiveNode != null) {\n                        if (nodeId === inactiveNode.id) {\n                            // we have found the node we want to remove\n                            node = inactiveNode;\n\n                            // remove the node from the array\n                            inactiveNodes.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * Load the inactive nodes\n     * @param nodes the inactive nodes\n     */\n    loadInactiveNodes(nodes) {\n\n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n\n                    // set the node into the mapping data structures\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n                    \n                    this.inactiveNodes.push(node);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if the node is active\n     * @param nodeId the node to check\n     * @returns whether the node is in the active array\n     */\n    isActive(nodeId) {\n\n        var result = true;\n\n        if (nodeId != null) {\n\n            if (nodeId === 'inactiveNodes') {\n                // this occurs when the author puts a step into the inactive nodes\n                result = false;\n            } else if (nodeId === 'inactiveGroups') {\n                // this occurs when the author puts a group into the inactive groups\n                result = false;\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n                // TODO: implement this\n            } else {\n                // the node is a step node\n\n                // get the inactive nodes\n                var inactiveNodes = this.project.inactiveNodes;\n\n                if (inactiveNodes != null) {\n\n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n\n                        if (inactiveNode != null) {\n                            if (nodeId === inactiveNode.id) {\n                                // we have found the node in the inactive nodes\n                                result = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Move the node to the active nodes array\n     */\n    moveToActive(node) {\n        if (node != null) {\n\n            // make sure the node is inactive\n            if (!this.isActive(node.id)) {\n                // the node is inactive so we will move it to the active array\n\n                // remove the node from inactive nodes array\n                this.removeNodeFromInactiveNodes(node.id);\n\n                // add the node to the active array\n                this.addNode(node);\n            }\n        }\n    }\n\n    /**\n     * Move the node to the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    moveToInactive(node, nodeIdToInsertAfter) {\n        if (node != null) {\n\n            // make sure the node is active\n            if (this.isActive(node.id)) {\n                // the node is active so we will move it to the inactive array\n\n                // remove the node from the active array\n                this.removeNodeFromActiveNodes(node.id);\n\n                // add the node to the inactive array\n                this.addInactiveNode(node, nodeIdToInsertAfter);\n            }\n        }\n    }\n\n    /**\n     * Add the node to the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    addInactiveNode(node, nodeIdToInsertAfter) {\n        if (node != null) {\n            var inactiveNodes = this.project.inactiveNodes;\n\n            if (inactiveNodes != null) {\n\n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps') {\n                    // put the node at the beginning of the inactive steps\n                    inactiveNodes.splice(0, 0, node);\n                } else {\n                    // put the node after one of the inactive nodes\n\n                    var added = false;\n\n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n\n                        if (inactiveNode != null) {\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\n                                // we have found the position to place the node\n                                inactiveNodes.splice(i + 1, 0, node);\n                                added = true;\n                            }\n                        }\n                    }\n\n                    if (!added) {\n                        /*\n                         * we haven't added the node yet so we will just add it\n                         * to the end of the array\n                         */\n                        inactiveNodes.push(node);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Move an inactive node within the inactive nodes array\n     * @param node the node to move\n     * @param nodeIdToInsertAfter place the node after this\n     */\n    moveInactiveNode(node, nodeIdToInsertAfter) {\n\n        if (node != null) {\n            var inactiveNodes = this.project.inactiveNodes;\n\n            if (inactiveNodes != null) {\n\n                // remove the node from inactive nodes\n\n                // loop through all the inactive nodes\n                for (var i = 0; i < inactiveNodes.length; i++) {\n                    var inactiveNode = inactiveNodes[i];\n\n                    if (inactiveNode != null) {\n                        if (node.id === inactiveNode.id) {\n                            // we have found the node we want to remove\n                            inactiveNodes.splice(i, 1);\n                        }\n                    }\n                }\n\n                // add the node back into the inactive nodes\n\n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps') {\n                    // put the node at the beginning of the inactive nodes\n                    inactiveNodes.splice(0, 0, node);\n                } else {\n                    // put the node after one of the inactive nodes\n\n                    var added = false;\n\n                    // loop through all the inactive nodes\n                    for (var i = 0; i < inactiveNodes.length; i++) {\n                        var inactiveNode = inactiveNodes[i];\n\n                        if (inactiveNode != null) {\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\n                                // we have found the position to place the node\n                                inactiveNodes.splice(i + 1, 0, node);\n                                added = true;\n                            }\n                        }\n                    }\n\n                    if (!added) {\n                        /*\n                         * we haven't added the node yet so we will just add it\n                         * to the end of the array\n                         */\n                        inactiveNodes.push(node);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove transitions that go into the group\n     * @param nodeId the group id\n     */\n    removeTransitionsIntoGroup(nodeId) {\n\n        if (nodeId != null) {\n\n            var group = this.getNodeById(nodeId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n\n                    // loop through all the children\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n\n                        if (childId != null) {\n                            this.removeTransitionsThatPointToNodeIdFromOutsideGroup(childId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove the transitions that point to the node that does not have\n     * the same parent\n     * @param nodeId remove transitions to this node\n     */\n    removeTransitionsThatPointToNodeIdFromOutsideGroup(nodeId) {\n\n        if (nodeId != null) {\n\n            // get the parent of the node\n            var parentGroupId = this.getParentGroupId(nodeId);\n\n            // get all the nodes that point to the node\n            var nodesThatPointToTargetNode = this.getNodesByToNodeId(nodeId);\n\n            if (nodesThatPointToTargetNode != null) {\n\n                // loop through all the nodes that point to the node\n                for (var n = 0; n < nodesThatPointToTargetNode.length; n++) {\n                    var nodeThatPointsToTargetNode = nodesThatPointToTargetNode[n];\n\n                    if (nodeThatPointsToTargetNode != null) {\n\n                        // get the parent of the node that points to the node target node\n                        var nodeThatPointsToTargetNodeParentGroupId = this.getParentGroupId(nodeThatPointsToTargetNode.id);\n\n                        if (parentGroupId != nodeThatPointsToTargetNodeParentGroupId) {\n                            /*\n                             * the parent groups are different so we will remove\n                             * the transition\n                             */\n                            this.removeTransition(nodeThatPointsToTargetNode, nodeId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove a transition\n     * @param node remove a transition in this node\n     * @param toNodeId remove the transition that goes to this node id\n     */\n    removeTransition(node, toNodeId) {\n\n        if (node != null && toNodeId != null) {\n\n            var transitionLogic = node.transitionLogic;\n\n            if (transitionLogic != null) {\n                var transitions = transitionLogic.transitions;\n\n                if (transitions != null) {\n\n                    // loop through all the transitions\n                    for (var t = 0; t < transitions.length; t++) {\n                        var transition = transitions[t];\n\n                        if (transition != null) {\n                            if (toNodeId === transition.to) {\n                                // we have found a transition that goes to the toNodeId\n\n                                // remove the transition\n                                transitions.splice(t, 1);\n                                t--;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove transitions that go out of the group\n     * @param nodeId the group id\n     */\n    removeTransitionsOutOfGroup(nodeId) {\n        if (nodeId != null) {\n            var group = this.getNodeById(nodeId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n\n                    // loop through all the child ids\n                    for (var c = 0; c < childIds.length; c++) {\n                        var childId = childIds[c];\n\n                        if (childId != null) {\n\n                            // get the transitions of the child\n                            var transitions = this.getTransitionsByFromNodeId(childId);\n\n                            if (transitions != null) {\n\n                                // loop through all the transitions\n                                for (var t = 0; t < transitions.length; t++) {\n                                    var transition = transitions[t];\n\n                                    if (transition != null) {\n\n                                        // get the to node id of the transition\n                                        var toNodeId = transition.to;\n\n                                        if (toNodeId != null) {\n\n                                            // get the parent group id of the toNodeId\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                                            if (nodeId != toNodeIdParentGroupId) {\n                                                /*\n                                                 * the parent group is different which means it is a\n                                                 * transition that goes out of the group\n                                                 */\n\n                                                // remove the transition\n                                                transitions.splice(t, 1);\n                                                t--;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Update the step transitions that point into the group we are moving\n     * For example\n     * group1 has children node1 and node2 (node2 transitions to node3)\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * group3 has children node5 and node6\n     * if we move group2 after group3 we will need to change the\n     * transition from node2 to node3 and make node2 transition to node5\n     * the result will be\n     * group1 has children node1 and node2 (node2 transitions to node5)\n     * group3 has children node5 and node6\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * note: the (node4 transition to node5) will be removed later\n     * when is called removeTransitionsOutOfGroup\n     * note: when group2 is added in a later function call, we will add\n     * the node6 to node3 transition\n     * @param groupThatTransitionsToGroupWeAreMoving the group object\n     * that transitions to the group we are moving. we may need to update\n     * the transitions of this group's children.\n     * @param groupIdWeAreMoving the group id of the group we are moving\n     */\n    updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\n\n        if (groupThatTransitionsToGroupWeAreMoving != null && groupIdWeAreMoving != null) {\n            var group = this.getNodeById(groupIdWeAreMoving);\n\n            if (group != null) {\n                // get all the nodes that have a transition to the node we are removing\n                var nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\n\n                // get the transitions of the node we are removing\n                var nodeToRemoveTransitionLogic = group.transitionLogic;\n                var nodeToRemoveTransitions = [];\n\n                if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n                    nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n                }\n\n                if (nodeToRemoveTransitions.length > 0) {\n\n                    // get the first group that comes after the group we are removing\n                    var firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\n                    var firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\n\n                    if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\n\n                        // get the group that comes after the group we are moving\n                        var groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\n\n                        // get child ids of the group that comes before the group we are moving\n                        var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n                        if (childIds != null) {\n\n                            // loop through all the children\n                            for (var c = 0; c < childIds.length; c++) {\n                                var childId = childIds[c];\n\n                                var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n\n                                if (transitionsFromChild != null) {\n\n                                    // loop through all the transitions from the child\n                                    for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                                        var transitionFromChild = transitionsFromChild[tfc];\n\n                                        if (transitionFromChild != null) {\n                                            var toNodeId = transitionFromChild.to;\n\n                                            // get the parent group id of the toNodeId\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                                            if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                                                // the transition is to a child in the group we are moving\n\n                                                if (groupNode.startId == null) {\n                                                    // change the transition to point to the after group\n                                                    transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\n                                                } else {\n                                                    // change the transition to point to the start id of the after group\n                                                    transitionFromChild.to = groupNode.startId;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the node ids and component ids in a node\n     * @param nodeId get the node ids and component ids in this node\n     * @returns an array of objects. the objects contain a node id\n     * and component id.\n     */\n    getNodeIdsAndComponentIds(nodeId) {\n\n        var nodeIdAndComponentIds = [];\n\n        if (nodeId != null) {\n\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n            if (nodeContent != null) {\n\n                var components = nodeContent.components;\n\n                if (components != null) {\n\n                    // loop through all the components in the node\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component != null) {\n\n                            var componentId = component.id;\n\n                            // create an object to hold the node id and component id\n                            var nodeIdAndComponentId = {};\n                            nodeIdAndComponentId.nodeId = nodeId;\n                            nodeIdAndComponentId.componentId = componentId;\n\n                            // add the object to the array\n                            nodeIdAndComponentIds.push(nodeIdAndComponentId);\n                        }\n                    }\n                }\n            }\n        }\n\n        return nodeIdAndComponentIds;\n    }\n\n    /**\n     * Get the show previous work node ids and component ids in a node\n     * @param nodeId get the show previous work node ids and component ids in\n     * this node\n     * @returns an array of objects. the objects contain a node id\n     * and component id.\n     */\n    getShowPreviousWorkNodeIdsAndComponentIds(nodeId) {\n\n        var nodeIdAndComponentIds = [];\n\n        if (nodeId != null) {\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n            if (nodeContent != null) {\n\n                var components = nodeContent.components;\n\n                if (components != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n\n                        if (component != null) {\n                            var showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n                            var showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n\n                            if (showPreviousWorkNodeId != null && showPreviousWorkComponentId != null) {\n\n                                // create an object to hold the node id and component id\n                                var nodeIdAndComponentId = {};\n                                nodeIdAndComponentId.nodeId = showPreviousWorkNodeId;\n                                nodeIdAndComponentId.componentId = showPreviousWorkComponentId;\n\n                                // add the object to the array\n                                nodeIdAndComponentIds.push(nodeIdAndComponentId);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return nodeIdAndComponentIds;\n    }\n\n    /**\n     * Check if we need to display the annotation to the student\n     * @param annotation the annotation\n     * @returns whether we need to display the annotation to the student\n     */\n    displayAnnotation(annotation) {\n\n        var result = true;\n\n        if (annotation != null) {\n            var nodeId = annotation.nodeId;\n            var componentId = annotation.componentId;\n\n            // get the component content\n            var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n            if (component != null) {\n                var componentType = component.type;\n\n                // get the component service\n                var componentService = this.$injector.get(componentType + 'Service');\n\n                if (componentService != null && componentService.displayAnnotation != null) {\n                    // check if we need to display the annotation to the student\n                    result = componentService.displayAnnotation(component, annotation);\n                    if (annotation.data != null && annotation.data.isGlobal && annotation.data.isPopup) {\n                        result = false;  // don't display annotation inline; it will be displayed in a popup\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Get the global annotation properties for the specified component and score, if exists.\n     * @param component the component content\n     * @param score the score we want the annotation properties for\n     * @returns the annotation properties for the given score\n     */\n    getGlobalAnnotationGroupByScore(component, score) {\n\n        let annotationGroup = null;\n\n        if (component.globalAnnotationSettings != null && component.globalAnnotationSettings.globalAnnotationGroups != null) {\n            let globalAnnotationGroups = component.globalAnnotationSettings.globalAnnotationGroups;\n            for (let g = 0; g < globalAnnotationGroups.length; g++) {\n                let globalAnnotationGroup = globalAnnotationGroups[g];\n                if (globalAnnotationGroup.enableCriteria != null && globalAnnotationGroup.enableCriteria.score != null) {\n                    let enableCriteriaScoreArray = globalAnnotationGroup.enableCriteria.score;\n                    for (let s = 0; s < enableCriteriaScoreArray.length; s++) {\n                        let enableCriteriaScore = enableCriteriaScoreArray[s];\n                        if (enableCriteriaScore == score) {\n                            annotationGroup = globalAnnotationGroup;\n                        }\n                    }\n                }\n            }\n        }\n\n        return annotationGroup;\n    }\n\n    /**\n     * Get the notification for the given score, if exists.\n     * @param component the component content\n     * @param previousScore the previousScore we want notification for, can be null, which means we just want to look at\n     * the currentScore\n     * @param currentScore the currentScore we want notification for\n     * @returns the notification for the given score\n     */\n    getNotificationByScore(component, previousScore, currentScore) {\n\n        let notificationResult = null;\n\n        if (component.notificationSettings != null && component.notificationSettings.notifications != null) {\n            let notifications = component.notificationSettings.notifications;\n            for (let n = 0; n < notifications.length; n++) {\n                let notification = notifications[n];\n                if (notification.enableCriteria != null && notification.enableCriteria.scoreSequence != null) {\n                    let scoreSequence = notification.enableCriteria.scoreSequence;\n\n                    if (scoreSequence != null) {\n\n                        /*\n                         * get the expected previous score and current score\n                         * that will satisfy the rule\n                         */\n                        let previousScoreMatch = scoreSequence[0];\n                        let currentScoreMatch = scoreSequence[1];\n\n                        if (previousScore == null) {\n                            // just matching on the current score\n                            if (previousScoreMatch == \"\" &&\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                                // found a match\n                                notificationResult = notification;\n                                break;\n                            }\n                        } else {\n                            if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                                /*\n                                 * the previous score and current score match the\n                                 * expected scores so we have found the rule we want\n                                 */\n                                notificationResult = notification;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return notificationResult;\n    }\n\n    /**\n     * Returns a project template for new projects\n     */\n    getNewProjectTemplate() {\n        return {\n            \"nodes\": [\n                {\n                    \"id\": \"group0\",\n                    \"type\": \"group\",\n                    \"title\": \"Master\",\n                    \"startId\": \"group1\",\n                    \"ids\": [\n                        \"group1\"\n                    ]\n                },\n                {\n                    \"id\": \"group1\",\n                    \"type\": \"group\",\n                    \"title\": \"First Activity\",\n                    \"startId\": \"\",\n                    \"ids\": [\n                    ],\n                    \"icons\": {\n                        \"default\": {\n                            \"color\": \"#2196F3\",\n                            \"type\": \"font\",\n                            \"fontSet\": \"material-icons\",\n                            \"fontName\": \"info\"\n                        }\n                    }\n                }\n            ],\n            \"constraints\": [],\n            \"startGroupId\": \"group0\",\n            \"startNodeId\": \"group0\",\n            \"navigationMode\": \"guided\",\n            \"layout\": {\n                \"template\": \"starmap|leftNav|rightNav\"\n            },\n            \"metadata\": {\n                \"title\": \"My New Project!\"\n            },\n            \"notebook\": {\n                \"enabled\": false,\n                \"label\": \"Notebook\",\n                \"enableAddNew\": true,\n                \"itemTypes\": {\n                    \"note\": {\n                        \"type\": \"note\",\n                        \"enabled\": true,\n                        \"enableLink\": true,\n                        \"enableAddNote\": true,\n                        \"enableClipping\": true,\n                        \"enableStudentUploads\": true,\n                        \"label\": {\n                            \"singular\": \"note\",\n                            \"plural\": \"notes\",\n                            \"link\": \"Notes\",\n                            \"icon\": \"note\",\n                            \"color\": \"#1565C0\"\n                        }\n                    },\n                    \"question\": {\n                        \"type\": \"question\",\n                        \"enabled\": false,\n                        \"enableLink\": true,\n                        \"enableClipping\": true,\n                        \"enableStudentUploads\": true,\n                        \"label\": {\n                            \"singular\": \"question\",\n                            \"plural\": \"questions\",\n                            \"link\": \"Questions\",\n                            \"icon\": \"live_help\",\n                            \"color\": \"#F57C00\"\n                        }\n                    },\n                    \"report\": {\n                        \"enabled\": false,\n                        \"label\": {\n                            \"singular\": \"report\",\n                            \"plural\": \"reports\",\n                            \"link\": \"Report\",\n                            \"icon\": \"assignment\",\n                            \"color\": \"#AD1457\"\n                        },\n                        \"notes\": [\n                            {\n                                \"reportId\": \"finalReport\",\n                                \"title\": \"Final Report\",\n                                \"description\": \"Final summary report of what you learned in this project\",\n                                \"prompt\": \"Use this space to write your final report using evidence from your notebook.\",\n                                \"content\": \"<h3>This is a heading</h3><p>This is a paragraph.</p>\"\n                            }\n                        ]\n                    }\n                }\n            },\n            \"inactiveGroups\": [],\n            \"inactiveNodes\": []\n        };\n    }\n    \n    /**\n     * Check if a node generates work by looking at all of its components\n     * @param nodeId the node id\n     * @return whether the node generates work\n     */\n    nodeHasWork(nodeId) {\n        var result = false;\n        \n        if (nodeId != null) {\n            \n            // get the node content object\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\n            \n            if (nodeContent != null) {\n                var components = nodeContent.components;\n                \n                if (components != null) {\n                    \n                    // loop through all the components in the node\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n                        \n                        if (component != null) {\n                            \n                            // check if the component generates work\n                            var componentHasWork = this.componentHasWork(component);\n                            \n                            if (componentHasWork) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Check if a component generates work\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @return whether the component generates work\n     */\n    componentHasWorkByNodeIdAndComponentId(nodeId, componentId) {\n        var result = false;\n        \n        if (nodeId != null) {\n            \n            // get the node content object\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\n            \n            if (nodeContent != null) {\n                var components = nodeContent.components;\n                \n                if (components != null) {\n                    \n                    // loop through the components\n                    for (var c = 0; c < components.length; c++) {\n                        var component = components[c];\n                        \n                        if (component != null && componentId == component.id) {\n                            // we have found the component we are looking for\n                            \n                            // check if the component generates work\n                            var componentHasWork = this.componentHasWork(component);\n                            \n                            if (componentHasWork) {\n                                // the component generates work\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Check if a component generates work\n     * @param component check if this component generates work\n     * @return whether the component generates work\n     */\n    componentHasWork(component) {\n        var result = false;\n        \n        if (component != null) {\n            var componentType = component.type;\n            \n            // get the component service\n            var componentService = this.getComponentService(componentType);\n            \n            if (componentService != null) {\n                // check if the component generates work\n                result = componentService.componentHasWork(component);\n            }\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Get a component service\n     * @param componentType the component type\n     * @return the component service\n     */\n    getComponentService(componentType) {\n        \n        var componentService = null;\n        \n        if (componentType != null) {\n            \n            // get the component service name e.g. 'OpenResponseService'\n            var componentServiceName = componentType + 'Service';\n            \n            /*\n             * check if we have previously retrieved the component service.\n             * if have previously retrieved the component service it will\n             * be in the componentServices map\n             */\n            componentService = this.componentServices[componentServiceName];\n            \n            if (componentService == null) {\n                /*\n                 * we have not previously retrieved the component service so\n                 * we will get it now\n                 */\n                componentService = this.$injector.get(componentServiceName);\n                \n                /*\n                 * save the component service to the map so we can easily\n                 * retrieve it later\n                 */\n                this.componentServices[componentServiceName] = componentService;\n            }\n        }\n        \n        return componentService;\n    }\n}\n\nProjectService.$inject = [\n    '$http',\n    '$injector',\n    '$q',\n    '$rootScope',\n    'ConfigService'\n];\n\nexport default ProjectService;\n"]}